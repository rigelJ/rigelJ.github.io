<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rigelj.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CS61A 数据抽象目录 数据抽象导引  构造器与选择器 序对的表示 抽象屏障与序对的过程性表示  层次性数据和闭包性质  序列的表示形式 可变数据与可变函数 层次性结构 迭代器与生成器   带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。 数据抽象导引 在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61A-数据抽象">
<meta property="og:url" content="http://rigelj.github.io/posts/e999557a/index.html">
<meta property="og:site_name" content="Klein Bottle">
<meta property="og:description" content="CS61A 数据抽象目录 数据抽象导引  构造器与选择器 序对的表示 抽象屏障与序对的过程性表示  层次性数据和闭包性质  序列的表示形式 可变数据与可变函数 层次性结构 迭代器与生成器   带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。 数据抽象导引 在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-28T03:25:57.000Z">
<meta property="article:modified_time" content="2023-04-05T02:36:53.671Z">
<meta property="article:author" content="Klein">
<meta property="article:tag" content="程序结构">
<meta property="article:tag" content="CS61">
<meta property="article:tag" content="CS61A">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rigelj.github.io/posts/e999557a/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CS61A-数据抽象 | Klein Bottle</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Klein Bottle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Klein Bottle</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">以我为名的小说，是隽永或是深刻。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rigelj.github.io/posts/e999557a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Klein">
      <meta itemprop="description" content="Now you see me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klein Bottle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS61A-数据抽象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-28 11:25:57" itemprop="dateCreated datePublished" datetime="2021-06-28T11:25:57+08:00">2021-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-05 10:36:53" itemprop="dateModified" datetime="2023-04-05T10:36:53+08:00">2023-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learning-Record/" itemprop="url" rel="index"><span itemprop="name">Learning Record</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="CS61A-数据抽象"><a href="#CS61A-数据抽象" class="headerlink" title="CS61A 数据抽象"></a>CS61A 数据抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>数据抽象导引</p>
<ul>
<li>构造器与选择器</li>
<li>序对的表示</li>
<li>抽象屏障与序对的过程性表示</li>
</ul>
<p>层次性数据和闭包性质</p>
<ul>
<li>序列的表示形式</li>
<li>可变数据与可变函数</li>
<li>层次性结构</li>
<li>迭代器与生成器</li>
</ul>
</blockquote>
<p><strong>带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。</strong></p>
<h3 id="数据抽象导引"><a href="#数据抽象导引" class="headerlink" title="数据抽象导引"></a>数据抽象导引</h3><hr>
<p>在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。</p>
<p><strong>数据抽象就是指将数据对象组合起来，构成复合数据的形式。</strong></p>
<p>这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adder_without</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> (ad+bc)//bd</span><br><span class="line"></span><br><span class="line">如果我们要计算<span class="number">1</span>/<span class="number">3</span>+<span class="number">4</span>/<span class="number">5</span>，那么我们就得这样传入参数</span><br><span class="line"></span><br><span class="line">&gt;&gt;adder_without(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">17</span>/<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。</p>
<p>但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？</p>
<p>答案就是构建构造函数与选择函数。</p>
<h4 id="构造器与选择器"><a href="#构造器与选择器" class="headerlink" title="构造器与选择器"></a>构造器与选择器</h4><p>接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">up,down</span>)：</span><br><span class="line">    <span class="keyword">return</span> [up,down]</span><br><span class="line"></span><br><span class="line">于是我们可以利用分子分母构建有理数a和b</span><br><span class="line"></span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>/<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">build</span> up down) (<span class="name"><span class="built_in">cons</span></span> up down)</span><br></pre></td></tr></table></figure>

<p>而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_up</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_down</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">于是我们就可以使用以上两个函数提取数据</span><br><span class="line"></span><br><span class="line">a_up = get_up(a)</span><br><span class="line">b_down = get_down(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用构造器与选择器重写加法函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)</span><br><span class="line"></span><br><span class="line">使用构造函数</span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">new = add(a,b)</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立<code>sub</code>,<code>mul</code>,<code>pow</code>等运算函数。</p>
<h4 id="序对的表示"><a href="#序对的表示" class="headerlink" title="序对的表示"></a>序对的表示</h4><p>其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   <span class="type">List</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="type">Tuple</span></span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125; <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line">Python中万物皆对象，所以提取数据的方式非常简单</span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line">b[<span class="number">1</span>]</span><br><span class="line">c[<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>在scheme语言中，序对表示为cons，但是cons只能有两个数据：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> x (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> <span class="number">2</span>)   #相当于x = [<span class="name">1</span>,<span class="number">2</span>],但是scheme没有python高级，实现序列需要cons函数</span><br><span class="line">  </span><br><span class="line">使用 car 和 cdr 提取数据</span><br><span class="line">(<span class="name"><span class="built_in">car</span></span> x)</span><br><span class="line">(<span class="name"><span class="built_in">cdr</span></span> x)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="抽象屏障与序对的过程性表示"><a href="#抽象屏障与序对的过程性表示" class="headerlink" title="抽象屏障与序对的过程性表示"></a>抽象屏障与序对的过程性表示</h4><p>抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最高层： 使用有理数运算函数的过程</span><br><span class="line"></span><br><span class="line">第一层： 有理数运算函数 add() sub() mul() </span><br><span class="line"></span><br><span class="line">第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）</span><br><span class="line">                                             </span><br><span class="line">第三层： 作为序对的有理数 cons() car()  cdr()  /list[]  tuple[]</span><br></pre></td></tr></table></figure>

<p>这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。</p>
<p>例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">up,down</span>): </span><br><span class="line">    g = gcd(up,down)</span><br><span class="line">    <span class="keyword">return</span> [up/g,down/g]</span><br></pre></td></tr></table></figure>

<p>这样就完成了约分有理数的过程。</p>
<p>一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">cons</span></span> x y))</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">dispatch</span> m))</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span> (<span class="name"><span class="built_in">=</span></span> m <span class="number">0</span>) x)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span> (<span class="name"><span class="built_in">=</span></span> m <span class="number">1</span>) y)</span><br><span class="line">    (<span class="name"><span class="built_in">else</span></span> (<span class="name">error</span>))</span><br><span class="line">    dispatch)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">car</span></span> z) (<span class="name">z</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">cdr</span></span> z) (<span class="name">z</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>由此我们可以看出，序对的概念实际上也可以解释为，由<code>(cons x y)</code>返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。</p>
<p>SICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？</p>
<p>答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(f(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上<code>one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) </code>),把这个结构抽象出来就得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们要实现 two = successor(one)</span><br><span class="line">所以 two = <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(one(f)(x))</span><br><span class="line">令one = n 则有</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(n(f)(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def church_to_int(n):</span><br><span class="line">    return n(lambda x:x+1)(0)</span><br><span class="line"></span><br><span class="line">这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;church_to_int(one)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt;church_to_int(three)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>同样也可以对church对象进行加法运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_church</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; church_to_int(add_church(two, three))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#church_to_int() if return 5 then five return five(f)</span></span><br><span class="line">    <span class="comment">#so we have to make add_church(two,three) like five(f)</span></span><br><span class="line">    <span class="comment">#five(f) return lambda x:f(f(f(f(f(x)))))  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(f)(x) +m(f)(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SICP中有church计数的scheme实现过程，大体类似。</p>
<h3 id="层次性数据和闭包性质"><a href="#层次性数据和闭包性质" class="headerlink" title="层次性数据和闭包性质"></a>层次性数据和闭包性质</h3><p>我们可以建立元素本身也是序对&#x2F;序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。</p>
<h4 id="序列的表示形式"><a href="#序列的表示形式" class="headerlink" title="序列的表示形式"></a>序列的表示形式</h4><p>在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> </span><br><span class="line">   (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> </span><br><span class="line">       (<span class="name"><span class="built_in">cons</span></span> <span class="number">3</span> nil)))</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">list(<span class="name">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">def lists (<span class="name"><span class="built_in">list</span></span>(<span class="name">1</span>,<span class="number">2</span>,<span class="number">3</span>)):</span><br></pre></td></tr></table></figure>

<p>通过上面的方式构建起<code>lists</code>这个表对象，而后使用cdr和car对表对象包含的数据进行调用</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">car</span></span> lists)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="name"><span class="built_in">cdr</span></span> lists)</span><br><span class="line">(<span class="name">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="built_in">car</span></span>(<span class="name"><span class="built_in">cdr</span></span> lists))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>我们也可以构建函数返回表中的第n个项：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">list-n</span> list n))</span><br><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">car</span></span> list)</span><br><span class="line">      (<span class="name">list-n</span> (<span class="name"><span class="built_in">cdr</span></span> items) (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">于是对lists对象使用</span><br><span class="line">    </span><br><span class="line">(<span class="name">list-n</span> lists <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>scheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样的过程只需要</span><br><span class="line"></span><br><span class="line">lists = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">调用返回第n项也只需要</span><br><span class="line"></span><br><span class="line">a = lists[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>



<h4 id="可变数据与可变函数"><a href="#可变数据与可变函数" class="headerlink" title="可变数据与可变函数"></a>可变数据与可变函数</h4><p>由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&lt;stat&gt;)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">min</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,key=)</span><br><span class="line"><span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">any</span>()</span><br><span class="line"><span class="built_in">bool</span>()</span><br></pre></td></tr></table></figure>

<p>以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于<strong>可变序列</strong>，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可变序列：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].append(<span class="string">&#x27;a&#x27;</span>)   </span><br><span class="line">dicts[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">不可变序列</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.append(<span class="string">&#x27;a&#x27;</span>)    Error</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>).append(<span class="string">&#x27;a&#x27;</span>)   Error</span><br></pre></td></tr></table></figure>

<p>具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表<code>list1 = [1,2,3,4]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    list1.append(x)</span><br><span class="line">    list1.append(x)</span><br><span class="line"></span><br><span class="line">执行func(<span class="number">3</span>)后list1会改变吗？</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;func(<span class="number">3</span>)</span><br><span class="line">&lt;&lt;&lt;list1</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。</span><br></pre></td></tr></table></figure>

<p>有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_money</span>(<span class="params">my_money</span>):</span><br><span class="line">     my_money -=<span class="number">20</span></span><br><span class="line">     <span class="keyword">return</span> my_money</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;my_money = <span class="number">100</span></span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money</span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>我们会发现这种方式很麻烦，因为要不断返回和重新赋值给<code>my_money</code>变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？</p>
<p>有的，那就是<strong>可变函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_draw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_draw</span>(<span class="params">acount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            balance = balance - acount</span><br><span class="line">            <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里出现了一个新的类型<code>nonlocal</code>，意思是非本地，也就是说，定义为<code>nonlocal</code>的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 <code>nonlocal</code>必须满足以下几个条件才能使用：</p>
<blockquote>
<p>1.nonlocal 声明的变量必须存在于父框架</p>
<p>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。</p>
</blockquote>
<p>我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？</p>
<p>答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于<code>balance=balance-accont</code>这个表达式判断balance是本地变量，而后在<code>if account &gt; balance</code>中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）</p>
<p>有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_draw</span>(<span class="params">balance</span>):</span><br><span class="line">    b= []</span><br><span class="line">    b[<span class="number">0</span>] = balance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_draw</span>(<span class="params">acount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b[<span class="number">0</span>] = b[<span class="number">0</span>] - acount</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。</p>
<h4 id="层次性结构"><a href="#层次性结构" class="headerlink" title="层次性结构"></a>层次性结构</h4><p>序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> branches(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> is_tree(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="params">tree</span>) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(<span class="params">tree</span>) &lt; <span class="number">1</span>:</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> <span class="literal">False</span></span></span><br><span class="line"><span class="params">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(<span class="params">branch</span>):</span></span><br><span class="line"><span class="params">            <span class="keyword">return</span> <span class="literal">False</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">True</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> is_leaf(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span></span><br><span class="line"><span class="string"><span class="params">    otherwise.</span></span></span><br><span class="line"><span class="string"><span class="params">    &quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="keyword">not</span> branches(<span class="params">tree</span>)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> print_tree(<span class="params">t, indent=<span class="number">0</span></span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span></span><br><span class="line"><span class="string"><span class="params">    indented by two spaces times its depth from the root.</span></span></span><br><span class="line"><span class="string"><span class="params"></span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; print_tree(tree(1))</span></span></span><br><span class="line"><span class="string"><span class="params">    1</span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span></span><br><span class="line"><span class="string"><span class="params">    1</span></span></span><br><span class="line"><span class="string"><span class="params">      2</span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; print_tree(numbers)</span></span></span><br><span class="line"><span class="string"><span class="params">    1</span></span></span><br><span class="line"><span class="string"><span class="params">      2</span></span></span><br><span class="line"><span class="string"><span class="params">      3</span></span></span><br><span class="line"><span class="string"><span class="params">        4</span></span></span><br><span class="line"><span class="string"><span class="params">        5</span></span></span><br><span class="line"><span class="string"><span class="params">      6</span></span></span><br><span class="line"><span class="string"><span class="params">        7</span></span></span><br><span class="line"><span class="string"><span class="params">    &quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="built_in">print</span>(<span class="params"><span class="string">&#x27;  &#x27;</span> * indent + <span class="built_in">str</span>(<span class="params">label(<span class="params">t</span>)</span>)</span>)</span></span><br><span class="line"><span class="params">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(<span class="params">t</span>):</span></span><br><span class="line"><span class="params">        print_tree(<span class="params">b, indent + <span class="number">1</span></span>)</span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure>

<p>以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。</p>
<p>递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。</p>
<p>我们来看几个关于树结构的问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">问题一：替换具有指定数据的树节点</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_leaf</span>(<span class="params">t, old, new</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to old has</span></span><br><span class="line"><span class="string">    been replaced with new.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,</span></span><br><span class="line"><span class="string">    ...                  [tree(&#x27;balder&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;freya&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;frigg&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;sif&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))</span></span><br><span class="line"><span class="string">    odin</span></span><br><span class="line"><span class="string">      balder</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      frigg</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      thor</span></span><br><span class="line"><span class="string">        sif</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      freya</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">if</span> label(t)==old:</span><br><span class="line">            <span class="keyword">return</span> tree(new)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tree(label(t))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_leaf(b,old,new) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line">可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">问题二：在每个叶节点上插入新子树</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, vals</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in vals at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">          6</span></span><br><span class="line"><span class="string">          1</span></span><br><span class="line"><span class="string">          2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(s) <span class="keyword">for</span> s <span class="keyword">in</span> vals ])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        lsb = []</span></span><br><span class="line"><span class="string">        for b in branches(t):</span></span><br><span class="line"><span class="string">            lsb += sprout_leaves(b,vals)</span></span><br><span class="line"><span class="string">        return [tree(label(t),lsb)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[sprout_leaves(b,vals) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure>

<p>下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">问题三：对应树的相加</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_trees</span>(<span class="params">t1, t2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; numbers = tree(1,</span></span><br><span class="line"><span class="string">    ...                [tree(2,</span></span><br><span class="line"><span class="string">    ...                      [tree(3),</span></span><br><span class="line"><span class="string">    ...                       tree(4)]),</span></span><br><span class="line"><span class="string">    ...                 tree(5,</span></span><br><span class="line"><span class="string">    ...                      [tree(6,</span></span><br><span class="line"><span class="string">    ...                            [tree(7)]),</span></span><br><span class="line"><span class="string">    ...                       tree(8)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(numbers, numbers))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">        6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">      10</span></span><br><span class="line"><span class="string">        12</span></span><br><span class="line"><span class="string">          14</span></span><br><span class="line"><span class="string">        16</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \</span></span><br><span class="line"><span class="string">    tree(2, [tree(3, [tree(4)]), tree(5)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t1) <span class="keyword">and</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span>(tree(label(t1)+label(t2)))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t1):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t2))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lsp = []</span><br><span class="line">        node = label(t1)+label(t2)</span><br><span class="line">        zips = <span class="built_in">list</span>(<span class="built_in">zip</span>(branches(t1),branches(t2)))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t1)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t2)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t2)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t1)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里所用到的zip函数请自行查阅python指南，解答过程如上。</p>
<h4 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h4><p>Python和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。</p>
<p>迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   迭代值</span><br><span class="line">iters = <span class="built_in">iter</span>(prime)  迭代器</span><br></pre></td></tr></table></figure>

<p>利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line">StopIteration </span><br></pre></td></tr></table></figure>

<p>当到达处理序列末尾后再次调用<code>next</code>方法将会引发StopIteration异常，说明序列已经迭代完毕。</p>
<p>两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  =  <span class="built_in">range</span> ( <span class="number">3</span> ,  <span class="number">13</span> ) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第一个迭代器s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第二个迭代器t </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u  =  <span class="built_in">iter</span>(t)  <span class="comment"># 第二个迭代器的替代名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>这里有一个利用迭代器计算斐波纳契数列的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_iter</span>(<span class="params">n</span>):</span><br><span class="line">    prev,curr=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="built_in">list</span> = [prev,curr]</span><br><span class="line">    index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        prev,curr = curr,prev+curr</span><br><span class="line">        <span class="built_in">list</span> +=[curr]</span><br><span class="line">        index ++</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。</p>
<p>生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素</p>
<p>生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">letters_generator</span>():</span><br><span class="line">    current = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> current &lt;=<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">yield</span> current</span><br><span class="line">        current =<span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;letters = letters_generator()</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(letters)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>再复杂一点可以这样使用生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">natural</span>():</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">        x+<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;ns1,ns2=natural(),natural()</span><br><span class="line">&gt;&gt;&gt;[<span class="built_in">next</span>(ns1)*<span class="built_in">next</span>(ns2) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/" rel="tag"># 程序结构</a>
              <a href="/tags/CS61/" rel="tag"># CS61</a>
              <a href="/tags/CS61A/" rel="tag"># CS61A</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/d5dca63c/" rel="prev" title="CS61A-过程抽象">
      <i class="fa fa-chevron-left"></i> CS61A-过程抽象
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/443f5291/" rel="next" title="CS61A-对象抽象">
      CS61A-对象抽象 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CS61A-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">CS61A 数据抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.0.1.</span> <span class="nav-text">目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E5%AF%BC%E5%BC%95"><span class="nav-number">1.1.</span> <span class="nav-text">数据抽象导引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">构造器与选择器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.1.2.</span> <span class="nav-text">序对的表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B1%8F%E9%9A%9C%E4%B8%8E%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%BF%87%E7%A8%8B%E6%80%A7%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.1.3.</span> <span class="nav-text">抽象屏障与序对的过程性表示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E6%80%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E9%97%AD%E5%8C%85%E6%80%A7%E8%B4%A8"><span class="nav-number">1.2.</span> <span class="nav-text">层次性数据和闭包性质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">序列的表示形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">可变数据与可变函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">层次性结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">迭代器与生成器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Klein</p>
  <div class="site-description" itemprop="description">Now you see me</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Klein</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">100k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:31</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

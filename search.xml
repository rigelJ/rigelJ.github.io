<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS61A-元语言抽象</title>
    <url>/posts/4e5dc807/</url>
    <content><![CDATA[<h2 id="CS61A-元语言抽象"><a href="#CS61A-元语言抽象" class="headerlink" title="CS61A 元语言抽象"></a>CS61A 元语言抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>Scheme语言</p>
<ul>
<li>表达式</li>
<li>控制结构与列表</li>
<li>定义变量与函数</li>
<li>匿名过程</li>
</ul>
<p>Scheme语言特性</p>
<ul>
<li>宏</li>
<li>流</li>
</ul>
<p>抽象语言的解释器</p>
<ul>
<li>解释器的实现</li>
<li>读取过程</li>
<li>评估过程</li>
<li>输出过程</li>
</ul>
</blockquote>
<p>在之前的章节中，我们都是基于一门语言去研究程序的抽象形式，而本 书的最后一个部分直接跳出了语言，讲解一门语言是怎么样抽象的，也就是说，这一章，是在教你如何实现一门语言，我们这里所说的语言是脚本语言，接下来，我们就要以Scheme语言为例，讲解Scheme语言是怎么样一步一步构造出来的。</p>
<h3 id="Scheme语言"><a href="#Scheme语言" class="headerlink" title="Scheme语言"></a>Scheme语言</h3><p>首先我们从使用者的角度了解一下Scheme的语法。</p>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>最基础的表达式可以是数字，布尔值或者符号，这里的符号是我们在Python语言中唯一没有遇到的类型，具体来说，Scheme中的符号也是一种值。</p>
<h5 id="原子表达式"><a href="#原子表达式" class="headerlink" title="原子表达式"></a>原子表达式</h5><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; <span class="number">1234</span>    <span class="comment">; integer</span></span><br><span class="line"><span class="number">1234</span></span><br><span class="line">scm&gt; <span class="number">123.4</span>   <span class="comment">; real number</span></span><br><span class="line"><span class="number">123.4</span></span><br></pre></td></tr></table></figure>

<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; #t</span><br><span class="line">#t</span><br><span class="line">scm&gt; #f</span><br><span class="line">#f</span><br></pre></td></tr></table></figure>

<p>在 Scheme 中，除了特殊的布尔值#f之外的所有值都被解释为真值（与 Python 不同，Python 中有一些像0那样的假值）</p>
<h5 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h5><p>其中，符号类型是我们在 Python 中唯一没有遇到的类型。一个 符号的作用很像一个Python的名字，但不完全是。具体来说，Scheme 中的符号也是一种值。在 Python 中，名称仅用作表达式；Python 表达式永远不能计算为名称。</p>
<p>这个过程具体是怎么实现的，我们后面再讲。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; quotient      <span class="comment">; A name bound to a built-in procedure</span></span><br><span class="line">#[<span class="name"><span class="built_in">quotient</span></span>]</span><br><span class="line">scm&gt; <span class="symbol">&#x27;quotient</span>     <span class="comment">; An expression that evaluates to a symbol</span></span><br><span class="line">quotient</span><br><span class="line">scm&gt; <span class="symbol">&#x27;hello-world!</span></span><br><span class="line">hello-world!</span><br></pre></td></tr></table></figure>

<h4 id="调用表达式"><a href="#调用表达式" class="headerlink" title="调用表达式"></a>调用表达式</h4><p>与 Python 一样，Scheme 调用表达式中的运算符位于所有操作数之前。与 Python 不同的是，运算符包含在括号内，并且操作数由空格而不是逗号分隔。然而，Scheme 调用表达式的计算遵循与 Python 完全相同的规则：</p>
<p>1.评估操作符，应该评估为一个过程</p>
<p>2.从左到右评估操作数</p>
<p>3.操作数应用于过程</p>
<p>以下是一些使用内置过程的示例：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">-</span></span> <span class="number">10</span> (<span class="name"><span class="built_in">/</span></span> <span class="number">6</span> <span class="number">2</span>))</span><br><span class="line"><span class="number">7</span></span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">modulo</span></span> <span class="number">35</span> <span class="number">4</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">even?</span></span> (<span class="name"><span class="built_in">quotient</span></span> <span class="number">45</span> <span class="number">2</span>))</span><br><span class="line">#t</span><br></pre></td></tr></table></figure>

<h4 id="控制结构与列表"><a href="#控制结构与列表" class="headerlink" title="控制结构与列表"></a>控制结构与列表</h4><h5 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h5><p>该if特殊形式使我们能够评估基于谓词两个表达式之一。它接受两个必需的参数和一个可选的第三个参数：</p>
<blockquote>
<p>(if <predicate> <if-true> [if-false])</p>
</blockquote>
<p>第一个操作数是Scheme 中所谓的谓词表达式，该表达式的值被解释为#tor 或#f。</p>
<p>计算if特殊形式表达式的规则如下：</p>
<p>1.评估<predicate>。<br>2.如果<predicate>评估为真值，则评估并返回该值，如果表达式<if-true>. 否则，[if-false]如果提供，则评估并返回值 。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> x <span class="number">3</span>)</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">         <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在 Scheme 中，您不能编写elif案例。如果要使用if表达式有多个案例，则需要多个分支if表达式：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">         <span class="symbol">&#x27;negative</span></span><br><span class="line">         (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> x <span class="number">0</span>)</span><br><span class="line">             <span class="symbol">&#x27;zero</span></span><br><span class="line">             <span class="symbol">&#x27;positive</span></span><br><span class="line">         )</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h5 id="cond表达式"><a href="#cond表达式" class="headerlink" title="cond表达式"></a>cond表达式</h5><p>使用嵌套if表达式似乎不是处理多种情况的非常实用的方法。相反，我们可以使用cond特殊形式，一种类似于 Python 中的多子句 if&#x2F;elif&#x2F;else 条件表达式的通用条件表达式。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">    (<span class="name">&lt;p1&gt;</span> &lt;e1&gt;)</span><br><span class="line">    (<span class="name">&lt;p2&gt;</span> &lt;e2&gt;)</span><br><span class="line">    ...</span><br><span class="line">    (<span class="name">&lt;pn&gt;</span> &lt;en&gt;)</span><br><span class="line">    [(<span class="name"><span class="built_in">else</span></span> &lt;else-expression&gt;)])</span><br></pre></td></tr></table></figure>

<p>评价规则如下：</p>
<p>1.对谓词<p1>, <p2>, …,<pn>进行求值，直到达到求值为真 y 值的谓词为止。<br>2.如果您到达一个计算结果为真值的谓词，请计算并返回子句中的相应表达式。<br>3.如果没有一个谓词是真y并且有一个else子句，则评估并返回<else-expression>。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">        ((<span class="name"><span class="built_in">&gt;</span></span> x <span class="number">0</span>) <span class="symbol">&#x27;positive</span>)</span><br><span class="line">        ((<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>) <span class="symbol">&#x27;negative</span>)</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> <span class="symbol">&#x27;zero</span>))</span><br></pre></td></tr></table></figure>

<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><h6 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h6><p>Scheme 列表与我们在 Python 中使用的链表非常相似。就像链表是由一系列Link 对象构建的一样，Scheme 列表是由一系列对构建的，这些对是由构造函数创建的cons，是一种可递归对象。</p>
<p>Scheme列表要cdr是另一个列表或nil空列表。列表在解释器中显示为值序列（类似于对象的 __str__表示Link）。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">3</span> nil)))</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>具体的实现方式用图像来表示就是</p>
<p><img src="https://i.loli.net/2021/08/10/Le2kpYIwaAgWN8E.png" alt="image-20210810094539083"></p>
<p>我们可以使用car和cdr从我们的列表中检索值，现在它的工作方式类似于 PythonLink的first和rest属性。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">define</span></span> a (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">3</span> nil))))  <span class="comment">; Assign the list to the name a</span></span><br><span class="line">scm&gt; a</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">car</span></span> a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">cdr</span></span> a)</span><br><span class="line">(<span class="name">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">car</span></span> (<span class="name"><span class="built_in">cdr</span></span> (<span class="name"><span class="built_in">cdr</span></span> a)))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果您没有将 pair 或 nil 作为第二个参数传递给cons，则会出错：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">Error</span><br></pre></td></tr></table></figure>

<h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>另一种创建列表的方式是利用list，该list过程接受任意数量的参数并使用这些参数的值构造一个列表</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">list</span></span> <span class="number">2</span> <span class="number">3</span>) <span class="number">4</span>)</span><br><span class="line">(<span class="name">1</span> (<span class="name">2</span> <span class="number">3</span>) <span class="number">4</span>)</span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">list</span></span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> nil)) <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">((<span class="name">1</span> <span class="number">2</span>) <span class="number">3</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>请注意，此表达式中的所有操作数在放入结果列表之前都会进行评估。</p>
<h6 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h6><p>我们还可以使用引用形式来创建一个列表，通过引用形式创建的列表不进评估</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; &#x27;(cons <span class="number">1</span> <span class="number">2</span>)           <span class="comment">; Argument to quote is not evaluated</span></span><br><span class="line">(<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">scm&gt; &#x27;(<span class="number">1</span> (<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name">1</span> (<span class="name">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h4 id="定义变量与函数"><a href="#定义变量与函数" class="headerlink" title="定义变量与函数"></a>定义变量与函数</h4><p>在Python中定义变量使用&#x3D;号进行，而定义变量使用def进行，而在Scheme中定义变量和过程都使用define语法，这个在后期解释器的构造中我也会着重细讲。</p>
<p>定义变量，我们使用语法</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> &lt;name&gt; &lt;expression&gt;)</span><br></pre></td></tr></table></figure>

<p>评估这个表达式的规则是</p>
<p>1.评估<expression>.<br>2.将其值绑定到<name>当前Frame中。<br>3.返回<name>。</p>
<p>定义过程，我们使用语法</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">&lt;name&gt;</span> &lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt; )</span><br></pre></td></tr></table></figure>

<p>要评估此表达式：</p>
<p>1.使用给定的参数和 来创建一个 lambda 过程<body>。<br>2.将过程绑定到<name>当前帧中的 。<br>3.返回<name>。</p>
<p>以下两个表达式是等价的：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">define</span></span> foo (<span class="name"><span class="built_in">lambda</span></span> (x y) (<span class="name"><span class="built_in">+</span></span> x y)))</span><br><span class="line">foo</span><br><span class="line">scm&gt; (<span class="name"><span class="built_in">define</span></span> (<span class="name">foo</span> x y) (<span class="name"><span class="built_in">+</span></span> x y))</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<h4 id="匿名过程"><a href="#匿名过程" class="headerlink" title="匿名过程"></a>匿名过程</h4><p>所有 Scheme 过程都是 lambda 过程。要创建 lambda 过程，我们可以使用lambda特殊形式</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">lambda</span></span> (&lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt;)</span><br></pre></td></tr></table></figure>

<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">lambda</span></span> (x y) (<span class="name"><span class="built_in">+</span></span> x y))        <span class="comment">; Returns a lambda function, but doesn&#x27;t assign it to a name</span></span><br><span class="line">(<span class="name"><span class="built_in">lambda</span></span> (x y) (<span class="name"><span class="built_in">+</span></span> x y))</span><br><span class="line">scm&gt; ((<span class="name"><span class="built_in">lambda</span></span> (x y) (<span class="name"><span class="built_in">+</span></span> x y)) <span class="number">3</span> <span class="number">4</span>)  <span class="comment">; Create and call a lambda function in one line</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>一个过程可以接受任意数量的参数。该<body>可以包含多个表达式。return Scheme 中没有 Python语句的等效版本。该函数将简单地返回正文中最后一个表达式的值。</p>
<h3 id="Scheme语言特性"><a href="#Scheme语言特性" class="headerlink" title="Scheme语言特性"></a>Scheme语言特性</h3><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><h5 id="Define-macro"><a href="#Define-macro" class="headerlink" title="Define-macro"></a>Define-macro</h5><p>宏是一个不好理解的概念，但是却是一个非常重要的概念，我们刚才已经介绍了define的用法，下面我们使用define来定义一个过程</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> twice(<span class="name">f</span>)</span><br><span class="line">  (<span class="name"><span class="built_in">begin</span></span> f f))</span><br></pre></td></tr></table></figure>

<p>当我们输入<code>（twice （print &#39;woof））</code>我们希望能输出两次woof，然而</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name">twice</span> (<span class="name">print</span> <span class="symbol">&#x27;woof</span>))</span><br><span class="line">woof</span><br></pre></td></tr></table></figure>

<p>这是怎么回事呢？</p>
<p>我们一步一步来，首先我们对操作符twice进行评估，返回我们定义的twice过程，而后我们对<code>(print &#39;woof)</code>进行评估，打印woof，而后将返回的undefined值绑定到f，而后将操作数字应用于操作符，得到表达式<code>（begin undefined undefined）</code>对该表达式进行评估，无返回值</p>
<p>那么我们该怎么样修改才能得到正确输出呢？</p>
<p>我们想要最终评估的表达式是这样的，<code>begin （print &#39;woof）(print &#39;woof)</code> ，因此，我们想到一种办法</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">twice</span> f)</span><br><span class="line">  (<span class="name"><span class="built_in">eval</span></span> (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;begin</span> f f))</span><br></pre></td></tr></table></figure>

<p>为了保证最终评估的表达式是<code>begin （print &#39;woof）(print &#39;woof)</code> ，我们稍微改变了一下输入的值</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name">twice</span> &#x27;(print <span class="symbol">&#x27;woof</span>))</span><br><span class="line">woof</span><br><span class="line">woof</span><br></pre></td></tr></table></figure>

<p>这样我们就通过eval list返回的列表，完成了正确输出。</p>
<p>但是肯定有人会想，为什么要这么麻烦，在进入函数的时候用‘防止被eval，结果在出来的时候又得加个eval，那索性就直接让操作数不评估不就行了。</p>
<p>诶，没错，这个问题，前人已经考虑到了，而且他们还设计了一种语法来解决这个问题，这种语法被叫做macro，宏。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name">define-macro</span> (<span class="name">twice</span> f) (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;begin</span> f f))</span><br><span class="line">twice</span><br><span class="line">scm&gt; (<span class="name">twice</span> (<span class="name">print</span> <span class="symbol">&#x27;woof</span>))</span><br><span class="line">woof</span><br><span class="line">woof</span><br></pre></td></tr></table></figure>

<p>define-macro允许我们定义macro，这是我们将未计算的输入表达式组合到另一个表达式中的一种方式。当我们调用宏时，操作数不会被评估，而是被视为 Scheme 数据。这意味着任何作为调用表达式或特殊形式表达式的操作数都被视为列表。</p>
<p>在我们的例子中，我们需要一个如下所示的begin 表达式</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">begin</span></span> (<span class="name">print</span> <span class="symbol">&#x27;woof</span>) (<span class="name">print</span> <span class="symbol">&#x27;woof</span>))</span><br></pre></td></tr></table></figure>

<p>作为 Scheme 数据，这个表达式实际上只是一个包含三个元素的列表：begin和(print ‘woof)两次，这正是(list ‘begin f f)返回的内容。现在，当我们调用 时twice，这个列表被评估为一个表达式并被(print ‘woof)评估两次。</p>
<p>回顾一下，宏的调用方式与常规过程类似，但评估它们的规则不同。我们通过以下方式评估了 lambda 过程：</p>
<blockquote>
<p>1.评估运算符<br>2.评估操作数<br>3.将运算符应用于操作数，评估过程的主体</p>
</blockquote>
<p>但是，评估对宏过程调用的规则是：</p>
<blockquote>
<p>1.评估运算符<br>2.将运算符应用于未计算的操作数<br>3.评估宏在调用它的框架中返回的表达式。</p>
</blockquote>
<p>这种特性使得scheme语言具有很强的扩展性，可以随意设计各种不同的语法来进行运算，举个例子，如果我们想把Scheme的定义语法用Python的风格写出来，该怎么做呢？</p>
<p>这时候我们就可以利用宏来实现。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">def</span> func bindings body)</span><br><span class="line">    (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;define</span> (<span class="name"><span class="built_in">cons</span></span> func bindings) body))</span><br></pre></td></tr></table></figure>

<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&lt; (<span class="name">def</span> f(<span class="name">x</span> y) (<span class="name"><span class="built_in">+</span></span> x y))</span><br><span class="line">f</span><br></pre></td></tr></table></figure>

<p>这样我们就可以使用具有Python风格的语法来定义scheme函数了。</p>
<h5 id="Quasiquote"><a href="#Quasiquote" class="headerlink" title="Quasiquote"></a>Quasiquote</h5><p>回想一下，quote特殊形式会阻止 Scheme 解释器执行表达式,如果我们试图构建具有许多嵌套列表的复杂 Scheme 表达式，这种形式似乎会派上用场。</p>
<p>考虑我们将twice宏重写如下</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">twice</span> f)</span><br><span class="line">  &#x27;(begin f f))</span><br></pre></td></tr></table></figure>

<p>这似乎会产生相同的效果，但由于quote 表单阻止了任何评估，我们创建的结果表达式实际上是<code>(begin f f)</code>，这不是我们想要的。</p>
<p>乍一看，quasiquote（可以用反引号&#96;或quasiquote特殊形式调用）与quote的行为完全相同。但是，使用quasiquote可以使用逗号，从引用的上下文中删除一个表达式，对其进行评估，然后将其放回原处。</p>
<p>下面是我们如何使用 quasiquote 来重写我们之前的示例：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">twice</span> f)</span><br><span class="line">  `(begin ,f ,f))</span><br></pre></td></tr></table></figure>

<p>同样我们重写def实例：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">def</span> func bindings body)</span><br><span class="line">    `(define ,(cons func bindings) ,body))</span><br></pre></td></tr></table></figure>

<p>其执行结果不变。</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>在Python当中，我们使用迭代器和生成器来实现惰性求值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ints</span>(<span class="params">first</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> first</span><br><span class="line">        first += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = ints(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(s)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>然而，在Scheme语言中，没有迭代器和生成器，让我们看看如果我们使用scheme列表来进行循环迭代求值会产生什么情况。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">ints</span> first)</span><br><span class="line">    (<span class="name"><span class="built_in">cons</span></span> first (<span class="name">ints</span> (<span class="name"><span class="built_in">+</span></span> first <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name">ints</span> <span class="number">1</span>)</span><br><span class="line">maximum recursion depth exceeded</span><br></pre></td></tr></table></figure>

<p>由于cons是一个连续求值的过程，在cons结构建立之前，需要对所有值进行逐个评估，因此我们不能用cons创建一个无限循环的列表，然而，scheme解释器引入了流，流是一个特殊的scheme列表，在进行评估时，第一个值会进行评估，而第二个值会被保留，直到我们需要进行评估时才执行，在程序编写范式中，这种模式被称作惰性求值。</p>
<p>我们使用以下语法结构创建一个流</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">cons-stream</span> &lt;operand1&gt; &lt;operand2&gt;)</span><br></pre></td></tr></table></figure>

<p>我们以自然数无限循环列表为例讲解流的操作</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">ints</span> first)</span><br><span class="line">    (<span class="name">cons-stream</span> first</span><br><span class="line">                 (<span class="name">ints</span> (<span class="name"><span class="built_in">+</span></span> first <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name">ints</span> <span class="number">1</span>)</span><br><span class="line">(<span class="name">1</span> . #[<span class="name">promise</span> (<span class="name"><span class="built_in">not</span></span> forced)])</span><br></pre></td></tr></table></figure>

<p>可以看出，流在进行评估的时候，只会评估第一个值，而保留第二个值，而后返回一个列表。</p>
<p>我们首先将循环列表返回的值赋给一个变量a</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt;(<span class="name"><span class="built_in">define</span></span> a (<span class="name">int</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>而后我们对列表进行操作，如果我们仅使用cdr</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">cdr</span></span> (<span class="name">int</span> <span class="number">1</span>))</span><br><span class="line">#[<span class="name">promise</span> (<span class="name"><span class="built_in">not</span></span> forced)]</span><br></pre></td></tr></table></figure>

<p>我们发现依然没有评估，因为我们需要使用cdr-stream，才能让列表第二个值评估后返回。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name">cdr-stream</span> a)</span><br><span class="line">(<span class="name">2</span> . #[<span class="name">promise</span> (<span class="name"><span class="built_in">not</span></span> forced)])</span><br></pre></td></tr></table></figure>

<p>这样我们就能得到第二个值评估后的结果。</p>
<p>利用流能做些什么呢？我们举一个例子</p>
<p>假设我们有一个自然数循环列表，我们需要得到一个对每个值都运用函数后返回值构成的循环列表，那么我们该怎么做呢？</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">naturals</span> n)</span><br><span class="line">  (<span class="name">cons-stream</span> n (<span class="name">naturals</span> (<span class="name"><span class="built_in">+</span></span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> nat (<span class="name">naturals</span> <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">map-stream</span> f s)</span><br><span class="line">  (<span class="name">cons-stream</span> (<span class="name">f</span> (<span class="name"><span class="built_in">car</span></span> s)) (<span class="name">map-stream</span> f (<span class="name">cdr-stream</span> s))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> evens (<span class="name">map-stream</span> (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">*</span></span> x <span class="number">2</span>)) nat))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，我们创建一个循环列表，并将其赋给变量<code>nat</code>，而后我们创建一个<code>map-stream</code>函数，引入循环列表和一个匿名函数作为参数，再将返回的列表赋给变量<code>even</code>由于cons-stream惰性求值的性质，我们在得到第一个值后并不会继续评估，因此<code>even</code>就变成了返回两倍自然数的循环列表，是不是很有趣呢？</p>
<p>以上统统扯淡，看文档都能会，接下来进入正题。</p>
<h3 id="抽象语言的解释器"><a href="#抽象语言的解释器" class="headerlink" title="抽象语言的解释器"></a>抽象语言的解释器</h3><h4 id="解释器的实现"><a href="#解释器的实现" class="headerlink" title="解释器的实现"></a>解释器的实现</h4><p>这是一个非常庞大的项目，CS61A利用Python构建了一个Scheme的解释器，也就是说，当完成这个解释器之后，我们就可以利用自己写的解释器进行scheme文档的解释与输出了，其实所有的编程语言本质都是解释器，你必须要采用合理的解释器将计算机无法理解的语言转换成计算机可以理解的语言，这样才能实现各种功能。</p>
<p>整个解释器分为三个步骤，Read，Eval，Print，我们着重讲解前两个步骤。</p>
<p>单个Read部分，这一步将用户的输入解析为解释器内部的一种抽象数据类型，我们在Python中构建了Pair这个类来将用户的输入从字符串转换成类的实例对象，以便于下一步对输入的整个表达式进行操作，主要有词法分析和句法分析两个步骤。</p>
<p>Eval部分，这一步评估Scheme表达式以获得相应的值，我们知道，对于基础表达式例如 数字，布尔值，符号等来说，只需要对其进行评估后返回即可，而对于有操作符和操作数的调用表达式来说，我们要遵循调用表达式评估的顺序，忘记了？我们再来回顾一遍。</p>
<blockquote>
<p>1.评估操作符，应该评估为一个过程</p>
<p>2.从左到右评估操作数</p>
<p>3.操作数应用于过程</p>
</blockquote>
<p>操作符评估后，将会返回相应的过程，如果被求值的表达式是特殊形式，比如if,cond等等，将调用相应的函数进行操作，而后对操作数进行评估，注意，如果操作数也是调用表达式，那么依然要按顺序进行评估后返回。接下来就是将评估后的操作数应用于过程了，这里的过程有两种，一是内置过程，二是我们自己创建的Lambda过程，在后面我们会详细介绍如何分别实现这两种过程的应用。</p>
<p>Print部分，这部分就不细讲了，就是使用str打印获得值即可。</p>
<p>还有一个问题就是，我们需要让整个解释器循环起来，总不能每次输入一次表达式得出结果就终止了程序吧，所以我们需要一个逻辑循环函数。</p>
<p>OK，从Read开始讲起。</p>
<h4 id="Read部分"><a href="#Read部分" class="headerlink" title="Read部分"></a>Read部分</h4><h5 id="Pair类"><a href="#Pair类" class="headerlink" title="Pair类"></a>Pair类</h5><p>前面我们讲到，Read部分是将用户输入的字符串，通过词法分析和句法分析转换成某种抽象数据类型，以供后续的分析</p>
<p>首先我们来定义一种能够接收并存储用户输入字符串的数据类型Pair</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A pair has two instance attributes: first and second. Second must be a Pair or nil</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Pair(1, Pair(2, nil))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Pair(1, Pair(2, nil))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(s)</span></span><br><span class="line"><span class="string">    (1 2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(s.map(lambda x: x+4))</span></span><br><span class="line"><span class="string">    (5 6)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, second</span>):</span><br><span class="line">        <span class="keyword">from</span> scheme_builtins <span class="keyword">import</span> scheme_valid_cdrp, SchemeError</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (second <span class="keyword">is</span> nil <span class="keyword">or</span> <span class="built_in">isinstance</span>(second, Pair) <span class="keyword">or</span> <span class="built_in">type</span>(second).__name__ == <span class="string">&#x27;Promise&#x27;</span>):</span><br><span class="line">            <span class="keyword">raise</span> SchemeError(<span class="string">&quot;cdr can only be a pair, nil, or a promise but was &#123;&#125;&quot;</span>.<span class="built_in">format</span>(second))</span><br><span class="line">        self.first = first</span><br><span class="line">        self.second = second</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Pair(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.first), <span class="built_in">repr</span>(self.second))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        s = <span class="string">&#x27;(&#x27;</span> + repl_str(self.first)</span><br><span class="line">        second = self.second</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">isinstance</span>(second, Pair):</span><br><span class="line">            s += <span class="string">&#x27; &#x27;</span> + repl_str(second.first)</span><br><span class="line">            second = second.second</span><br><span class="line">        <span class="keyword">if</span> second <span class="keyword">is</span> <span class="keyword">not</span> nil:</span><br><span class="line">            s += <span class="string">&#x27; . &#x27;</span> + repl_str(second)</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        n, second = <span class="number">1</span>, self.second</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">isinstance</span>(second, Pair):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            second = second.second</span><br><span class="line">        <span class="keyword">if</span> second <span class="keyword">is</span> <span class="keyword">not</span> nil:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;length attempted on improper list&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(p, Pair):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.first == p.first <span class="keyword">and</span> self.second == p.second</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">map</span>(<span class="params">self, fn</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a Scheme list after mapping Python function FN to SELF.&quot;&quot;&quot;</span></span><br><span class="line">        mapped = fn(self.first)</span><br><span class="line">        <span class="keyword">if</span> self.second <span class="keyword">is</span> nil <span class="keyword">or</span> <span class="built_in">isinstance</span>(self.second, Pair):</span><br><span class="line">            <span class="keyword">return</span> Pair(mapped, self.second.<span class="built_in">map</span>(fn))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;ill-formed list (cdr is a promise)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以看出，Pair的结构非常像Link，其实本质也是一种迭代对象，只不过在link的基础上增加了一些内置方法，用于对Pair对象进行各种操作。</p>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><p>当用户输入一个字符串 </p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">scm&gt; (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>解释器首先要对其进行词法分析，在该项目中，我们使用tokenize_lines函数和Buffer类进行词法分析，最终返回一个Buffer对象src</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">next_line = buffer_input</span><br><span class="line"></span><br><span class="line">src = next_line()</span><br></pre></td></tr></table></figure>

<p>根据函数调用的顺序，涉及的函数调用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">获取字符串</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buffer_input</span>(<span class="params">prompt=<span class="string">&#x27;scm&gt; &#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a Buffer instance containing interactive input.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Buffer(tokenize_lines(InputReader(prompt)))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#获取输入字符串，逐个字符传入tokenize_line函数执行    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize_lines</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;An iterator over lists of tokens, one for each line of the iterable</span></span><br><span class="line"><span class="string">    input sequence.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (tokenize_line(line) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取tokenize_line函数执行返回结果构成的列表，并将其转为Buffer类的实例对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, source</span>):</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        self.lines = []</span><br><span class="line">        self.source = source</span><br><span class="line">        self.current_line = ()</span><br><span class="line">        self.current()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Remove the next item from self and return it. If self has</span></span><br><span class="line"><span class="string">        exhausted its source, returns None.&quot;&quot;&quot;</span></span><br><span class="line">        current = self.current()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">current</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the current element, or None if none exists.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.more_on_line:</span><br><span class="line">            self.index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.current_line = <span class="built_in">next</span>(self.source)</span><br><span class="line">                self.lines.append(self.current_line)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.current_line = ()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.current_line[self.index]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">more_on_line</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.index &lt; <span class="built_in">len</span>(self.current_line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return recently read contents; current element marked with &gt;&gt;.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Format string for right-justified line numbers</span></span><br><span class="line">        n = <span class="built_in">len</span>(self.lines)</span><br><span class="line">        msg = <span class="string">&#x27;&#123;0:&gt;&#x27;</span> + <span class="built_in">str</span>(math.floor(math.log10(n))+<span class="number">1</span>) + <span class="string">&quot;&#125;: &quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Up to three previous lines and current line are included in output</span></span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>, n-<span class="number">4</span>), n-<span class="number">1</span>):</span><br><span class="line">            s += msg.<span class="built_in">format</span>(i+<span class="number">1</span>) + <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, self.lines[i])) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        s += msg.<span class="built_in">format</span>(n)</span><br><span class="line">        s += <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, self.current_line[:self.index]))</span><br><span class="line">        s += <span class="string">&#x27; &gt;&gt; &#x27;</span></span><br><span class="line">        s += <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, self.current_line[self.index:]))</span><br><span class="line">        <span class="keyword">return</span> s.strip()</span><br></pre></td></tr></table></figure>

<p>Buffer实例有两个核心方法remove_front和current，这两个方法可以对Buffer对象里的值进行有序输出。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; buf = Buffer(<span class="name">iter</span>([[&#x27;(&#x27;, <span class="symbol">&#x27;+</span>&#x27;], [<span class="number">15</span>], [<span class="number">12</span>, &#x27;)&#x27;]]))</span><br><span class="line">&gt;&gt;&gt; buf.remove_front()</span><br><span class="line">&#x27;(&#x27;</span><br><span class="line">&gt;&gt;&gt; buf.remove_front()</span><br><span class="line"><span class="symbol">&#x27;+</span>&#x27;</span><br><span class="line">&gt;&gt;&gt; buf.current()</span><br><span class="line"><span class="number">15</span></span><br><span class="line">&gt;&gt;&gt; print(buf)</span><br><span class="line"><span class="number">1</span>: ( +</span><br><span class="line"><span class="number">2</span>:  &gt;&gt; <span class="number">15</span></span><br><span class="line">&gt;&gt;&gt; buf.remove_front()</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>经过词法分析，用户输入的字符串被转换成了可有序输出的Buffer实例对象，就好像排列在内存中的数据一样，但是有一个问题就在于，对于这些存在实例对象中的数据，数据之间的相互关联并没有建立，就好像在游乐园等待入场的队列，虽然有序，但是相互之间毫无关联。</p>
<p>因此我们要进行句法分析。</p>
<h5 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h5><p>在该项目中，我们使用scheme_read进行句法分析，最终返回一个Pair对象expression</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">expression = scheme_read(<span class="name">src</span>)</span><br></pre></td></tr></table></figure>

<p>我们来看一下scheme_read的逻辑流程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scheme_read</span>(<span class="params">src</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read the next expression from SRC, a Buffer of tokens.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;nil&#x27;])))</span></span><br><span class="line"><span class="string">    nil</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;1&#x27;])))</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;true&#x27;])))</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;(+ 1 2)&#x27;])))</span></span><br><span class="line"><span class="string">    Pair(&#x27;+&#x27;, Pair(1, Pair(2, nil)))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> src.current() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> EOFError</span><br><span class="line">    val = src.remove_front() <span class="comment"># Get the first token</span></span><br><span class="line">    <span class="keyword">if</span> val == <span class="string">&#x27;nil&#x27;</span>:</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 2</span></span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">        <span class="comment"># END PROBLEM 2</span></span><br><span class="line">    <span class="keyword">elif</span> val == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 2</span></span><br><span class="line">        <span class="keyword">return</span> read_tail(src)</span><br><span class="line">        <span class="comment"># END PROBLEM 2</span></span><br><span class="line">    <span class="keyword">elif</span> val <span class="keyword">in</span> quotes:</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 7</span></span><br><span class="line">        <span class="keyword">return</span> Pair(quotes[val],Pair(scheme_read(src),nil))</span><br><span class="line">        <span class="comment"># END PROBLEM 7</span></span><br><span class="line">    <span class="keyword">elif</span> val <span class="keyword">not</span> <span class="keyword">in</span> DELIMITERS:</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">&#x27;unexpected token: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(val))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_tail</span>(<span class="params">src</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the remainder of a list in SRC, starting before an element or ).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;)&#x27;])))</span></span><br><span class="line"><span class="string">    nil</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;2 3)&#x27;])))</span></span><br><span class="line"><span class="string">    Pair(2, Pair(3, nil))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> src.current() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> SyntaxError(<span class="string">&#x27;unexpected end of file&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> src.current() == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="comment"># BEGIN PROBLEM 2</span></span><br><span class="line">            src.remove_front()</span><br><span class="line">            <span class="keyword">return</span> nil</span><br><span class="line">            <span class="comment"># END PROBLEM 2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># BEGIN PROBLEM 2</span></span><br><span class="line">            <span class="keyword">return</span> Pair(scheme_read(src),read_tail(src))</span><br><span class="line">            <span class="comment"># END PROBLEM 2</span></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">&#x27;unexpected end of file&#x27;</span>)</span><br><span class="line"></span><br><span class="line">quotes = &#123;<span class="string">&quot;&#x27;&quot;</span>:  <span class="string">&#x27;quote&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;`&#x27;</span>:  <span class="string">&#x27;quasiquote&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;,&#x27;</span>:  <span class="string">&#x27;unquote&#x27;</span>&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>我们可以看出，对于不同的结构，scheme_read有不同的方案去构造，主要可以分为三种，一种是普通的基础表达式，比如123，nil和布尔值，一种是调用表达式，scheme_read函数规定当遇到‘（’时会自动进入read_tail函数，最终返回一个完整的Pair结构，第三种就是符号，函数会判断这个符号是Quote，Quasiquote还是unquote，并将这三个模式传入以供后期评估使用。</p>
<p>最终输入如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scheme_read(Buffer(tokenize_lines([<span class="string">&#x27;(+ 1 2)&#x27;</span>])))</span><br><span class="line">Pair(<span class="string">&#x27;+&#x27;</span>, Pair(<span class="number">1</span>, Pair(<span class="number">2</span>, nil)))</span><br></pre></td></tr></table></figure>

<p>可以看出，经过句法分析，我们建立了字符之间的关联性，同属于一个调用表达式的字符被整合进 了独立的一个Pair实例，就好比，让在排队的人，夫妻合并成一组，家庭或朋友合并成一组，再进行排队。</p>
<p>经过第一部分Read，我们拥有了具有关联性的Pair对象，在接下来的Eval部分中，我们将要对这个对象进行评估。</p>
<h4 id="Eval-部分"><a href="#Eval-部分" class="headerlink" title="Eval 部分"></a>Eval 部分</h4><p>在整个评估过程中，有两个类发挥着重要作用，一个类是Frame，Frame类是一个环境框架，我们学习Python作用域的时候学习过，程序开始时候是在Global Frame下，当调用函数时候，会创建一个Frame，并且在该Frame下创建的变量和传入的参数是不能在Global Frame下被使用的，Scheme同样如此，所以我们创建了一个Frame类用于分离不同作用域。一个类是Procedure，Procedure类是过程类，他有两个子类，一个是BuiltinProcedure，即内置过程，比如我们使用的if，cons，cond都是内置过程，另一个是LambdaProcedure，即匿名过程，这是用来创建并绑定用户定义过程的。</p>
<h5 id="Frame类"><a href="#Frame类" class="headerlink" title="Frame类"></a>Frame类</h5><p>EFrame类实现了环境框架，在对解释器进行初始化的时候，会调用create_global_frame创建一个Frame环境框架。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Frame</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;An environment frame binds Scheme symbols to Scheme values.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;An empty frame with parent frame PARENT (which may be None).&quot;&quot;&quot;</span></span><br><span class="line">        self.bindings = &#123;&#125;</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;Global Frame&gt;&#x27;</span></span><br><span class="line">        s = <span class="built_in">sorted</span>([<span class="string">&#x27;&#123;0&#125;: &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.bindings.items()])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&#123;&#123;&#123;0&#125;&#125;&#125; -&gt; &#123;1&#125;&gt;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;, &#x27;</span>.join(s), <span class="built_in">repr</span>(self.parent))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">define</span>(<span class="params">self, symbol, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Define Scheme SYMBOL to have VALUE.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 3</span></span><br><span class="line">        self.bindings[symbol]=value</span><br><span class="line">        <span class="comment"># END PROBLEM 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lookup</span>(<span class="params">self, symbol</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the value bound to SYMBOL. Errors if SYMBOL is not found.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 3</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.bindings[symbol]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">if</span> self.parent <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> self.parent.lookup(symbol)</span><br><span class="line">        <span class="comment"># END PROBLEM 3</span></span><br><span class="line">        <span class="keyword">raise</span> SchemeError(<span class="string">&#x27;unknown identifier: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(symbol))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_child_frame</span>(<span class="params">self, formals, vals</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a new local frame whose parent is SELF, in which the symbols</span></span><br><span class="line"><span class="string">        in a Scheme list of formal parameters FORMALS are bound to the Scheme</span></span><br><span class="line"><span class="string">        values in the Scheme list VALS. Raise an error if too many or too few</span></span><br><span class="line"><span class="string">        vals are given.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; env = create_global_frame()</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; formals, expressions = read_line(&#x27;(a b c)&#x27;), read_line(&#x27;(1 2 3)&#x27;)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; env.make_child_frame(formals, expressions)</span></span><br><span class="line"><span class="string">        &lt;&#123;a: 1, b: 2, c: 3&#125; -&gt; &lt;Global Frame&gt;&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 11</span></span><br><span class="line">        match_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(formals)!=<span class="built_in">len</span>(vals):</span><br><span class="line">            <span class="keyword">raise</span> SchemeError(<span class="string">&#x27;The number of argument values does not match&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(formals)):</span><br><span class="line">                match_dict[formals.first] = vals.first</span><br><span class="line">                formals = formals.second</span><br><span class="line">                vals = vals.second</span><br><span class="line">        new_frame = Frame(self)</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> match_dict.items():</span><br><span class="line">            new_frame.define(key,value)</span><br><span class="line">        <span class="keyword">return</span> new_frame</span><br><span class="line">        <span class="comment"># END PROBLEM 11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Frame框架类从外界引入一个父环境Frame实例，并维护一个binding列表，在初始化时候，会在初始Frame环境中调用define方法引入内置过程，在后面的过程中，如果需要引入用户过程，可以通过define引入，查找内置过程，可以通过lookup方法实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_global_frame</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Initialize and return a single-frame environment with built-in names.&quot;&quot;&quot;</span></span><br><span class="line">    env = Frame(<span class="literal">None</span>)</span><br><span class="line">    env.define(<span class="string">&#x27;eval&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(scheme_eval, <span class="literal">True</span>, <span class="string">&#x27;eval&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;apply&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(complete_apply, <span class="literal">True</span>, <span class="string">&#x27;apply&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;load&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(scheme_load, <span class="literal">True</span>, <span class="string">&#x27;load&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;procedure?&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(scheme_procedurep, <span class="literal">False</span>, <span class="string">&#x27;procedure?&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;map&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(scheme_map, <span class="literal">True</span>, <span class="string">&#x27;map&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;filter&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(scheme_filter, <span class="literal">True</span>, <span class="string">&#x27;filter&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;reduce&#x27;</span>,</span><br><span class="line">               BuiltinProcedure(scheme_reduce, <span class="literal">True</span>, <span class="string">&#x27;reduce&#x27;</span>))</span><br><span class="line">    env.define(<span class="string">&#x27;undefined&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    add_builtins(env, BUILTINS)</span><br><span class="line">    <span class="keyword">return</span> env</span><br></pre></td></tr></table></figure>

<p>当子环境创建需要引入一个Frame实例时，Frame可以调用make_child_frame创建一个子Frame并返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_call_frame</span>(<span class="params">self,args,env</span>):</span><br><span class="line">        <span class="keyword">return</span> env.make_child_frame(self.formals, args)</span><br></pre></td></tr></table></figure>

<h5 id="Procedure类"><a href="#Procedure类" class="headerlink" title="Procedure类"></a>Procedure类</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BuiltinProcedure</span>(<span class="title class_ inherited__">Procedure</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A Scheme procedure defined as a Python function.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fn, use_env=<span class="literal">False</span>, name=<span class="string">&#x27;builtin&#x27;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.fn = fn</span><br><span class="line">        self.use_env = use_env</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#[&#123;0&#125;]&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply</span>(<span class="params">self, args, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Apply SELF to ARGS in ENV, where ARGS is a Scheme list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; env = create_global_frame()</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; plus = env.bindings[&#x27;+&#x27;]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; twos = Pair(2, Pair(2, nil))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; plus.apply(twos, env)</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scheme_listp(args):</span><br><span class="line">            <span class="keyword">raise</span> SchemeError(<span class="string">&#x27;arguments are not in a list: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(args))</span><br><span class="line">        <span class="comment"># Convert a Scheme list to a Python list</span></span><br><span class="line">        python_args = []</span><br><span class="line">        <span class="keyword">while</span> args <span class="keyword">is</span> <span class="keyword">not</span> nil:</span><br><span class="line">            python_args.append(args.first)</span><br><span class="line">            args = args.second</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 4</span></span><br><span class="line">        <span class="keyword">if</span> self.use_env:</span><br><span class="line">            python_args.append(env)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fn(*python_args)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">raise</span> SchemeError(<span class="string">&quot;Invalid number of arguments to &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">        <span class="comment"># END PROBLEM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaProcedure</span>(<span class="title class_ inherited__">Procedure</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A procedure defined by a lambda expression or a define form.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, formals, body, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A procedure with formal parameter list FORMALS (a Scheme list),</span></span><br><span class="line"><span class="string">        whose body is the Scheme list BODY, and whose parent environment</span></span><br><span class="line"><span class="string">        starts with Frame ENV.&quot;&quot;&quot;</span></span><br><span class="line">        self.formals = formals</span><br><span class="line">        self.body = body</span><br><span class="line">        self.env = env</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_call_frame</span>(<span class="params">self, args, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Make a frame that binds my formal parameters to ARGS, a Scheme list</span></span><br><span class="line"><span class="string">        of values, for a lexically-scoped call evaluated in environment ENV.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 12</span></span><br><span class="line">        new_frame = self.env.make_child_frame(self.formals,args)</span><br><span class="line">        <span class="keyword">return</span> new_frame</span><br><span class="line">        <span class="comment"># END PROBLEM 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(Pair(<span class="string">&#x27;lambda&#x27;</span>, Pair(self.formals, self.body)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;LambdaProcedure(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            <span class="built_in">repr</span>(self.formals), <span class="built_in">repr</span>(self.body), <span class="built_in">repr</span>(self.env))</span><br></pre></td></tr></table></figure>

<p>内置过程表示为BuiltinProcedure实例，BuiltinProcedure具有两个实例属性，fn是实施内置方案程序的Python功能，use_env是一个布尔标志，指示这个内置程序是否会期望当前环境作为最后一个参数传递。例如，需要环境来实施内置eval程序。</p>
<p>用户定义的程序表示为LambdaProcedure实例。LambdaProcedure具有三个实例属性，formals是命名程序参数的正式参数（符号）的方案列表。body是一个方案列表的表达式，程序的主体。<br>env是定义程序的Frame环境。</p>
<h5 id="评估仅内置过程的表达式"><a href="#评估仅内置过程的表达式" class="headerlink" title="评估仅内置过程的表达式"></a>评估仅内置过程的表达式</h5><p>当我们评估只有内置过程的表达式的时候，我们会进行这个过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> scheme_symbolp(first) <span class="keyword">and</span> first <span class="keyword">in</span> SPECIAL_FORMS:</span><br><span class="line">        <span class="keyword">return</span> SPECIAL_FORMS[first](rest, env)</span><br></pre></td></tr></table></figure>

<p>这里的SPECIAL_FORMS就是内置过程的列表，我们通过first变量传入操作符名称，当我们发现评估的操作符是个内置过程的时候，我们就会调用这段代码找到对应调用内置过程的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SPECIAL_FORMS = &#123;</span><br><span class="line">    <span class="string">&#x27;and&#x27;</span>: do_and_form,</span><br><span class="line">    <span class="string">&#x27;begin&#x27;</span>: do_begin_form,</span><br><span class="line">    <span class="string">&#x27;cond&#x27;</span>: do_cond_form,</span><br><span class="line">    <span class="string">&#x27;define&#x27;</span>: do_define_form,</span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: do_if_form,</span><br><span class="line">    <span class="string">&#x27;lambda&#x27;</span>: do_lambda_form,</span><br><span class="line">    <span class="string">&#x27;let&#x27;</span>: do_let_form,</span><br><span class="line">    <span class="string">&#x27;or&#x27;</span>: do_or_form,</span><br><span class="line">    <span class="string">&#x27;quote&#x27;</span>: do_quote_form,</span><br><span class="line">    <span class="string">&#x27;define-macro&#x27;</span>: do_define_macro,</span><br><span class="line">    <span class="string">&#x27;quasiquote&#x27;</span>: do_quasiquote_form,</span><br><span class="line">    <span class="string">&#x27;unquote&#x27;</span>: do_unquote,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以评估define内置过程为例来讲解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_define_form</span>(<span class="params">expressions, env</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Evaluate a define form.&quot;&quot;&quot;</span></span><br><span class="line">    check_form(expressions, <span class="number">2</span>)</span><br><span class="line">    target = expressions.first</span><br><span class="line">    <span class="keyword">if</span> scheme_symbolp(target):</span><br><span class="line">        check_form(expressions, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 6</span></span><br><span class="line">        value = scheme_eval(expressions.second.first,env)</span><br><span class="line">        env.define(target,value)</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">        <span class="comment"># END PROBLEM 6</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bad_target = target.first <span class="keyword">if</span> <span class="built_in">isinstance</span>(target, Pair) <span class="keyword">else</span> target</span><br><span class="line">        <span class="keyword">raise</span> SchemeError(<span class="string">&#x27;non-symbol: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(bad_target))</span><br></pre></td></tr></table></figure>

<p>do_define_form函数引入了两个参数，根据调用函数可知，传入的expression参数是调用表达式的操作数部分，因此就把操作数评估后的结果在全局环境下与设定的变量绑定了，其关键代码为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">env.define(target,value)</span><br></pre></td></tr></table></figure>

<p>这就是实现一个内置过程的办法，接下来我们来看看该如何实现用户定义函数。</p>
<h5 id="评估带有用户定义的表达式"><a href="#评估带有用户定义的表达式" class="headerlink" title="评估带有用户定义的表达式"></a>评估带有用户定义的表达式</h5><p>我们先来看看如何使用内置过程<code>define</code>定义一个用户过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_define_form</span>(<span class="params">expressions, env</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Evaluate a define form.&quot;&quot;&quot;</span></span><br><span class="line">    check_form(expressions, <span class="number">2</span>)</span><br><span class="line">    target = expressions.first</span><br><span class="line">    <span class="keyword">if</span> scheme_symbolp(target):</span><br><span class="line">        check_form(expressions, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 6</span></span><br><span class="line">        value = scheme_eval(expressions.second.first,env)</span><br><span class="line">        env.define(target,value)</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">        <span class="comment"># END PROBLEM 6</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(target, Pair) <span class="keyword">and</span> scheme_symbolp(target.first):</span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 10</span></span><br><span class="line">        name = target.first</span><br><span class="line">        formal = target.second</span><br><span class="line">        body = expressions.second</span><br><span class="line">        process = LambdaProcedure(formal,body,env)</span><br><span class="line">        env.define(name,process)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">        <span class="comment"># END PROBLEM 10</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bad_target = target.first <span class="keyword">if</span> <span class="built_in">isinstance</span>(target, Pair) <span class="keyword">else</span> target</span><br><span class="line">        <span class="keyword">raise</span> SchemeError(<span class="string">&#x27;non-symbol: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(bad_target))</span><br></pre></td></tr></table></figure>

<p>我们看到，这个define函数比之前仅能定义变量的函数多了elif的部分，在这个过程中，函数首先将整个定义代码段分成name函数名称，formal函数参数，和body函数主体三个部分，而后将这三个部分放入LambdaProcedure类创建一个实例，最后调用Frame的define过程将新定义的过程实例与过程名绑定，以便后期lookup函数的查找。</p>
<p>我们来看看创建新过程的实例时候，发生了什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaProcedure</span>(<span class="title class_ inherited__">Procedure</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A procedure defined by a lambda expression or a define form.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, formals, body, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A procedure with formal parameter list FORMALS (a Scheme list),</span></span><br><span class="line"><span class="string">        whose body is the Scheme list BODY, and whose parent environment</span></span><br><span class="line"><span class="string">        starts with Frame ENV.&quot;&quot;&quot;</span></span><br><span class="line">        self.formals = formals</span><br><span class="line">        self.body = body</span><br><span class="line">        self.env = env</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_call_frame</span>(<span class="params">self, args, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Make a frame that binds my formal parameters to ARGS, a Scheme list</span></span><br><span class="line"><span class="string">        of values, for a lexically-scoped call evaluated in environment ENV.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># BEGIN PROBLEM 12</span></span><br><span class="line">        new_frame = self.env.make_child_frame(self.formals,args)</span><br><span class="line">        <span class="keyword">return</span> new_frame</span><br><span class="line">        <span class="comment"># END PROBLEM 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(Pair(<span class="string">&#x27;lambda&#x27;</span>, Pair(self.formals, self.body)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;LambdaProcedure(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            <span class="built_in">repr</span>(self.formals), <span class="built_in">repr</span>(self.body), <span class="built_in">repr</span>(self.env))</span><br></pre></td></tr></table></figure>

<p>可以看到，lambda维护着一个方法，当调用到用户实例的时候，就会调用这个方法，打开一个新Frame进行运算。</p>
<p>最后对调用表达式执行apply操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scheme_apply</span>(<span class="params">procedure, args, env</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in</span></span><br><span class="line"><span class="string">    environment ENV.&quot;&quot;&quot;</span></span><br><span class="line">    check_procedure(procedure)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(procedure, BuiltinProcedure):</span><br><span class="line">        <span class="keyword">return</span> procedure.apply(args, env)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_env = procedure.make_call_frame(args, env)</span><br><span class="line">        <span class="keyword">return</span> eval_all(procedure.body, new_env)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval_all</span>(<span class="params">expressions, env</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Evaluate each expression in the Scheme list EXPRESSIONS in</span></span><br><span class="line"><span class="string">    environment ENV and return the value of the last.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># BEGIN PROBLEM 8</span></span><br><span class="line">    <span class="keyword">if</span> expressions == nil:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = expressions.<span class="built_in">map</span>((<span class="keyword">lambda</span> x:scheme_eval(x,env)))</span><br><span class="line">        <span class="keyword">while</span> value <span class="keyword">is</span> <span class="keyword">not</span> nil:</span><br><span class="line">            now = value.first</span><br><span class="line">            value = value.second</span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>

<p>至此，整个解释器就写完了，再加上内置的自循环函数，一个可以运行Scheme程序的python解释器就大功告成了。在61A 的Scheme项目中，还有如宏和流这种复杂的过程，大家可以自行学习，不过本质还是和内置过程的评估相差不大。学习这个项目的目的不是真的要完成一个解释器，而是要让你学会和理解解释器是如何”翻译“一种语言的，这样你才能更好的去理解各种编程范式，例如函数式编程，面向对象编程.</p>
]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>程序结构</tag>
        <tag>CS61</tag>
        <tag>CS61A</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61A-对象抽象</title>
    <url>/posts/443f5291/</url>
    <content><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>面向对象编程（OOP）</p>
<ul>
<li>对象和类</li>
<li>类属性与实例属性</li>
<li>消息传递与点表达式</li>
<li>类方法</li>
</ul>
<p>继承与方法</p>
<ul>
<li>继承与方法重写</li>
<li>多重继承</li>
<li>特殊方法</li>
</ul>
<p>递归对象的实现</p>
<ul>
<li>链表类</li>
<li>树类</li>
</ul>
</blockquote>
<p>在课程的第一章当中我们提到了使用函数进行抽象，这种方式可以很好的对数据进行处理，然而仅仅只考虑函数式编程往往会产生很多问题，举个例子，假设一家银行仅仅使用变量和函数来对人员的账户进行管理，他们使用xx_money ,xx_name来进行人员账户的登记，利用<code>transfrom()</code>函数进行转账操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Tom_money = <span class="number">100</span></span><br><span class="line">Bob_money = <span class="number">200</span></span><br><span class="line">Jef_money = <span class="number">400</span></span><br><span class="line">David_money = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">from_account,to_account,number</span>):</span><br><span class="line">    from_account -= number</span><br><span class="line">    to_account +- number</span><br></pre></td></tr></table></figure>

<p>突然有一天，银行的i系统在调试过程中被某个程序员整崩溃了，重新找回数据的时候变成了这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">￥&amp;×.money = <span class="number">100</span></span><br><span class="line">%^&amp;.money = <span class="number">200</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>银行傻眼了，这下怎么区分金额属于谁啊，他们只能重新寻找曾经顾客注册登记用的纸质材料，费了好大的功夫才好不容易将数据恢复了回去，经过这次事件，银行的工作人员开始思考，是不是应该换一种方式对数据进行记录，经过长时间的研究讨论，他们决定使用面向对象的编程方式重新组织和记录数据，从此以后，再也没有出现过类似的事情。</p>
<p>面向对象OOP，究竟强大在何处？</p>
<p>接下来我们将对OOP进行深入分析，为大家揭开这个谜底。</p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h4><p>上面我们讲到，利用面向对象的思考方式，我们可以解决银行账户的问题，那么为什么呢？原因就在于，之前银行储存数据时，没有考虑到数据与数据之间的关联性，仅仅只采用了很弱的关系，统一变量名来进行关联，而利用面向对象的思考方式，是将一个账户看做一个对象，每一个变量都是其对象的对象属性。</p>
<p>什么是对象？对象就是具有同一特征的一类元素，比如，一个人就是一个对象，每个人都有鼻子眼睛嘴巴，而且都能行走和思考，这些具有的同一特征就被称作一个类，类就好像上帝在造人的时候使用的模板。再比如一支笔，无论他是钢笔还是水笔，毛笔，都具有写字这个功能，因此同属于笔这个类，而每一支笔都是一个独立的对象。</p>
<p>下面我们通过一个例子来具体讲解类和对象，Lab8的这个例子很好，我就直接借用了。</p>
<p>Tiffany 迟到了，需要在讲座开始前从旧金山赶到伯克利。她会乘坐 BART，但这会花费太长时间。要是有车就好了 一辆巨型卡车会是最好的。</p>
<p>我们要为Tiffany造一辆汽车，我们首先要创建一个汽车类，用户定义的类是由class语句创建的，它由单个子句组成。class 语句定义类名称，然后包含一组语句来定义类的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>：</span><br></pre></td></tr></table></figure>

<p>接下来我们要对这个类增加一些属性，一辆车有哪些属性呢？品牌，型号，颜色，轮子数，汽油量，那么我们要对这个类附加属性，类的构造函数是一个函数，它创建类所概述的对象的实例或单个实例。在 Python 中，构造函数方法名为init，在Car类的构造函数如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model</span>):</span><br><span class="line">    self.make = make</span><br><span class="line">    self.model = model</span><br><span class="line">    self.color = <span class="string">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class="line">    self.wheels = Car.num_wheels</span><br><span class="line">    self.gas = Car.gas</span><br></pre></td></tr></table></figure>

<p>该__init__有三个参数。第一个参数self，自动绑定到新创建的Car对象。第二个和第三个参数make和model绑定到传递给构造函数的参数，这意味着当我们创建一个Car对象时，我们必须提供两个参数。</p>
<p>于是，汽车这个类我们就构造完毕了，让我们开始造我们的车。蒂芙尼想开一辆特斯拉 Model S 去上课。所以我们可以构造一个厂家为“Tesla”，型号为“Model S”的汽车实例，Python 允许我们通过类的名称来创建类的实例，而不是显式调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car = Car(<span class="string">&#x27;Tesla&#x27;</span>, <span class="string">&#x27;Model S&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，’Tesla’作为 make传入，“Model S”作为model传入， 请注意，我们没有传递参数self，因为它的值始终是正在创建的对象，一个对象是类的一个实例。在这种情况下， tiffanys_car现在绑定到一个Car对象，或者换句话说，绑定到Car类的一个实例。</p>
<p>这样，我们就创建了一个Car类，并且通过Car类创建了一个tiffanys_car的实例对象。</p>
<h4 id="实例属性与类属性"><a href="#实例属性与类属性" class="headerlink" title="实例属性与类属性"></a>实例属性与类属性</h4><p>我们继续来看我们上面创建的Car类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    num_wheels = <span class="number">4</span></span><br><span class="line">    gas = <span class="number">30</span></span><br><span class="line">    headlights = <span class="number">2</span></span><br><span class="line">    size = <span class="string">&#x27;Tiny&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model</span>):</span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = <span class="string">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class="line">        self.wheels = Car.num_wheels</span><br><span class="line">        self.gas = Car.gas</span><br></pre></td></tr></table></figure>

<p>我们会发现，诶，除了我们刚刚利用构造函数所创建的属性，上面怎么还多了几行？</p>
<p>这里就涉及到实例属性和类属性两个概念了，什么是类属性？类属性就是同属于一个类的对象所共有的属性 ，比如，只要是汽车，肯定都是四个轮子，两个头灯，一个后备箱，这些是所有汽车共有的属性，所以被称作类属性。而不同的汽车有不同的型号，品牌，颜色和汽油量，因此这些属性就被称作实例属性。每创建一个实例对象，都会自动将类属性附加给该实例。</p>
<h4 id="消息传递与点表达式"><a href="#消息传递与点表达式" class="headerlink" title="消息传递与点表达式"></a>消息传递与点表达式</h4><p>上面，我们为tiffany造了一辆车，但如果有一天，tiffany说，我不想开Tesla了，我想换辆Benz开开，那该怎么办呢？我们当然可以重新利用Car类创造一个新的实例对象，但这太麻烦了，有没有什么办法可以对已有的车辆属性进行改变呢？</p>
<p>有的，利用点符号就可以。</p>
<p>例如，我们可以访问Car类的类属性size</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Car.size</span><br><span class="line"><span class="string">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同样也可以对Car类的属性进行改变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Car.size = <span class="string">&#x27;Big&#x27;</span></span><br><span class="line"><span class="string">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对实例属性的改变也是同样如此，在以下行中，我们访问tiffanys_car的make属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; tiffanys_car.make </span><br><span class="line"><span class="string">&#x27;Tesla&#x27;</span></span><br></pre></td></tr></table></figure>

<p>而后我们将make属性修改为‘Benz’:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car.make = <span class="string">&#x27;Benz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就成功改造了tiffany的车子，是不是很简单呢？</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>让我们再为Car类增加一些东西</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    num_wheels = <span class="number">4</span></span><br><span class="line">    gas = <span class="number">30</span></span><br><span class="line">    headlights = <span class="number">2</span></span><br><span class="line">    size = <span class="string">&#x27;Tiny&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model</span>):</span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = <span class="string">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class="line">        self.wheels = Car.num_wheels</span><br><span class="line">        self.gas = Car.gas</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paint</span>(<span class="params">self, color</span>):</span><br><span class="line">        self.color = color</span><br><span class="line">        <span class="keyword">return</span> self.make + <span class="string">&#x27; &#x27;</span> + self.model + <span class="string">&#x27; is now &#x27;</span> + color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.wheels &lt; Car.num_wheels <span class="keyword">or</span> self.gas &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Cannot drive!&#x27;</span></span><br><span class="line">        self.gas -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> self.make + <span class="string">&#x27; &#x27;</span> + self.model + <span class="string">&#x27; goes vroom!&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_tire</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.wheels &gt; <span class="number">0</span>:</span><br><span class="line">            self.wheels -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fill_gas</span>(<span class="params">self</span>):</span><br><span class="line">        self.gas += <span class="number">20</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Gas level: &#x27;</span> + <span class="built_in">str</span>(self.gas)</span><br></pre></td></tr></table></figure>

<p>这些def叫做类的方法，他们可以调用类的属性，并且输出给外界。方法是特定于类的函数，只有类的一个实例可以使用它们，那么，我们如何在实例上调用方法？你猜对了，点符号！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car.paint(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Tesla Model S is now black&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car.color</span><br><span class="line"><span class="string">&#x27;black&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面是一个调用paint方法的过程，我们仔细看一下这个方法，它需要两个参数，那么为什么我们不需要传递两个参数呢？就好像我们在init构造函数中看到的那样，一个类的所有方法都有一个self参数，python会自动将调用该方法的实例绑定到该参数，在这里，self绑定到tiffanys_car这个实例，并调用paint函数改变实例属性</p>
<p>您还可以使用类名和点符号来调用方法；例如，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Car.paint(tiffanys_car, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Tesla Model S is now red&#x27;</span></span><br></pre></td></tr></table></figure>

<p>请注意，与我们将 Tiffany 的汽车漆成黑色不同，这次我们必须传入两个参数：一个 self和一个 color。这是因为当您使用点表示法从实例调用方法时，Python 知道要自动绑定到哪个实例self。但是，当您使用类中的点表示法调用方法时，Python 不知道Car我们要绘制哪个实例 ，因此我们也要将实例作为参数传入。</p>
<h3 id="继承与方法重写"><a href="#继承与方法重写" class="headerlink" title="继承与方法重写"></a>继承与方法重写</h3><p>61A讲继承的时候举了一个很有意思的例子，大家小时候都玩过宝可梦吧，让我们来创建一个宝可梦的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pokemon</span>:</span><br><span class="line">    basic_attack = <span class="string">&#x27;tackle&#x27;</span></span><br><span class="line">    damage = <span class="number">40</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, trainer</span>):</span><br><span class="line">        self.name, self.trainer = name, trainer</span><br><span class="line">        self.level, self.hp = <span class="number">1</span>, <span class="number">50</span></span><br><span class="line">        self.paralyzed = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.paralyzed:</span><br><span class="line">            self.speak()</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&#x27;used&#x27;</span>, self.basic_attack, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">            other.receive_damage(self.damage)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">receive_damage</span>(<span class="params">self, damage</span>):</span><br><span class="line">        self.hp = <span class="built_in">max</span>(<span class="number">0</span>, self.hp - damage)</span><br><span class="line">        <span class="keyword">if</span> self.hp == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure>

<p>噢我们可以看见，一个宝可梦类有类属性damage，basic_attack，有实例属性name，level，paralyzed，还有一些类方法。</p>
<p>现在我们再来创建一个电属性的宝可梦类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricType</span>:</span><br><span class="line">    basic_attack = <span class="string">&#x27;thunder shock&#x27;</span></span><br><span class="line">    damage = <span class="number">40</span></span><br><span class="line">    prob = <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, trainer</span>):</span><br><span class="line">          self.name, self.trainer = name, trainer</span><br><span class="line">          self.level, self.hp = <span class="number">1</span>, <span class="number">50</span></span><br><span class="line">          self.paralyzed = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.speak()</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;used&#x27;</span>, self.basic_attack, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        other.receive_damage(self.damage)</span><br><span class="line">        <span class="keyword">if</span> random() &lt; self.prob <span class="keyword">and</span> <span class="built_in">type</span>(other) != ElectricType:</span><br><span class="line">            other.paralyzed = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(other.name, <span class="string">&#x27;is paralyzed!&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">receive_damage</span>(<span class="params">self, damage</span>):</span><br><span class="line">        self.hp = <span class="built_in">max</span>(<span class="number">0</span>, self.hp - damage)</span><br><span class="line">        <span class="keyword">if</span> self.hp == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure>

<p>有些人会说好麻烦，为什么不直接在原来的基础上修改，说的好，这就是继承的概念，我们会发现电属性宝可梦类和宝可梦类只有</p>
<p>类属性部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prob = 0.1</span><br></pre></td></tr></table></figure>

<p>attack方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.speak()</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;used&#x27;</span>, self.basic_attack, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        other.receive_damage(self.damage)</span><br><span class="line">        <span class="keyword">if</span> random() &lt; self.prob <span class="keyword">and</span> <span class="built_in">type</span>(other) != ElectricType:</span><br><span class="line">            other.paralyzed = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(other.name, <span class="string">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这两个模块是不同的，其他都是相同的，所以我们可以这样来写电属性宝可梦类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricType</span>(<span class="title class_ inherited__">Pokemon</span>):</span><br><span class="line">    basic_attack = <span class="string">&#x27;thunder shock&#x27;</span></span><br><span class="line">    prob = <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self, other</span>):</span><br><span class="line">        Pokemon.attack(self, other)</span><br><span class="line">        <span class="keyword">if</span> random() &lt; self.prob <span class="keyword">and</span> <span class="built_in">type</span>(other) != ElectricType:</span><br><span class="line">            other.paralyzed = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(other.name, <span class="string">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的<code>class &lt;Class Name&gt;(&lt;Superclass Name&gt;):</code>结构就是继承，通过继承，我们可以在新创建的类中保留下原有的类属性和实例属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pica = ElectricType(<span class="string">&#x27;pica&#x27;</span>,<span class="string">&#x27;me&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pica.hp</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>可以看得出，新类所创建的实例拥有和被继承类相同的实例属性。</p>
<p>我们还可以看到，attack方法被重写了，原来attack的方法被覆盖了，这种情况叫做方法重写，新类可以创建与被继承类相同名称的方法，将会覆盖原有方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;Pica.attack(Yib)</span><br><span class="line"><span class="string">&#x27;Yib is paralyzed!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这时候有人会问，那如果需要增加或删除实例属性项，是不是要重写一遍构造函数？</p>
<p>当然，重写固然没有问题，但是还有更简便的方法。</p>
<p>我们举一个61A Project ant的例子</p>
<p>假设我们有一个昆虫类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Insect</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;An Insect, the base class of Ant and Bee, has armor and a Place.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    is_ant = <span class="literal">False</span></span><br><span class="line">    damage = <span class="number">0</span></span><br><span class="line">    is_watersafe = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, armor, place=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create an Insect with an ARMOR amount and a starting PLACE.&quot;&quot;&quot;</span></span><br><span class="line">        self.armor = armor</span><br><span class="line">        self.armor = armor</span><br><span class="line">        self.place = place  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reduce_armor</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Reduce armor by AMOUNT, and remove the insect from its place if it</span></span><br><span class="line"><span class="string">        has no armor remaining.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; test_insect = Insect(5)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; test_insect.reduce_armor(2)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; test_insect.armor</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.armor -= amount</span><br><span class="line">        <span class="keyword">if</span> self.armor &lt;= <span class="number">0</span>:</span><br><span class="line">            self.place.remove_insect(self)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们要创建一个新的Ant类，这个Ant类是Insert类的一个子类，它继承了Insert类的一些方法和属性，不同的是，我们要修改一下Ant类当中amor属性的默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ant</span>(<span class="title class_ inherited__">Insect</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;An Ant occupies a place and does work for the colony.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    is_ant = <span class="literal">True</span></span><br><span class="line">    implemented = <span class="literal">False</span>  <span class="comment"># Only implemented Ant classes should be instantiated</span></span><br><span class="line">    food_cost = <span class="number">0</span></span><br><span class="line">    blocks_path = <span class="literal">True</span></span><br><span class="line">    is_container = <span class="literal">False</span></span><br><span class="line">    is_double = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, armor=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create an Ant with an ARMOR quantity.&quot;&quot;&quot;</span></span><br><span class="line">        Insect.__init__(self, armor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">can_contain</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用了<code>Insert.__init__(self,armor=1)</code>来修改父类的构造函数</p>
<p>我们再以Ant为父类，创建一个名为HungryAnt的子类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HungryAnt</span>(<span class="title class_ inherited__">Ant</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;HungryAnt will take three turns to digest a Bee in its place.</span></span><br><span class="line"><span class="string">    While digesting, the HungryAnt can&#x27;t eat another Bee.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = <span class="string">&#x27;Hungry&#x27;</span></span><br><span class="line">    food_cost = <span class="number">4</span></span><br><span class="line">    time_to_digest = <span class="number">3</span></span><br><span class="line">    <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">    implemented = <span class="literal">True</span>  <span class="comment"># Change to True to view in the GUI</span></span><br><span class="line">    <span class="comment"># END Problem 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, armor=<span class="number">1</span></span>):</span><br><span class="line">        <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">        Ant.__init__(self, armor)</span><br><span class="line">        self.digesting = <span class="number">0</span></span><br><span class="line">        <span class="comment"># END Problem 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat_bee</span>(<span class="params">self, bee</span>):</span><br><span class="line">        <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">        bee.armor = <span class="number">0</span></span><br><span class="line">        self.place.remove_insect(bee)</span><br><span class="line">        self.digesting = self.time_to_digest</span><br><span class="line">        <span class="comment"># END Problem 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">self, colony</span>):</span><br><span class="line">        <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">        <span class="keyword">if</span> self.digesting == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> random_or_none(self.place.bees) !=<span class="literal">None</span>:</span><br><span class="line">                self.eat_bee(random_or_none(self.place.bees))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.digesting -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># END Problem 6</span></span><br></pre></td></tr></table></figure>

<p>我们看到，这里我们使用<code>Insert.__init__(self,armor)</code>继承了父类的所有实例属性，并且在这基础上又增加了一个digesting属性作为该类独有的实例属性。</p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>多重继承顾名思义，就是从多个父类继承的子类，比如，作为你父母的孩子，你既继承了你父亲的身高智慧，又继承了你母亲的高鼻梁大眼睛，因此在你这个类当中，既有父亲传给你的属性，又有母亲传给你的属性。</p>
<p>Python 支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。</p>
<p>恩，突然一下子想不出什么特别好的例子，大家可以在CS61A的一些习题当中找一些例子来看。</p>
<h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><p>在 Python 中，某些特殊名称会在特殊情况下由 Python 解释器调用。例如，每当构造对象时，都会自动调用类的__init__方法。每当打印对象时会自动调用__str__方法，在交互式会话到显示值会调用repr方法。</p>
<p>假设我们有一个类A</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,number</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.number = number</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span> + self.name + <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<p>那么我们在打印A类所构造的实例对象时，就会自动调用__str__函数打印，交互式对话输入自动调用repr</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="string">&#x27;alien&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">&lt;alien&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">alien</span><br></pre></td></tr></table></figure>

<p>我们用Link对象举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A linked list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Link(1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.first</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest is Link.empty</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.first = 5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest.first = 6</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest.rest = Link.empty</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)</span></span><br><span class="line"><span class="string">    Link(5, Link(6))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Link(5, Link(7, Link(Link(8, Link(9)))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(s)                             # Prints str(s)</span></span><br><span class="line"><span class="string">    &lt;5 7 &lt;8 9&gt;&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    empty = ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, rest=empty</span>):</span><br><span class="line">        <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">        self.first = first</span><br><span class="line">        self.rest = rest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            rest_repr = <span class="string">&#x27;, &#x27;</span> + <span class="built_in">repr</span>(self.rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest_repr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#x27;</span> + <span class="built_in">repr</span>(self.first) + rest_repr + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        string = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            string += <span class="built_in">str</span>(self.first) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">            self = self.rest</span><br><span class="line">        <span class="keyword">return</span> string + <span class="built_in">str</span>(self.first) + <span class="string">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>虽然我们还没有讲到链表类，但是我们可以看到，Link类也重写了str和repr方法，因此Link类实现 方法的实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;s = Link(<span class="number">2</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>)))</span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>)))</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(s)</span><br><span class="line">&lt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>

<p>除了最基本的str和repr特殊方法之外，python也支持对其他特殊方法进行修改，我们这里以contain特殊方法为例进行介绍,contain特殊方会在对实例使用in指令时自动调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,x</span>):</span><br><span class="line">    <span class="keyword">if</span> self.first == x：</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> self.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">in</span> self.rest</span><br></pre></td></tr></table></figure>

<p>这样我们就改写了contain特殊方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;l=Link(<span class="number">1</span>,Link(<span class="number">2</span>,Link(<span class="number">3</span>)))</span><br><span class="line">&gt;&gt;&gt;<span class="number">2</span> <span class="keyword">in</span> l</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">4</span> <span class="keyword">in</span> l</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>下面是一些常见的特殊方法，大家可以对其进行改写试一试。</p>
<p><img src="https://i.loli.net/2021/08/09/eG2QDp4y7vlIH9a.png" alt="image-20210809105526287"></p>
<h3 id="递归对象的实现"><a href="#递归对象的实现" class="headerlink" title="递归对象的实现"></a>递归对象的实现</h3><p>对象可以有其他对象作为属性值。当某个类的对象具有同一个类的属性值时，它就是递归对象。</p>
<p>常见的递归对象有链表类和树类两种</p>
<h4 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h4><p>本章前面已经提前给出Link类的概念，我们再次回顾一下，链表由第一个元素和列表的其余部分组成，链表的其余部分只能是一个链表，链表是一个序列，它的长度是有限的，并且支持按索引选择元素。</p>
<p>我们可以实现一个Link类，表示一个链表对象。每个Link实例都有两个实例属性，first和rest。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span>:</span><br><span class="line">    empty = ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, rest=empty</span>):</span><br><span class="line">        <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">        self.first = first</span><br><span class="line">        self.rest = rest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            rest_repr = <span class="string">&#x27;, &#x27;</span> + <span class="built_in">repr</span>(self.rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest_repr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#x27;</span> + <span class="built_in">repr</span>(self.first) + rest_repr + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        string = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            string += <span class="built_in">str</span>(self.first) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">            self = self.rest</span><br><span class="line">        <span class="keyword">return</span> string + <span class="built_in">str</span>(self.first) + <span class="string">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看出，链表第一个元素没有限制，但是第二个元素只能是一个链表或空链表，由于每个链表的第二个元素都是链表，所以链表是一个递归对象</p>
<p>让我们通过一个例子来进一步加深印象，这道题是61A的题目。</p>
<blockquote>
<p>编写一个函数store_digits，接收一个整数n并返回一个链表，其中链表的每个元素都是 的一个数字n。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store_digits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Stores the digits of a positive number n in a linked list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = store_digits(1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Link(1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; store_digits(2345)</span></span><br><span class="line"><span class="string">    Link(2, Link(3, Link(4, Link(5))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; store_digits(876)</span></span><br><span class="line"><span class="string">    Link(8, Link(7, Link(6)))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># In iteration</span></span><br><span class="line">    new_link = Link.empty</span><br><span class="line">    <span class="keyword">while</span> n !=<span class="number">0</span>:</span><br><span class="line">        new_link = Link(n%<span class="number">10</span>,new_link)</span><br><span class="line">        n = n//<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> new_link</span><br></pre></td></tr></table></figure>

<p>这道题目就利用了Link递归的特性，通过递归过程对不断加长拓展链表，最终构成一个单一数字的链表。</p>
<h4 id="树类"><a href="#树类" class="headerlink" title="树类"></a>树类</h4><p>回想一下，树是一种递归抽象数据类型，它具有label（存储在树根中的值）和branches（根正下方的树列表）两种不同类型的值，在数据抽象一章中，我们曾经使用将树视为列表的构造函数和选择器函数实现过树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tree ADT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span><br><span class="line"><span class="string">    otherwise.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">t, indent=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span><br><span class="line"><span class="string">    indented by two spaces times its depth from the root.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(tree(1))</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(numbers)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">        7</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;  &#x27;</span> * indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_tree</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a copy of t. Only for testing purposes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(5)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; copy = copy_tree(t)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(6)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(copy)</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tree(label(t), [copy_tree(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure>

<p>但是我们会发现使用这种方式创建的树是不可更改的，因为我们无法为调用表达式赋值，为了能够实现对树的修改，我们将构造器的功能用树类实现，而将选择器的功能用访问实例属性的点表达式实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t.label</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t.branches[0].label</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t.branches[1].is_leaf()</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, branches=[]</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches:</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, Tree)</span><br><span class="line">        self.label = label</span><br><span class="line">        self.branches = <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.branches</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以方便的创建树对象和修改树对象的label和branches属性，而不需要通过调用函数来获得树对象的各项属性，同时我们还可以在树类中任意增加各种方法，同样也只需要对实例进行方法调用即可。</p>
<p>此外，使用构造选择函数和列表实现的树ADT与使用类与对象实现的树ADT还有如下的区别</p>
<p><img src="https://i.loli.net/2021/08/09/q6QKxZFmIGuWihL.png" alt="image-20210809154119551"></p>
<p>总的来说，利用类实现的树ADT具有可变的特点，因此使用起来要比函数式的ADT更加便捷。</p>
]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>程序结构</tag>
        <tag>CS61</tag>
        <tag>CS61A</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61A-综述</title>
    <url>/posts/feb1c775/</url>
    <content><![CDATA[<h2 id="CS61A-综述"><a href="#CS61A-综述" class="headerlink" title="CS61A 综述"></a>CS61A 综述</h2><p>简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。</p>
<p>首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。</p>
<p>而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。</p>
<p>最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。</p>
<p>本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。</p>
<p>但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。</p>
<p>从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。</p>
<p>从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。</p>
]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>程序结构</tag>
        <tag>CS61</tag>
        <tag>CS61A</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61A-数据抽象</title>
    <url>/posts/e999557a/</url>
    <content><![CDATA[<h2 id="CS61A-数据抽象"><a href="#CS61A-数据抽象" class="headerlink" title="CS61A 数据抽象"></a>CS61A 数据抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>数据抽象导引</p>
<ul>
<li>构造器与选择器</li>
<li>序对的表示</li>
<li>抽象屏障与序对的过程性表示</li>
</ul>
<p>层次性数据和闭包性质</p>
<ul>
<li>序列的表示形式</li>
<li>可变数据与可变函数</li>
<li>层次性结构</li>
<li>迭代器与生成器</li>
</ul>
</blockquote>
<p><strong>带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。</strong></p>
<h3 id="数据抽象导引"><a href="#数据抽象导引" class="headerlink" title="数据抽象导引"></a>数据抽象导引</h3><hr>
<p>在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。</p>
<p><strong>数据抽象就是指将数据对象组合起来，构成复合数据的形式。</strong></p>
<p>这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adder_without</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> (ad+bc)//bd</span><br><span class="line"></span><br><span class="line">如果我们要计算<span class="number">1</span>/<span class="number">3</span>+<span class="number">4</span>/<span class="number">5</span>，那么我们就得这样传入参数</span><br><span class="line"></span><br><span class="line">&gt;&gt;adder_without(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">17</span>/<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。</p>
<p>但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？</p>
<p>答案就是构建构造函数与选择函数。</p>
<h4 id="构造器与选择器"><a href="#构造器与选择器" class="headerlink" title="构造器与选择器"></a>构造器与选择器</h4><p>接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">up,down</span>)：</span><br><span class="line">    <span class="keyword">return</span> [up,down]</span><br><span class="line"></span><br><span class="line">于是我们可以利用分子分母构建有理数a和b</span><br><span class="line"></span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>/<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">build</span> up down) (<span class="name"><span class="built_in">cons</span></span> up down)</span><br></pre></td></tr></table></figure>

<p>而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_up</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_down</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">于是我们就可以使用以上两个函数提取数据</span><br><span class="line"></span><br><span class="line">a_up = get_up(a)</span><br><span class="line">b_down = get_down(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用构造器与选择器重写加法函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)</span><br><span class="line"></span><br><span class="line">使用构造函数</span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">new = add(a,b)</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立<code>sub</code>,<code>mul</code>,<code>pow</code>等运算函数。</p>
<h4 id="序对的表示"><a href="#序对的表示" class="headerlink" title="序对的表示"></a>序对的表示</h4><p>其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   <span class="type">List</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="type">Tuple</span></span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125; <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line">Python中万物皆对象，所以提取数据的方式非常简单</span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line">b[<span class="number">1</span>]</span><br><span class="line">c[<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>在scheme语言中，序对表示为cons，但是cons只能有两个数据：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> x (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> <span class="number">2</span>)   #相当于x = [<span class="name">1</span>,<span class="number">2</span>],但是scheme没有python高级，实现序列需要cons函数</span><br><span class="line">  </span><br><span class="line">使用 car 和 cdr 提取数据</span><br><span class="line">(<span class="name"><span class="built_in">car</span></span> x)</span><br><span class="line">(<span class="name"><span class="built_in">cdr</span></span> x)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="抽象屏障与序对的过程性表示"><a href="#抽象屏障与序对的过程性表示" class="headerlink" title="抽象屏障与序对的过程性表示"></a>抽象屏障与序对的过程性表示</h4><p>抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最高层： 使用有理数运算函数的过程</span><br><span class="line"></span><br><span class="line">第一层： 有理数运算函数 add() sub() mul() </span><br><span class="line"></span><br><span class="line">第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）</span><br><span class="line">                                             </span><br><span class="line">第三层： 作为序对的有理数 cons() car()  cdr()  /list[]  tuple[]</span><br></pre></td></tr></table></figure>

<p>这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。</p>
<p>例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">up,down</span>): </span><br><span class="line">    g = gcd(up,down)</span><br><span class="line">    <span class="keyword">return</span> [up/g,down/g]</span><br></pre></td></tr></table></figure>

<p>这样就完成了约分有理数的过程。</p>
<p>一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">cons</span></span> x y))</span><br><span class="line">  (<span class="name"><span class="built_in">define</span></span> (<span class="name">dispatch</span> m))</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span> (<span class="name"><span class="built_in">=</span></span> m <span class="number">0</span>) x)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span> (<span class="name"><span class="built_in">=</span></span> m <span class="number">1</span>) y)</span><br><span class="line">    (<span class="name"><span class="built_in">else</span></span> (<span class="name">error</span>))</span><br><span class="line">    dispatch)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">car</span></span> z) (<span class="name">z</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">cdr</span></span> z) (<span class="name">z</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>由此我们可以看出，序对的概念实际上也可以解释为，由<code>(cons x y)</code>返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。</p>
<p>SICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？</p>
<p>答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(f(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上<code>one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) </code>),把这个结构抽象出来就得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">我们要实现 two = successor(one)</span><br><span class="line">所以 two = <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(one(f)(x))</span><br><span class="line">令one = n 则有</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(n(f)(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def church_to_int(n):</span><br><span class="line">    return n(lambda x:x+1)(0)</span><br><span class="line"></span><br><span class="line">这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;church_to_int(one)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt;church_to_int(three)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>同样也可以对church对象进行加法运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_church</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; church_to_int(add_church(two, three))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#church_to_int() if return 5 then five return five(f)</span></span><br><span class="line">    <span class="comment">#so we have to make add_church(two,three) like five(f)</span></span><br><span class="line">    <span class="comment">#five(f) return lambda x:f(f(f(f(f(x)))))  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(f)(x) +m(f)(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SICP中有church计数的scheme实现过程，大体类似。</p>
<h3 id="层次性数据和闭包性质"><a href="#层次性数据和闭包性质" class="headerlink" title="层次性数据和闭包性质"></a>层次性数据和闭包性质</h3><p>我们可以建立元素本身也是序对&#x2F;序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。</p>
<h4 id="序列的表示形式"><a href="#序列的表示形式" class="headerlink" title="序列的表示形式"></a>序列的表示形式</h4><p>在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> </span><br><span class="line">   (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> </span><br><span class="line">       (<span class="name"><span class="built_in">cons</span></span> <span class="number">3</span> nil)))</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">list(<span class="name">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">def lists (<span class="name"><span class="built_in">list</span></span>(<span class="name">1</span>,<span class="number">2</span>,<span class="number">3</span>)):</span><br></pre></td></tr></table></figure>

<p>通过上面的方式构建起<code>lists</code>这个表对象，而后使用cdr和car对表对象包含的数据进行调用</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">car</span></span> lists)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="name"><span class="built_in">cdr</span></span> lists)</span><br><span class="line">(<span class="name">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="built_in">car</span></span>(<span class="name"><span class="built_in">cdr</span></span> lists))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>我们也可以构建函数返回表中的第n个项：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">list-n</span> list n))</span><br><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">car</span></span> list)</span><br><span class="line">      (<span class="name">list-n</span> (<span class="name"><span class="built_in">cdr</span></span> items) (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">于是对lists对象使用</span><br><span class="line">    </span><br><span class="line">(<span class="name">list-n</span> lists <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>scheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">同样的过程只需要</span><br><span class="line"></span><br><span class="line">lists = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">调用返回第n项也只需要</span><br><span class="line"></span><br><span class="line">a = lists[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lists1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>



<h4 id="可变数据与可变函数"><a href="#可变数据与可变函数" class="headerlink" title="可变数据与可变函数"></a>可变数据与可变函数</h4><p>由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&lt;stat&gt;)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">min</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,key=)</span><br><span class="line"><span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">any</span>()</span><br><span class="line"><span class="built_in">bool</span>()</span><br></pre></td></tr></table></figure>

<p>以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于<strong>可变序列</strong>，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">可变序列：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].append(<span class="string">&#x27;a&#x27;</span>)   </span><br><span class="line">dicts[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">不可变序列</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.append(<span class="string">&#x27;a&#x27;</span>)    Error</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>).append(<span class="string">&#x27;a&#x27;</span>)   Error</span><br></pre></td></tr></table></figure>

<p>具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表<code>list1 = [1,2,3,4]</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    list1.append(x)</span><br><span class="line">    list1.append(x)</span><br><span class="line"></span><br><span class="line">执行func(<span class="number">3</span>)后list1会改变吗？</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;func(<span class="number">3</span>)</span><br><span class="line">&lt;&lt;&lt;list1</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。</span><br></pre></td></tr></table></figure>

<p>有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_money</span>(<span class="params">my_money</span>):</span><br><span class="line">     my_money -=<span class="number">20</span></span><br><span class="line">     <span class="keyword">return</span> my_money</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;my_money = <span class="number">100</span></span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money</span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>我们会发现这种方式很麻烦，因为要不断返回和重新赋值给<code>my_money</code>变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？</p>
<p>有的，那就是<strong>可变函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_draw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_draw</span>(<span class="params">acount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            balance = balance - acount</span><br><span class="line">            <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里出现了一个新的类型<code>nonlocal</code>，意思是非本地，也就是说，定义为<code>nonlocal</code>的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 <code>nonlocal</code>必须满足以下几个条件才能使用：</p>
<blockquote>
<p>1.nonlocal 声明的变量必须存在于父框架</p>
<p>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。</p>
</blockquote>
<p>我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？</p>
<p>答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于<code>balance=balance-accont</code>这个表达式判断balance是本地变量，而后在<code>if account &gt; balance</code>中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）</p>
<p>有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_draw</span>(<span class="params">balance</span>):</span><br><span class="line">    b= []</span><br><span class="line">    b[<span class="number">0</span>] = balance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_draw</span>(<span class="params">acount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b[<span class="number">0</span>] = b[<span class="number">0</span>] - acount</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。</p>
<h4 id="层次性结构"><a href="#层次性结构" class="headerlink" title="层次性结构"></a>层次性结构</h4><p>序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> branches(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> is_tree(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="params">tree</span>) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(<span class="params">tree</span>) &lt; <span class="number">1</span>:</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> <span class="literal">False</span></span></span><br><span class="line"><span class="params">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(<span class="params">branch</span>):</span></span><br><span class="line"><span class="params">            <span class="keyword">return</span> <span class="literal">False</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">True</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> is_leaf(<span class="params">tree</span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span></span><br><span class="line"><span class="string"><span class="params">    otherwise.</span></span></span><br><span class="line"><span class="string"><span class="params">    &quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="keyword">not</span> branches(<span class="params">tree</span>)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">def</span> print_tree(<span class="params">t, indent=<span class="number">0</span></span>):</span></span><br><span class="line"><span class="params">    <span class="string">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span></span><br><span class="line"><span class="string"><span class="params">    indented by two spaces times its depth from the root.</span></span></span><br><span class="line"><span class="string"><span class="params"></span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; print_tree(tree(1))</span></span></span><br><span class="line"><span class="string"><span class="params">    1</span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span></span><br><span class="line"><span class="string"><span class="params">    1</span></span></span><br><span class="line"><span class="string"><span class="params">      2</span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span></span><br><span class="line"><span class="string"><span class="params">    &gt;&gt;&gt; print_tree(numbers)</span></span></span><br><span class="line"><span class="string"><span class="params">    1</span></span></span><br><span class="line"><span class="string"><span class="params">      2</span></span></span><br><span class="line"><span class="string"><span class="params">      3</span></span></span><br><span class="line"><span class="string"><span class="params">        4</span></span></span><br><span class="line"><span class="string"><span class="params">        5</span></span></span><br><span class="line"><span class="string"><span class="params">      6</span></span></span><br><span class="line"><span class="string"><span class="params">        7</span></span></span><br><span class="line"><span class="string"><span class="params">    &quot;&quot;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="built_in">print</span>(<span class="params"><span class="string">&#x27;  &#x27;</span> * indent + <span class="built_in">str</span>(<span class="params">label(<span class="params">t</span>)</span>)</span>)</span></span><br><span class="line"><span class="params">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(<span class="params">t</span>):</span></span><br><span class="line"><span class="params">        print_tree(<span class="params">b, indent + <span class="number">1</span></span>)</span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure>

<p>以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。</p>
<p>递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。</p>
<p>我们来看几个关于树结构的问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">问题一：替换具有指定数据的树节点</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_leaf</span>(<span class="params">t, old, new</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to old has</span></span><br><span class="line"><span class="string">    been replaced with new.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,</span></span><br><span class="line"><span class="string">    ...                  [tree(&#x27;balder&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;freya&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;frigg&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;sif&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))</span></span><br><span class="line"><span class="string">    odin</span></span><br><span class="line"><span class="string">      balder</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      frigg</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      thor</span></span><br><span class="line"><span class="string">        sif</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      freya</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">if</span> label(t)==old:</span><br><span class="line">            <span class="keyword">return</span> tree(new)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tree(label(t))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_leaf(b,old,new) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line">可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">问题二：在每个叶节点上插入新子树</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, vals</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in vals at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">          6</span></span><br><span class="line"><span class="string">          1</span></span><br><span class="line"><span class="string">          2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(s) <span class="keyword">for</span> s <span class="keyword">in</span> vals ])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        lsb = []</span></span><br><span class="line"><span class="string">        for b in branches(t):</span></span><br><span class="line"><span class="string">            lsb += sprout_leaves(b,vals)</span></span><br><span class="line"><span class="string">        return [tree(label(t),lsb)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[sprout_leaves(b,vals) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure>

<p>下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">问题三：对应树的相加</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_trees</span>(<span class="params">t1, t2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; numbers = tree(1,</span></span><br><span class="line"><span class="string">    ...                [tree(2,</span></span><br><span class="line"><span class="string">    ...                      [tree(3),</span></span><br><span class="line"><span class="string">    ...                       tree(4)]),</span></span><br><span class="line"><span class="string">    ...                 tree(5,</span></span><br><span class="line"><span class="string">    ...                      [tree(6,</span></span><br><span class="line"><span class="string">    ...                            [tree(7)]),</span></span><br><span class="line"><span class="string">    ...                       tree(8)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(numbers, numbers))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">        6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">      10</span></span><br><span class="line"><span class="string">        12</span></span><br><span class="line"><span class="string">          14</span></span><br><span class="line"><span class="string">        16</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \</span></span><br><span class="line"><span class="string">    tree(2, [tree(3, [tree(4)]), tree(5)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t1) <span class="keyword">and</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span>(tree(label(t1)+label(t2)))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t1):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t2))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lsp = []</span><br><span class="line">        node = label(t1)+label(t2)</span><br><span class="line">        zips = <span class="built_in">list</span>(<span class="built_in">zip</span>(branches(t1),branches(t2)))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t1)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t2)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t2)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t1)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里所用到的zip函数请自行查阅python指南，解答过程如上。</p>
<h4 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h4><p>Python和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。</p>
<p>迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   迭代值</span><br><span class="line">iters = <span class="built_in">iter</span>(prime)  迭代器</span><br></pre></td></tr></table></figure>

<p>利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line">StopIteration </span><br></pre></td></tr></table></figure>

<p>当到达处理序列末尾后再次调用<code>next</code>方法将会引发StopIteration异常，说明序列已经迭代完毕。</p>
<p>两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  =  <span class="built_in">range</span> ( <span class="number">3</span> ,  <span class="number">13</span> ) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第一个迭代器s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第二个迭代器t </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u  =  <span class="built_in">iter</span>(t)  <span class="comment"># 第二个迭代器的替代名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>这里有一个利用迭代器计算斐波纳契数列的实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_iter</span>(<span class="params">n</span>):</span><br><span class="line">    prev,curr=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="built_in">list</span> = [prev,curr]</span><br><span class="line">    index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        prev,curr = curr,prev+curr</span><br><span class="line">        <span class="built_in">list</span> +=[curr]</span><br><span class="line">        index ++</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。</p>
<p>生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素</p>
<p>生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">letters_generator</span>():</span><br><span class="line">    current = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> current &lt;=<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">yield</span> current</span><br><span class="line">        current =<span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;letters = letters_generator()</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(letters)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>再复杂一点可以这样使用生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">natural</span>():</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">        x+<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;ns1,ns2=natural(),natural()</span><br><span class="line">&gt;&gt;&gt;[<span class="built_in">next</span>(ns1)*<span class="built_in">next</span>(ns2) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>程序结构</tag>
        <tag>CS61</tag>
        <tag>CS61A</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61A-过程抽象</title>
    <url>/posts/d5dca63c/</url>
    <content><![CDATA[<h2 id="CS61A-过程抽象"><a href="#CS61A-过程抽象" class="headerlink" title="CS61A 过程抽象"></a>CS61A 过程抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>程序设计的基本元素</p>
<ul>
<li>表达式</li>
<li>变量与环境</li>
<li>复合过程与函数</li>
<li>条件表达式与判定符号</li>
<li>过程作为黑箱抽象</li>
</ul>
<p>过程产生的计算</p>
<ul>
<li>线性递归与迭代</li>
<li>树形递归</li>
</ul>
<p>高阶函数抽象</p>
<ul>
<li>过程作为参数</li>
<li>过程作为一般性的方法</li>
<li>过程作为返回值</li>
<li>使用匿名函数构造过程</li>
</ul>
</blockquote>
<h3 id="程序设计的基本元素"><a href="#程序设计的基本元素" class="headerlink" title="程序设计的基本元素"></a>程序设计的基本元素</h3><hr>
<p>一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：</p>
<p>一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int(‘s’),这叫做复合表达式，表达式是语言最简单的个体。</p>
<p>二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素</p>
<p>三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用</p>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;s&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过将基本表达式进行组合，我们可以得到组合式</p>
<blockquote>
<p>3-1</p>
<p>‘s’ + ‘e’</p>
</blockquote>
<p>组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>+(<span class="number">4</span>*<span class="number">6</span>))*(<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p> 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。</p>
<p><img src="https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png" alt="image-20210612194156857"></p>
<h4 id="变量与环境"><a href="#变量与环境" class="headerlink" title="变量与环境"></a>变量与环境</h4><p>我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用<code>pi*(2**2)</code>进行计算，当我们想要计算的半径变为3时，我们又得写表达<code>pi*(3**2)</code>,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用<code>pi*(r**2)</code>就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。</p>
<p>不同语言定义变量的方式不同</p>
<p>Lisp</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> r <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>C</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> r = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。</p>
<h4 id="复合过程与函数"><a href="#复合过程与函数" class="headerlink" title="复合过程与函数"></a>复合过程与函数</h4><p>由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象</p>
<p>那么如果我们要对过程进行抽象该怎么办呢？</p>
<p>过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，<strong>为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。</strong></p>
<p>例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square</p>
<p>不同语言定义函数&#x2F;复合过程名称的方式不同</p>
<p><em>Lisp</em></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x) (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure>

<p><em>Python</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>定义好之后就可以使用square进行调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(sqare <span class="number">21</span>)</span><br><span class="line">square(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以利用已定义好的函数去构建其他过程，以python为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_sq</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> square(x) + square(y)</span><br></pre></td></tr></table></figure>

<p>还可以利用sum_sq去构造其他过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> sum_aq(a,a)</span><br></pre></td></tr></table></figure>

<h4 id="条件表达式与符号"><a href="#条件表达式与符号" class="headerlink" title="条件表达式与符号"></a>条件表达式与符号</h4><p>至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式</p>
<p>不同的语言中条件表达式不同</p>
<p><em>Lisp</em></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</span><br><span class="line">     (<span class="name">cond</span>  (<span class="name">&gt;</span> x <span class="number">0</span>)x)</span><br><span class="line">            (<span class="name">=</span> x <span class="number">0</span>)<span class="number">0</span>)</span><br><span class="line">            (<span class="name">&lt;</span> x <span class="number">0</span>)(<span class="name">-x</span>))</span><br><span class="line">     )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Python没有switch语句，可以用if..elif…替代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> x = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> x &lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p>if是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。</p>
<p>除了&gt;&lt;&#x3D;之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。</p>
<p>例如Lisp中</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">and</span>(<span class="name">&gt;</span> x <span class="number">5</span>)(<span class="name">&lt;</span> x <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h4 id="函数作为黑箱抽象"><a href="#函数作为黑箱抽象" class="headerlink" title="函数作为黑箱抽象"></a>函数作为黑箱抽象</h4><p>sqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的</p>
<p><img src="https://i.loli.net/2021/06/12/u4zixB95rycdopg.png" alt="image-20210612202953454"></p>
<p>这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。</p>
<h5 id="内部定义与块结构"><a href="#内部定义与块结构" class="headerlink" title="内部定义与块结构"></a>内部定义与块结构</h5><p>为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。</p>
<h3 id="函数产生的计算"><a href="#函数产生的计算" class="headerlink" title="函数产生的计算"></a>函数产生的计算</h3><hr>
<h4 id="线性递归与迭代"><a href="#线性递归与迭代" class="headerlink" title="线性递归与迭代"></a>线性递归与迭代</h4><p>我们以函数的阶乘为例，讲解函数的递归和迭代。</p>
<p>首先，我们使用递归来计算阶乘</p>
<p>考虑阶乘函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n! = n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>)..<span class="number">.1</span></span><br><span class="line">(n-<span class="number">1</span>)! = (n-<span class="number">1</span>)*(n-<span class="number">2</span>)..<span class="number">.1</span></span><br><span class="line">n! = n*(n-<span class="number">1</span>)! </span><br></pre></td></tr></table></figure>

<p>这样，我们就能通过算出(n-1)!，i进而计算出n！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">     <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这个过程如图所示</p>
<p><img src="https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png" alt="image-20210612215413983"></p>
<p>于是我们总结出迭代所需要的三个要素：</p>
<p><em>一是base_case也就是迭代终止条件</em></p>
<p>*二是可迭代拆分的结构，比如<code>factorial(n)</code>的结果就可以分解成为<code>n * factorial(n-1)</code></p>
<p><em>三是可以连续传递</em>，验证n与n-1的规则是否通用。</p>
<p>但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如</p>
<blockquote>
<p>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：</p>
<p>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,</p>
<p>def pingpong(n): ?</p>
</blockquote>
<p>这里的<code>pingpong(n)</code>和<code>pingpong(n-1)</code>无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pingpong</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">itera</span>(<span class="params">out,index=<span class="number">1</span>,adder=<span class="number">1</span></span>)</span><br><span class="line">        <span class="keyword">if</span> index == n:</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">        <span class="keyword">if</span> index%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> itera(out+adder,index+<span class="number">1</span>,adder=-adder)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> itera(out+adder,index+<span class="number">1</span>,adder=adder)</span><br><span class="line">    out = itera(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> out </span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<p>这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。</p>
<p>而后，我们再使用迭代对阶乘进行计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a = a*i</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。</p>
<p>迭代的表示如下：</p>
<p><img src="https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png" alt="image-20210613110228758"></p>
<p>迭代和递归是两种最常见的循环过程，其主要不同点在于：</p>
<p>一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。</p>
<p>迭代：</p>
<p><img src="https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png" alt="image-20210613110437725"></p>
<p>递归：</p>
<p><img src="https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png" alt="image-20210613110636563"></p>
<p>二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。</p>
<h4 id="树形递归"><a href="#树形递归" class="headerlink" title="树形递归"></a>树形递归</h4><p>树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。</p>
<p>首先我们以递归的思路来考虑</p>
<p><code>feb(n)</code>和<code>feb(n-1)</code>有什么关系？</p>
<p>貌似没有关系，但是我们知道<code>feb(n)=feb(n-1)+feb(n-2)</code></p>
<p>因此我们可以这样设计递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">feb</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：</p>
<p><img src="https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png" alt="image-20210613112437233"></p>
<p>树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题</p>
<blockquote>
<p>Q7：河内塔<br>一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。</p>
<p><img src="https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png" alt="image-20210613154038670"></p>
<p>拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：</p>
<p>一次只能移动一个磁盘。<br>每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。<br>任何磁盘都不能放置在较小磁盘的顶部。<br>完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。</p>
<p>题目给出了两个内置函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_move</span>(<span class="params">origin, destination</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print instructions to move a disk.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Move the top disk from rod&quot;</span>, origin, <span class="string">&quot;to rod&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_stack</span>(<span class="params">n, start, end</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print the moves required to move n disks on the start pole to the end</span></span><br><span class="line"><span class="string">    pole without violating the rules of Towers of Hanoi.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该<code>move_stack(3,1,3)</code>,而<code>move_stack(3,1,3)</code>这个过程可以分解为</p>
<p>一.先将上面两层移动至2,即<code>move_stack(2,1,2)</code></p>
<p>二.将底层移动到3,即<code>move_stack(1,1,3)</code></p>
<p>三.将在2的两层移至3,即<code>move_stack(2,2,3)</code></p>
<p>我们会发现实际上<code>move_stack(n,a,c)</code>可以分解为<code>move_stack(n-1,a,b)</code>，<code>move_stack(1,a,c)</code>,<code>move_stack(n-1,b,c)</code></p>
<p>因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。</p>
<p>具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move_stack</span>(<span class="params">n,start,end</span>):</span><br><span class="line">        bars = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        print_move(start,end)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c=[bar <span class="keyword">for</span> bar <span class="keyword">in</span> bars <span class="keyword">if</span> bar <span class="keyword">not</span> <span class="keyword">in</span> [start,end] ]</span><br><span class="line">        c = c[<span class="number">0</span>]</span><br><span class="line">        a = start</span><br><span class="line">        b = end </span><br><span class="line">        move_stack(n-<span class="number">1</span>,a,c)</span><br><span class="line">        move_stack(<span class="number">1</span>,a,b)</span><br><span class="line">        move_stack(n-<span class="number">1</span>,c,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的base_case就是n&#x3D;&#x3D;1。</p>
<h3 id="高阶函数抽象"><a href="#高阶函数抽象" class="headerlink" title="高阶函数抽象"></a>高阶函数抽象</h3><hr>
<h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>思考一下以下两个函数</p>
<p>第一个 sum_naturals函数计算最大为n的自然数之和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + [k], k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个sum_pi计算系列中的项的总和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + [<span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>))], k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xx</span> (n):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">n,term</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">natural</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pi</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。</p>
<h4 id="函数作为一般性方法"><a href="#函数作为一般性方法" class="headerlink" title="函数作为一般性方法"></a>函数作为一般性方法</h4><p>刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	<span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess=<span class="number">1</span></span>):</span><br><span class="line"><span class="number">2</span>	    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line"><span class="number">3</span>	        guess = update(guess)</span><br><span class="line"><span class="number">4</span>	    <span class="keyword">return</span> guess</span><br><span class="line"><span class="number">5</span>	</span><br><span class="line"><span class="number">6</span>	<span class="keyword">def</span> <span class="title function_">golden_update</span>(<span class="params">guess</span>):</span><br><span class="line"><span class="number">7</span>	    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"><span class="number">8</span>	</span><br><span class="line"><span class="number">9</span>	<span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line"><span class="number">10</span>	    <span class="keyword">return</span> approx_eq(guess * guess,</span><br><span class="line"><span class="number">11</span>	                     guess + <span class="number">1</span>)</span><br><span class="line"><span class="number">12</span>	</span><br><span class="line"><span class="number">13</span>	<span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span><br><span class="line"><span class="number">14</span>	    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line"><span class="number">15</span>	</span><br><span class="line"><span class="number">16</span>	phi = improve(golden_update,</span><br><span class="line"><span class="number">17</span>	              square_close_to_successor)</span><br></pre></td></tr></table></figure>

<p>我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">golden_update</span>(<span class="params">guess</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">           <span class="keyword">return</span> approx_eq(guess * guess,guess + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span> <span class="keyword">not</span> square_close_to_successor(guess):</span><br><span class="line">        guess = golden_update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line">phi = improve()</span><br></pre></td></tr></table></figure>

<p>这样一来整体的函数结构就清晰多了。</p>
<h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。</p>
<p>一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) &#x3D; f(g(x))。我们可以使用现有工具定义函数组合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> f(g(x))</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>

<p>这时候返回的函数就是f(g(x))</p>
<p>函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。</p>
<p>柯里化的具体实现过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curi_pow</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x,y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当调用<code>curi_pow(2)(3)</code>时，首先计算curi_pow(2),返回的函数实际上就是 <code>lambda  x: pow(2,x)</code>，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此<code>curi_pow(2)（3）</code>实际上是<code>lambda x:pow(2,x)(3)</code>也就是pow(2,3)</p>
<p>我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curi</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x,y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure>

<p>具体推导过程 如下：</p>
<p>要使得  s(x)(y) &#x3D; f(x,y)，则s &#x3D; lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。</p>
<p>柯里化也可以反向进行，具体实现过程为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uncuri</span>(<span class="params">g</span>):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x,y</span>):</span><br><span class="line">            <span class="keyword">return</span> g(x)(y)</span><br><span class="line">     <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>

<p>同理，要使得 f(x,y) &#x3D; g(x)(y)，则 f &#x3D; lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。</p>
<h4 id="使用匿名函数构造过程"><a href="#使用匿名函数构造过程" class="headerlink" title="使用匿名函数构造过程"></a>使用匿名函数构造过程</h4><p>到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。</p>
<p>lambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="keyword">lambda</span> x:x*x</span><br><span class="line">s(<span class="number">2</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。</p>
<p>一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">compose1=<span class="keyword">lambda</span> f,g:<span class="keyword">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure>

<p>匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。</p>
<p>我们知道，使用递归来进行阶乘的计算如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么如果使用匿名函数来进行递归，结构又该是什么样的呢？</p>
<p>我们先来看一个简单一点的方案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fact = <span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> n*fact(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> n,f:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> n*f(n-<span class="number">1</span>,f) </span><br></pre></td></tr></table></figure>

<p>于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact&#x3D; lambda n,f:1 if n&#x3D;&#x3D;1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。</p>
<p>解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。</p>
<p>fact &#x3D; lambda n:(lambda g:g(n,f))(lambda n,f:1 if n&#x3D;&#x3D;1 else n*f(n-1,f))</p>
<p>这个结构的原理是这样的，fact(3)首先等于<code>(lambda f:f(3,f))</code>，然而由于后i面还有一个<code>(lambda n,f:1 if n==1 else n*f(n-1,f))</code>因此f函数的值被填充为匿名函数，成为f(3,f) 其中 <code>f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))</code>。</p>
]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>程序结构</tag>
        <tag>CS61</tag>
        <tag>CS61A</tag>
      </tags>
  </entry>
  <entry>
    <title>CS自学路线与课程推荐</title>
    <url>/posts/17f76a70/</url>
    <content><![CDATA[<h1 id="CS基础课程自学路线与课程推荐"><a href="#CS基础课程自学路线与课程推荐" class="headerlink" title="CS基础课程自学路线与课程推荐"></a>CS基础课程自学路线与课程推荐</h1><p>简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考</p>
<p>注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。</p>
<hr>
<h3 id="计算机入门"><a href="#计算机入门" class="headerlink" title="计算机入门"></a>计算机入门</h3><h5 id="公开课程："><a href="#公开课程：" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><strong>哈佛大学 CS50</strong>   </li>
<li>斯坦福大学 CS101</li>
<li>麻省理工学院 6.00.1</li>
</ul>
<h5 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>《编码》： 一本讲清编码原理的书</li>
</ul>
<hr>
<h3 id="计算机程序结构与抽象"><a href="#计算机程序结构与抽象" class="headerlink" title="计算机程序结构与抽象"></a>计算机程序结构与抽象</h3><h5 id="公开课程：-1"><a href="#公开课程：-1" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><p><strong>加州大学伯克利分校  CS61A</strong></p>
</li>
<li><p>斯坦福大学 CS106A  [Python]  </p>
</li>
<li><p>卡内基梅隆大学 CMU 15-122</p>
</li>
</ul>
<h5 id="书籍推荐：-1"><a href="#书籍推荐：-1" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><p>《计算机程序的构造和解释》</p>
<blockquote>
<p>SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。</p>
</blockquote>
<hr>
<h3 id="计算机系统架构与体系"><a href="#计算机系统架构与体系" class="headerlink" title="计算机系统架构与体系"></a>计算机系统架构与体系</h3><p>对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。</p>
<h5 id="公开课程：-2"><a href="#公开课程：-2" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><strong>计算机系统要素  Nand2Tetris</strong></li>
</ul>
<blockquote>
<p>这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I&#x2F;O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。</p>
</blockquote>
<h5 id="书籍推荐：-2"><a href="#书籍推荐：-2" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>计算机系统要素  Nand2Tetris的原书</li>
</ul>
<hr>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。</p>
<h5 id="公开课程：-3"><a href="#公开课程：-3" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><strong>加州大学伯克利分校  CS61B</strong></li>
</ul>
<blockquote>
<p>cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。</p>
</blockquote>
<ul>
<li>斯坦福 CS106B</li>
<li>卡内基梅隆大学 CMU 15-210</li>
</ul>
<h5 id="书籍推荐：-3"><a href="#书籍推荐：-3" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>算法导论</li>
</ul>
<blockquote>
<p>老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。</p>
</blockquote>
<ul>
<li>大话数据结构</li>
</ul>
<blockquote>
<p>深入浅出的讲解数据结构，作为入门当小说看看挺好的。</p>
</blockquote>
<ul>
<li>算法图解</li>
</ul>
<blockquote>
<p>同样是入门书籍，看看培养兴趣挺好的。</p>
</blockquote>
<hr>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。</p>
<h5 id="公开课程：-4"><a href="#公开课程：-4" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li>斯坦福大学 CS144</li>
<li>网易云课堂 《计算机网络》</li>
</ul>
<h5 id="书籍推荐：-4"><a href="#书籍推荐：-4" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li><strong>计算机网络自顶而下</strong></li>
</ul>
<blockquote>
<p>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。</p>
</blockquote>
<ul>
<li>计算机网络(谢希仁版)</li>
</ul>
<blockquote>
<p>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。</p>
</blockquote>
<hr>
<h3 id="计算机系统与运行"><a href="#计算机系统与运行" class="headerlink" title="计算机系统与运行"></a>计算机系统与运行</h3><p>学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。</p>
<h5 id="公开课程"><a href="#公开课程" class="headerlink" title="公开课程:"></a>公开课程:</h5><ul>
<li><strong>卡内基梅隆大学 CSAPP 配套课程  （B站有）</strong></li>
<li>卡内基梅隆大学 CMU 15-213</li>
<li>加州大学伯克利大学 CS61C</li>
<li>斯坦福大学 CS107</li>
</ul>
<h5 id="书籍推荐：-5"><a href="#书籍推荐：-5" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>深入理解计算机系统 CSAPP</li>
</ul>
<blockquote>
<p>计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。</p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>知乎文章《计算机名校路线课程》</li>
<li>网易云课堂  顶尖大学中文计算机课程</li>
</ol>
]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
        <tag>计算机课程</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT:不能用来摸鱼的AI不是好AI</title>
    <url>/posts/2f0634a9/</url>
    <content><![CDATA[<h1 id="ChatGPT-不能用来摸鱼的AI不是好AI"><a href="#ChatGPT-不能用来摸鱼的AI不是好AI" class="headerlink" title="ChatGPT: 不能用来摸鱼的AI不是好AI"></a>ChatGPT: 不能用来摸鱼的AI不是好AI</h1><p>最近ChatGPT的大火，使得很多的行业面临大洗牌，很多人都说要被GPT优化了，本来咱这个职业吧，跟ChatGPT可以说是八竿子打不着，无非也就是当个电子宠物玩玩。</p>
<p>不过最近在少数派看了篇文章，说可以用chatGPT直接生成markdown文档，再把markdown文档转为PPT演示文稿…..</p>
<p>诶这我就来兴趣了。</p>
<p>这多好的摸鱼工具阿，以后什么政治教育，双争教育，爱国主义教育，直接一步到位，还费心思写什么稿子，做什么ppt，这好哇，这可太好了。</p>
<p>但同时我也对其实现的可能性存在一定的质疑，主要在两方面：</p>
<blockquote>
<ol>
<li>chatGPT真的能实现一篇逻辑清晰，层次分明的文章么？</li>
<li>Markdown文件转为PPT的可行性有多少?</li>
</ol>
</blockquote>
<p>于是我分别就这两个问题进行了探究。</p>
<h2 id="ChatGPT实现文章撰写"><a href="#ChatGPT实现文章撰写" class="headerlink" title="ChatGPT实现文章撰写"></a>ChatGPT实现文章撰写</h2><h3 id="chatGPT的部署与使用"><a href="#chatGPT的部署与使用" class="headerlink" title="chatGPT的部署与使用"></a>chatGPT的部署与使用</h3><p>网络上有很多种方式可以部署chatGPT，有些是客户端，有些是网站部署，这里推荐Github上两个最主流的项目</p>
<blockquote>
<p>ChatGPT-Next-Web   ChatGPT Desktop Application</p>
</blockquote>
<h4 id="ChatGPT-Next-Web"><a href="#ChatGPT-Next-Web" class="headerlink" title="ChatGPT-Next-Web"></a>ChatGPT-Next-Web</h4><blockquote>
<p><a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web</a> 这个项目是利用使用 Vercel 一键部署的Next.js项目，可以直接fork原项目后，将自己仓库的rep部署到vercel，简便可靠。</p>
</blockquote>
<p>部署主要有以下几个步骤。</p>
<p>首先，我们要登录openai网站获取OpenAI API key</p>
<p><strong>第一步</strong>：挂上梯子，这里推荐<a href="https://dt666.xyz/">灯塔 Cloud </a>，可选择的线路比较多，可及时更换。<br><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427201916557.png" alt="image-20230427201916557"></p>
<p><strong>第二步</strong>：注册账号，并登录openAI官网，看似很简单，实则到处都是坑。</p>
<blockquote>
<p>！如果注册输入邮箱后，出现这个提示，说明这个邮箱被OpenAI拒绝注册了，目前QQ邮箱,foxmail邮箱，163邮箱，网易邮箱yeah.net，126邮箱，新浪邮箱，Outlook、hotmail邮箱，eud.cn邮箱以及其他以.cn结尾的邮箱全部都不能注册了 ，最好的办法就是注册一个Google账号，直接快捷登录。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202043393.png" alt="image-20230427202043393"></p>
</blockquote>
<blockquote>
<p>！如果输入跳转后提示 OpenAI’s services are not available in your country 说明你所在的地区不被允许登录，目前香港和台湾代理用不了的，最好用韩国或者北美的线路。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427201947140.png" alt="image-20230427201947140"></p>
</blockquote>
<blockquote>
<p>！登录的时候，又有一个手机号验证的过程，看了崔大的博客找到一个方法，可以花一块钱到<a href="https://sms-activate.org/">sms-active</a>买一个手机号接收验证码。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202001048.png" alt="image-20230427202001048"></p>
<p>把手机号输入进去，就能通过手机验证了。</p>
</blockquote>
<p><strong>第三步</strong> 获取openAI api key</p>
<p>登录API keys - <a href="https://platform.openai.com/account/api-keys">OpenAI API</a>，点击<code>View api key</code>查看账号Api key，自己新建一个然后保存。<br><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202157143.png" alt="image-20230427202157143"></p>
<p><strong>第四步</strong> 将项目部署到Vercel上</p>
<p>参考ChatGPT-Next-Web(<a href="https://github.com/Yidadaa/ChatGPT-Next-Web)%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%EF%BC%8C%E5%A4%A7%E6%A6%82%E5%B0%B1%E6%98%AF%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%85%A5API">https://github.com/Yidadaa/ChatGPT-Next-Web)项目自带的中文说明，大概就是创建一个项目，然后输入API</a> Key 和 配置密码code，点击部署，完成。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202207102.png" alt="image-20230427202207102"></p>
<p>然后打开项目就可以使用了。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202216433.png" alt="image-20230427202216433"></p>
<p>说实话UI界面做的还挺好看的。</p>
<p><strong>补充</strong> 给网站挂上域名</p>
<p>由于versel生成的地址太复杂而且很难记，为了简便使用我们可以给它挂个域名。</p>
<p>（域名最近出了点问题，自己看教程吧）</p>
<h4 id="ChatGPT-Desktop-Application"><a href="#ChatGPT-Desktop-Application" class="headerlink" title="ChatGPT Desktop Application"></a>ChatGPT Desktop Application</h4><blockquote>
<p><a href="https://github.com/lencx/ChatGPT">ChatGPT Desktop Application</a> 这个项目是一个多平台的客户端，可以实现很多网页浏览器不能实现的功能，直接下载使用。</p>
</blockquote>
<p>下载就完事了，注意一下版本不要下错了，windows 是msi文件，linux是deb文件,以windows为例，登录后界面是这样的</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202236458.png" alt="image-20230427202236458"></p>
<h3 id="chatgpt功能测试"><a href="#chatgpt功能测试" class="headerlink" title="chatgpt功能测试"></a>chatgpt功能测试</h3><p>作为一个经常需要做PPT(hu nong ling dao)的小排，我就直奔主题了，这次，我们来看看chatGPT能不能给我直接实现一篇markdown的教案。</p>
<p>话不多说，开搞。</p>
<p>首先我问了他这样一个问题。<br><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202249271.png" alt="image-20230427202249271"></p>
<p>他的回答是这样的<br><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202254794.png" alt="image-20230427202254794"></p>
<p>还行，但是感觉这个分点有点乱，正常我们上个教育一般都是分三个大点，然后每个大点里面再分三四个小点，这种层次的布局会更适合授课。</p>
<p>于是我调整了一下思路，给他设定了一下范围，并且给出了每个大点围绕的具体内容。</p>
<p>这是GPT的回答。<br><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202312249.png" alt="image-20230427202312249"></p>
<p>我简直可以拍手叫绝了，这个结构完完全全已经符合授课的要求了，如果能够再润色一下语言，那么这绝对是一篇牛逼的稿子。</p>
<p>总的来说，ChatGPT虽然不能直接给出一篇优秀的稿子，但是可以给我们的写作提供思路，比如如果你想写一篇关于挫折的文章，你就可以这样来收集信息</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202320460.png" alt="image-20230427202320460"></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202323843.png" alt="image-20230427202323843"></p>
<p>如果临时进行演讲，这将成为一个极其高效的工具。</p>
<h2 id="实现Markdown-PPT转换"><a href="#实现Markdown-PPT转换" class="headerlink" title="实现Markdown-PPT转换"></a>实现Markdown-PPT转换</h2><h3 id="Mindshow-fun"><a href="#Mindshow-fun" class="headerlink" title="Mindshow.fun"></a>Mindshow.fun</h3><p>简单看了下Mindshow这个软件，号称可以直接将markdown转换为ppt，于是我就先拿这个软件来开刀了。</p>
<p>这个软件覆盖的平台还蛮多的，从MacOS到Linux都覆盖了，开发者也是野心相当的大，还几乎处于测试阶段就全覆盖平台。</p>
<p>为了方便，我下了个windows的用，因为一般干工作上的活都是用的windows，写代码才开linux。</p>
<p>打开界面如下，导入的话可以选额md，word还有幕布格式。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202339958.png" alt="image-20230427202339958"></p>
<p>我们选择md格式，稍微调整了一下位置，我们把他下载下来看看效果。</p>
<blockquote>
<p>！第一个问题：兼容性不太好，wps显示数字就会乱码</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202347507.png" alt="image-20230427202347507"></p>
</blockquote>
<p>我们再来看看布局和页面有没有问题，看了一下效果，觉得还是比较满意的，每个插入的模块不管是图片还是文字都是可以拖动更改的而不是图片，这点做的很不错。</p>
<blockquote>
<p>!但是有个问题就在于，每个页面没有把最大的标题加上，这样看起来显得逻辑性不好，而且也不便于讲解者理清思路，他给出的模型是这样的</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202354321.png" alt="image-20230427202354321"></p>
<p>这里有几个问题，我标记出来了</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202402376.png" alt="image-20230427202402376"></p>
<blockquote>
<p>第一个问题，不需要数字标记的小点符号<br>第二个问题：正常我们每个页面除了本级的小标题还应该有个上级的大标题，这里如果没加上会显得东一句西一句，逻辑很乱。<br>第三个问题：每个小点只能对应一张幻灯片，如果需要一个小点讲两张片子，就不行了，这个问题可以解决一下。</p>
</blockquote>
</blockquote>
<p>总的来说，Mindshow可以实现从Markdown转PPT的操作，但是还有一些小的细节需要打磨一下，这样的话就更加符合正常ppt使用的习惯，就分页这点来说，我觉得可以借鉴一下Marp的做法。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230427202417087.png" alt="image-20230427202417087"></p>
<p>像这样用分割线来表示分页我觉得是一个很不错的想法，只要每次分割还保留本级和上级标题就可以实现我们正常使用的功能了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ChatGPT—Markdown—PPT 这个工作流虽然还存在一些技术性问题需要修改，但是不得不说这无形之中给未来的公职人员提出了更高的要求，如果只是会做毫无建树，毫无创新的工作，迟早有天会被AI所优化的。</p>
<p>总结，摸鱼很好用，躺着收课件指日可待。</p>
]]></content>
      <categories>
        <category>Talk</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
        <tag>Markdown</tag>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT-MissingSemester</title>
    <url>/posts/32824600/</url>
    <content><![CDATA[<p><strong>“对于计算机教育来说，从操作系统到机器学习，这些高大上课程和主题已经非常多了。然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。 这部分内容就是：精通工具。在这个系列课程中，我们会帮助您精通命令行、使用强大的文本编辑器、使用版本控制系统提供的多种特性等等。”</strong></p>
<p>​                                                                                                                                                                  <strong>——【MIT】The Missing Semester</strong></p>
<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Name：MIT-MissingSemester</p>
<p>Time：20h</p>
<p>Tips：Bash  |  Script  |  Vim  |  Data-Wrangling |  Git |  Debuging |  Security</p>
<p>Project：<a href="https://github.com/rigelJ/Learning-CS-fromScratch/tree/develop/missing_semester">Learning-CS-fromScratch</a></p>
<hr>
<h1 id="GUIDE"><a href="#GUIDE" class="headerlink" title="GUIDE"></a>GUIDE</h1><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p><strong>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR&#x2F;VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</strong></p>
<p>执行指令</p>
<ul>
<li><p>echo  </p>
<ul>
<li><p>echo “hello world”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>$PATH</p>
<ul>
<li><p>shell通过$PATH的值来寻找echo cd这类执行程序的位置，当我们执行 echo 命令时，shell 了解到需要执行 echo 这个程序，随后它便会在 $PATH 中搜索由 : 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>which </p>
<ul>
<li><p>判断该程序是在哪个目录被打开的 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">missing:~$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>位置导航</p>
<ul>
<li><p>描述计算机里文件的位置</p>
<ul>
<li>绝对路径<ul>
<li>绝对准确的定义一个文件的位置</li>
<li>pwd  查看当前路径</li>
</ul>
</li>
<li>相对路径<ul>
<li>相对当前路径所在路径</li>
<li>..  上一层目录</li>
<li>.  当前目录</li>
<li>~ 用户相关目录</li>
<li>上一个进入的目录，切换目录</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">missing:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ <span class="built_in">cd</span> /home</span><br><span class="line">missing:/home$ <span class="built_in">pwd</span></span><br><span class="line">/home</span><br><span class="line">missing:/home$ <span class="built_in">cd</span> ..</span><br><span class="line">missing:/$ <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line">missing:/$ <span class="built_in">cd</span> ./home</span><br><span class="line">missing:/home$ <span class="built_in">pwd</span></span><br><span class="line">/home</span><br><span class="line">missing:/home$ <span class="built_in">cd</span> missing</span><br><span class="line">missing:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ ../../bin/echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>cd   </p>
<ul>
<li>切换目录</li>
<li>后跟绝对路径或相对路径</li>
</ul>
</li>
<li><p>ls</p>
<ul>
<li>显示当前目录所有文件</li>
<li>-l  文件类型、权限<ul>
<li>rwx权限  <ul>
<li>文件<ul>
<li>r读权限</li>
<li>w写权限</li>
<li>x执行权限</li>
</ul>
</li>
<li>目录<ul>
<li>r阅读清单权限</li>
<li>w重命名新建删除文件权限</li>
<li>x搜索权限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span></span><br><span class="line">missing:~$ <span class="built_in">cd</span> ..</span><br><span class="line">missing:/home$ <span class="built_in">ls</span></span><br><span class="line">missing</span><br><span class="line">missing:/home$ <span class="built_in">cd</span> ..</span><br><span class="line">missing:/$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">...</span><br><span class="line">missing:~$ <span class="built_in">ls</span> -l /home</span><br><span class="line">drwxr-xr-x 1 missing  <span class="built_in">users</span>  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure>
</li>
<li><p>mv  </p>
<ul>
<li>重命名或移动文件</li>
<li>mv  dotfile.md foo.md</li>
</ul>
</li>
<li><p>cp  </p>
<ul>
<li>复制文件</li>
<li>cp  xxx</li>
</ul>
</li>
<li><p>rm</p>
<ul>
<li>删除文件</li>
<li>rmdir  <ul>
<li>删除目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>创建程序间的链接</p>
<ul>
<li><p>重定向输出流</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span>  hello &gt; hello.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向输入流</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt; hello.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt;&gt; hello.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>|  管道符号,  允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">tail</span>  -n1</span><br><span class="line">curl --<span class="built_in">head</span> --silent google.com | grep -i content-length </span><br></pre></td></tr></table></figure>
</li>
<li><p>root权限</p>
<ul>
<li>sudo  使用root权限执行指令</li>
<li>tee<ul>
<li>echo 1000 | sudo tee brightness</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><p><strong>在编程的时候，你会把大量时间花在阅读&#x2F;编辑而不是在写代码上。所以，Vim 是一个多模态编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</strong></p>
<p><strong>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</strong></p>
<p>Vim</p>
<ul>
<li><p>编辑模式</p>
<ul>
<li><p>模式切换</p>
<blockquote>
<p>在默认设置下，Vim 会在左下角显示当前的模式。Vim 启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。</p>
<p>你可以按下 <ESC>（退出键）从任何其他模式返回正常模式。在正常模式，键入 i 进入插入 模式，R 进入替换模式，v 进入可视（一般）模式，V 进入可视（行）模式，<C-v> （Ctrl-V, 有时也写作 ^V）进入可视（块）模式，: 进入命令模式。</p>
</blockquote>
</li>
<li><p>Normal mode</p>
<ul>
<li>移动光标<ul>
<li>hjkl  前后左右</li>
<li>wb  前后移动一个单词  e  移到单词末尾</li>
<li>0$ 行首行尾    ^行首的第一个非空字符</li>
<li>ctrl  ud   上下翻页</li>
<li>HML  屏幕的顶中底</li>
<li>gg  G 文件开头结尾</li>
<li>f&#x2F;F+x   移动到上下一个x字符   t&#x2F;T +x  x前一个字符</li>
</ul>
</li>
<li>编辑删除<ul>
<li>插入<ul>
<li>i  当前插入</li>
<li>o&#x2F;O 上下一行插入</li>
</ul>
</li>
<li>删除编辑复制<ul>
<li>x 删除当前字符</li>
<li>s 替换当前字符</li>
<li>d + e   删除到结尾</li>
<li>c + e   编辑到结尾</li>
<li>y + w  复制一个单词</li>
<li>dd&#x2F;cc&#x2F;yy  整行删除&#x2F;编辑&#x2F;复制</li>
</ul>
</li>
<li>替换<ul>
<li>r+x   将当前字符替换为x</li>
</ul>
</li>
<li>撤销<ul>
<li>u  撤销操作 </li>
<li>ctrl+r 恢复撤销</li>
</ul>
</li>
<li>v  选中</li>
<li>p 粘贴</li>
</ul>
</li>
<li>计数操作<ul>
<li>4j  向下4行</li>
<li>7dw  往后删除7个单词</li>
<li>c2w  往后修改2个单词</li>
</ul>
</li>
<li>修饰符<ul>
<li>ci( 更改当前括号内容</li>
<li>da’ 删除单引号字符串 包括周围的字符串</li>
</ul>
</li>
</ul>
</li>
<li><p>Insert mode</p>
<ul>
<li>N + i</li>
</ul>
</li>
<li><p>Replace mode</p>
<ul>
<li>N + r</li>
</ul>
</li>
<li><p>Visual  mode  </p>
<ul>
<li>N + v</li>
<li>Visual Line  +shift   一次选中一行</li>
<li>Visual Block  +ctrl   按块选中</li>
</ul>
</li>
<li><p>Command Line mode  </p>
<ul>
<li><p>N + :</p>
</li>
<li><p>：q  结束 </p>
<ul>
<li>：qa  结束多个</li>
</ul>
</li>
<li><p>：w  保存文件</p>
</li>
<li><p>:  e  打开文件并编辑</p>
</li>
<li><p>: help 帮助</p>
</li>
<li><p>: sp  切分同一文件</p>
<ul>
<li>Ctrl + w + hjkl  切换文件</li>
</ul>
</li>
<li><p>：！ls   指令</p>
</li>
<li><p>：r   读取文件并粘贴</p>
<ul>
<li>: r !ls   可以把命令输出的内容粘贴到当前光标所在处</li>
</ul>
</li>
<li><p>&#x2F; 搜索</p>
<ul>
<li>&#x2F;word   在文档中搜索word</li>
<li>n  下一个匹配</li>
<li>. 重复之前的行动</li>
</ul>
</li>
<li><p>: %s 替换</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">%s/foo/bar/gc  替换所有foo为bar,并确认</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>,<span class="number">12</span>s/foo/bar/g 将第 <span class="number">5</span> 行到第 <span class="number">12</span> 行（含）的所有行的每个“foo”更改为“bar”。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>.vimrc 配置文件</p>
<ul>
<li>Vim 由一个位于 ~&#x2F;.vimrc 的文本配置文件</li>
</ul>
</li>
<li><p>Vim 能够被重度自定义，花时间探索自定义选项是值得的。</p>
<ul>
<li><a href="https://missing-semester-cn.github.io/2020/files/vimrc">VIm配置参考</a></li>
</ul>
</li>
<li><p>vim插件 </p>
<ul>
<li><p>插件管理器</p>
<ul>
<li>vundle 旧</li>
<li>vim plug  新</li>
</ul>
</li>
</ul>
</li>
<li><p>nerdtree  文件浏览器</p>
<ul>
<li>CTRLp  文件浏览</li>
</ul>
</li>
<li><p>colorscheme  主题切换</p>
<ul>
<li>更多插件</li>
</ul>
</li>
<li><p><a href="https://vimawesome.com/">Vim Awesome</a></p>
</li>
<li><p>其他程序的vim模式</p>
<ul>
<li>Shell<ul>
<li>export EDITOR&#x3D;vim。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。</li>
</ul>
</li>
<li>Readline<ul>
<li>通过在 ~&#x2F;.inputrc 添加<code>set editing-mode vi</code></li>
</ul>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>Vim 的网页浏览快捷键 browsers</li>
<li>Google Chrome 的 Vimium </li>
<li>Firefox 的 Tridactyl</li>
<li><a href="https://reversed.top/2016-08-13/big-list-of-vim-like-software">其他支持vim键位绑定的软件</a></li>
</ul>
</li>
<li><p>vim的拓展学习资料</p>
<ul>
<li>vimtutor  直接在终端键入，这个是最好的教程</li>
</ul>
</li>
<li><p><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim wiki</a></p>
<ul>
<li><a href="https://vim-adventures.com/" title="a game to learning vim ">vim Adventures</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Data-wrangling"><a href="#Data-wrangling" class="headerlink" title="Data wrangling"></a>Data wrangling</h2><p><strong>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</strong></p>
<p><strong>数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</strong></p>
<p>Data Wrangling</p>
<ul>
<li><p>bash三剑客</p>
<ul>
<li>awk<ul>
<li>example<ul>
<li><code>&#39;&#123;print $2&#125;&#39; </code>  选择第二列</li>
<li><code>&#39;$1==1 &amp;&amp; $2 ~  /^c.*e$/&#39; &#123;print $0&#125;*  </code>   第一列是1  第二列符合c开头e结尾的模式</li>
<li><code>‘BEGIN &#123; rows = 0 &#125;  $1==1 $2 ~ /^c.*e$/&#123;rows+=1&#125; END &#123;print rows&#125;’* </code>   每当匹配到合适的行则row+1 ，最后输出row的值</li>
</ul>
</li>
<li>awk<ul>
<li>将每一行进行分割按照模块进行操作,awk读取一行，分割后操作，然后下一行，以此类推</li>
<li>格式  awk 【选项】【操作或模式】</li>
<li>-F 指定分割字符</li>
<li>内建变量<ul>
<li>NF	当前处理的行的字段个数（就是：有多少列）</li>
<li>NR	当前处理的行的行号（就是：有多少行）</li>
<li>FNR	读取文件的记录数（行号），从1开始，新的文件重新从1开始计数</li>
<li>$0	当前处理的行的整行内容（就是：表示一行的内容）</li>
<li>$n	当前处理行的第n个字段（就是：第n列）</li>
<li>FILENAME	被处理的文件名</li>
<li>FS	指定每行的字段分隔符，默认为空格或制表位（相当于选项 -F ）</li>
<li>OFS	输出字段的分隔符，默认也是空格</li>
</ul>
</li>
<li>BEGIN开始和END结尾<ul>
<li>BEGIN：一般用来做初始化操作，仅在读取数据记录之前执行一次</li>
<li>END：一般用来做汇总操作，仅在读取完数据记录之后执行一次</li>
</ul>
</li>
<li>模糊匹配<ul>
<li>$1 ~ &#x2F;xx&#x2F;  xx可以使用标准正则表达式进行匹配</li>
</ul>
</li>
<li>参考网址<ul>
<li><a href="https://blog.csdn.net/m0_57515995/article/details/125713566">awk参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>sed <ul>
<li>example<ul>
<li><code>cat ssh.log | sed &#39;s/.*Dissconnected from//&#39; * </code>将以某个模式结尾的部分替换为空</li>
<li><code>echo &quot;bba&quot;  | sed ‘s/[ab]//g’  </code>匹配a或者b</li>
<li><code>echo “abcaba” | sed -E &#39;s/(ab)*//g)&#39;* </code>匹配ab</li>
<li><code>echo &quot;abcababc&quot; | sed -E &#39;s/(ab|bc)//g)&#39;  </code>匹配ab或bc</li>
<li><code>&#39;s/^.*？Dissconnected from (invalid | authenticating)?  user  (.*)  [0-9.]+ port [0-9]+ (\[preauth\]?$)/ \2/g&#39;</code><ul>
<li>^$ 开头与结尾</li>
<li>? 0&#x2F;1次  + 1∞次  . 0∞次  [0-9] 范围  </li>
<li>(.<em>) 且没有修饰符的为捕获组</em></li>
<li>？ 改为非贪婪匹配</li>
</ul>
</li>
</ul>
</li>
<li>sed<ul>
<li>用于对整行进行各种操作</li>
<li>格式 sed 【选项】【操作】 参数</li>
<li>选项<ul>
<li>-E 使用扩展正则</li>
</ul>
</li>
<li>操作<ul>
<li>p  输出<ul>
<li>sed -n ‘4,&#x2F;the&#x2F;p’</li>
</ul>
</li>
<li>i  插入<ul>
<li>sed ‘&#x2F;the&#x2F;a 我是谁’</li>
</ul>
</li>
<li>d   删除<ul>
<li>sed ‘&#x2F;.$&#x2F;d’</li>
</ul>
</li>
<li>c  替换</li>
<li>s  替换指定字符，可以使用正则模式匹配<ul>
<li>sed  -n ‘s&#x2F;the&#x2F;THE&#x2F;‘</li>
<li>g  全部替换</li>
</ul>
</li>
<li>g G w  r  a 迁移<ul>
<li>G  追加指定行后   H 复制到剪贴板<ul>
<li>sed ‘1,5&#x2F;{H;d};14G’</li>
</ul>
</li>
<li>w  另存为文件<ul>
<li>sed ‘&#x2F;the&#x2F;w out.file’</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>参考网址<ul>
<li><a href="https://blog.csdn.net/qq_57377057/article/details/126216920">sed</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>grep<ul>
<li>example<ul>
<li><code>ssh tsp jounralctl  | grep ssh</code></li>
<li><code>sshtsp &#39;journalctl | grep ssh | grep &quot;Disconnected from&quot;&#39; | less</code></li>
<li>-v  反选</li>
</ul>
</li>
<li>grep <ul>
<li>格式  grep 【参数】【过滤的规则】</li>
<li>参数<ul>
<li>-n   显示过滤行所在行号</li>
<li>-c   显示匹配到的行数</li>
<li>-o   只显示匹配到的内容</li>
<li>-q  静默输出</li>
<li>-i  忽略大小写</li>
<li>-v  反向查找，显示不符合匹配的结果</li>
<li>-w   匹配某个词</li>
<li>-E 使用扩展正则</li>
<li>-R 递归查询<ul>
<li>grep -R “root” &#x2F;etc&#x2F;</li>
</ul>
</li>
<li>-l   打印文件路径<ul>
<li>grep -Rl “root” &#x2F;etc&#x2F;</li>
</ul>
</li>
<li>-A  -B  -C  匹配前后各几n行<ul>
<li>grep -n -C 2 “mail” &#x2F;etc&#x2F;passwd</li>
</ul>
</li>
</ul>
</li>
<li>正则表达式<ul>
<li>grep的过滤规则中可使用正则表达式进行过滤</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其他工具</p>
<ul>
<li>wc  -l  行数统计</li>
<li>sort   排序<ul>
<li>-n 数值排序</li>
<li>-k  选中空白分割</li>
<li>1，1  从第一列到第一列</li>
</ul>
</li>
<li>uniq -c  去掉重复的数据 统计数目</li>
<li>tail -n 10  从最后算起的10行</li>
<li>paste -sd  改为以tab分割的行</li>
<li>bc   简易计算器<ul>
<li><code>echo &quot;1+2&quot; | bc -l	</code></li>
<li><code>awk &#39;$1 !=1 &#123;print $1&#125;&#39; | paste -sd+ | bc -l</code></li>
</ul>
</li>
<li>R  统计语言</li>
<li>gnuplot   图表绘制</li>
<li>xargs  将行作为参数传递</li>
</ul>
</li>
<li><p>正则表达式基础</p>
<ul>
<li></li>
<li><p>abc…	Letters</p>
</li>
<li><p>123… 	Digit</p>
</li>
<li><p>\d  	Any Digit</p>
</li>
<li><p>\D 	Any Non-digit character</p>
</li>
<li><p>.	Any Character</p>
</li>
<li><p>.	 Period </p>
</li>
<li><p>[abc]	Only a, b, or c</p>
</li>
<li><p>[^abc]	Not a, b, nor c</p>
</li>
<li><p>[a-z]	Characters a to z</p>
</li>
<li><p>[0-9]	Numbers 0 to 9</p>
</li>
<li><p>\w 	Any Alphanumeric character</p>
</li>
<li><p>\W 	Any Non-alphanumeric character</p>
</li>
<li><p>{m}	m  Repetitions</p>
</li>
<li><p>{m,n} 	m to n Repetitions</p>
</li>
<li><p>.Zero or more repetitions</p>
</li>
<li><p>+One or more repetitions</p>
</li>
<li><p>?  Optional character</p>
</li>
<li><p>\s 	Any Whitespace</p>
</li>
<li><p>\S 	Any Non-whitespace character</p>
</li>
<li><p>^… $	Starts and ends</p>
</li>
<li><p>(…) 	Capture Group</p>
</li>
<li><p>(a(bc)) 	Capture Sub-group</p>
</li>
<li><p>(.*) 	Capture all</p>
</li>
<li><p>(abc|def) 	Matches abc or def</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><strong>版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。</strong></p>
<p><strong>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</strong></p>
<p><strong>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</strong></p>
<ul>
<li><strong>当前模块是谁编写的</strong></li>
<li><strong>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</strong></li>
<li><strong>最近的1000个版本中，何时&#x2F;为什么导致了单元测试失败？</strong></li>
</ul>
<p><strong>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</strong></p>
<p>Git</p>
<ul>
<li><p>Git的数据模型</p>
<ul>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/1-Repository/4-how-trees-are-made.html">自下而上的 Git</a></li>
</ul>
</li>
<li><p>Git的命令行接口</p>
<ul>
<li><p>配置</p>
<ul>
<li>git config<ul>
<li>级别<ul>
<li>&#x2F;etc&#x2F;gitconfig   system系统上所有用户通用</li>
<li>~&#x2F;.config&#x2F;git&#x2F;config  global当前用户</li>
<li>.git&#x2F;config   local当前仓库</li>
<li>高级别可覆盖</li>
</ul>
</li>
<li>git config –list  查看所有配置</li>
<li>git config –system&#x2F;global&#x2F;local xxx&#x3D;xxx 三级设定  <ul>
<li>user.name</li>
<li>user.email</li>
<li>core.editor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>帮助</p>
<ul>
<li>git help</li>
</ul>
</li>
<li><p>基础</p>
<ul>
<li><p>获取Git仓库</p>
<ul>
<li>git init  创建一个新的 git 仓库，其数据会存放在一个名为 .git 的目录下</li>
<li>git clone  从远端下载仓库<ul>
<li>git clone -b master  指定clone分支</li>
</ul>
</li>
</ul>
</li>
<li><p>记录每次更新到仓库</p>
<ul>
<li><p>git status 显示当前的仓库状态</p>
</li>
<li><p>git add <filename> 添加文件到暂存区</p>
</li>
<li><p>.gitignore  忽略指定文件</p>
<blockquote>
<p>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。匹配模式可以以（<code>/</code>）开头防止递归。匹配模式可以以（<code>/</code>）结尾指定目录。要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</p>
</blockquote>
</li>
<li><p>git diff  查看尚未暂存的文件更新了哪些部分</p>
<ul>
<li>git diff –staged  比对已暂存文件与最后一次提交的文件差异</li>
<li>git diff –cached  查看已经暂存起来的变化</li>
<li>git diff  &lt;版本1&gt; &lt;版本4&gt; <file></li>
</ul>
</li>
<li><p>git commit 创建一个新的提交</p>
<ul>
<li>git commit -m xxxx  以说明进行提交</li>
<li>git commit -a 自动将修改的都提交</li>
</ul>
</li>
<li><p>rm + git rm  删除某个文件</p>
</li>
<li><p>git rm  –cached README </p>
</li>
<li><p>git  mv  filefrom fileto  重命名文件</p>
</li>
</ul>
</li>
<li><p>查看提交历史</p>
<ul>
<li>git log  查找所有历史提交<ul>
<li>git log -p 显示每次提交的差异</li>
<li>git log –stat 显示每次提交被修改的文件</li>
<li>git log –pretty&#x3D;format:”%h - %an, %ar : %s”  定制显示格式</li>
<li>git log  –all –graph  –decorate  以流程图的形式显示 历史提交</li>
<li>git  log grep  显示说明匹配的的提交‘’</li>
</ul>
</li>
</ul>
</li>
<li><p>撤销操作</p>
<ul>
<li>git commit –amend  这次提交会合并覆盖上次提交</li>
<li>git reset  HEAD  <file> 取消所有暂存区的提交&#x2F;某个文件的提交</li>
<li>git checkout  – xxxx文件  撤销该文件尚未提交的修改</li>
</ul>
</li>
<li><p>远端操作</p>
<ul>
<li>git remote add origin <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a> 添加一个远程仓库</li>
<li>git remote rm origin  断开远端仓库</li>
<li>git remote  -v 查看已经配置的远程仓库服务器</li>
<li>git fetch origin 拉取远端分支信息</li>
<li>git branch -r 查看远端分支</li>
<li>git remote show origin  获取远程分支的更多信息</li>
<li>git push origin master(：master) 将对象传送至远端并更新远端引用</li>
<li>跟踪分支<ul>
<li>git check out -b test 创建并切换到新分支</li>
<li>git  push -u origin test  推送到远程分支，并且跟踪远程分支</li>
<li>git checkout -b newtest origin&#x2F;test 新建分支并跟踪远程分支</li>
<li>git branch -u origin&#x2F;test  设置已有的本地分支跟踪拉取的远程分支</li>
<li>git branch -r -d origin&#x2F;branchname 删除本地跟踪的远程分支</li>
<li>git push origin –delete branchname  删除仓库的远程分支</li>
</ul>
</li>
</ul>
</li>
<li><p>标签</p>
<ul>
<li>创建标签<ul>
<li>附注标签<ul>
<li>git tag -a v1.4 -m “my version 1.4”</li>
</ul>
</li>
<li>轻量标签<ul>
<li>git tag v1.4-lw</li>
</ul>
</li>
</ul>
</li>
<li>git tag -a v1.2 &lt;版本号&gt; 给之前的某个提交打标签</li>
<li>git push origin –tags  推送所有标签到远端</li>
<li>删除标签<ul>
<li>删除本地<ul>
<li>git tag -d v1.4-lw</li>
</ul>
</li>
<li>删除远端<ul>
<li>git push origin –delete <tagname></li>
</ul>
</li>
</ul>
</li>
<li>检出标签对应的文件版本<ul>
<li>git checkout 2.0.0</li>
</ul>
</li>
</ul>
</li>
<li><p>别名</p>
<ul>
<li>git config –global alias.co checkout</li>
</ul>
</li>
</ul>
</li>
<li><p>分支</p>
<ul>
<li>git branch testing  创建分支</li>
<li>git checkout testing  分支切换</li>
<li>git merge  合并分支<ul>
<li>合并冲突<ul>
<li>打开文件修改冲突后git add，然后commit</li>
</ul>
</li>
<li>–no-ff  能够将被合并的分支独立显示</li>
</ul>
</li>
<li>git branch 分支管理<ul>
<li>git branch -v  查看所有分支及其最后一次提交</li>
<li>git branch –merge&#x2F;–no-merge 合并&#x2F;未合并的分支</li>
</ul>
</li>
<li>git branch -d  删除分支，未合并的分支不能删除，强制丢弃使用-D</li>
<li>git 分支流<ul>
<li>master和develop作为常驻分支</li>
<li>feature分支<ul>
<li>功能分支用以开发新的版本功能，从develop引出，开发功能完成后，再合并回develop</li>
</ul>
</li>
<li>release分支<ul>
<li>发布分支准备新的生产版本，从develop引出，而后分别合并回develop和master分支</li>
</ul>
</li>
<li>hotfix分支<ul>
<li>修补分支从master分支创建，比如版本1.2是当前运行版本的一个原因，出现一个错误，因此从master1.2这个位置引出，而后合并回master1.21和develop</li>
</ul>
</li>
<li>参考<ul>
<li><a href="https://nvie.com/posts/a-successful-git-branching-model/">git分支工作流</a></li>
</ul>
</li>
</ul>
</li>
<li>远程分支<ul>
<li>git ls-remote <name> 显示远程引用的完整列表</li>
<li>git  fetch  更新远端分支情况</li>
<li>git push <remote> <branch> 将本地当前分支推送到远程分支</li>
<li>git checkout  -b <branch> <a href="remote:branch">remote:branch</a> 在新的远程分支上建立本地分支，该分支自动跟踪远端分支</li>
<li>git branch   -vv 可以看到本地分支的所有跟踪分支</li>
<li>git push origin –delete <remotename>  删除服务器上的远端分支</li>
</ul>
</li>
<li>变基<ul>
<li>你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。merge和rebase的整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。</li>
<li>git rebase –onto master server client  假设你希望将 client中的修改合并到主分支并发布，但暂时并不想合并 server中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用git rebase 命令的 –onto 选项</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器</p>
<ul>
<li>协议<ul>
<li>本地协议  <ul>
<li>git clone &#x2F;srv&#x2F;git&#x2F;project.git 克隆一个本地版本库</li>
<li>git remote add local_proj &#x2F;srv&#x2F;git&#x2F;project.git_ 增加一个本地版本库到现有的 Git 项目</li>
</ul>
</li>
<li>HTTP协议<ul>
<li>智能HTTP协议</li>
<li>哑HTTP协议<ul>
<li>只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 post-update 的挂钩就可以了 。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。</li>
<li><code>cd /var/www/htdocs/  git clone --bare /path/to/git_project gitproject.git  cd gitproject.git  mv hooks/post-update.sample hooks/post-update  chmod a+x hooks/post-update_  </code>克隆版本库并放在http的根目录</li>
<li><code>git clone https://example.com/gitproject.git </code>访问web服务器并clone版本库</li>
</ul>
</li>
</ul>
</li>
<li>SSH协议  <ul>
<li>git clone ssh:&#x2F;&#x2F;[user@]server&#x2F;project.git 使用ssh协议克隆版本库</li>
<li>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTPS 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</li>
<li>SSH 协议的缺点在于它不支持匿名访问 Git 仓库。 如果你使用 SSH，那么即便只是读取数据，使用者也得通过 SSH 访问你的主机， 这使得 SSH 协议不利于开源的项目，毕竟人们可能只想把你的仓库克隆下来查看。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外， 还得架设一个可以让其他人访问的服务。</li>
</ul>
</li>
<li>Git协议<ul>
<li>最后是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。</li>
</ul>
</li>
</ul>
</li>
<li>服务器上搭建Git<ul>
<li><code>git clone --bare my_project_ my_project.git_</code> 将现有仓库导出为裸仓库–即不包含当前工作目录</li>
<li><code>scp -r my_project.git user@git.example.com:/srv/git_  </code>若服务器上存在&#x2F;srv&#x2F;git目录，复制裸仓库来创建一个新仓库</li>
<li><code>git clone user@git.example.com:/srv/git/my_project.git_</code> 克隆你的仓库，如果一个用户，通过使用 SSH 连接到一个服务器，并且其对 &#x2F;srv&#x2F;git&#x2F;my_project.git_ 目录拥有可写权限，那么他将自动拥有推送权限。</li>
<li><code>ssh user@git.example.com cd /srv/git/my_project.git   git init --bare --shared</code>  如果到该项目目录中运行  git init  命令，并加上  –shared  选项， 那么 Git 会自动修改该仓库目录的组权限为可写。 注意，运行此命令的工程中不会摧毁任何提交、引用等内容。</li>
</ul>
</li>
<li><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE">剩余参考架设git服务器</a></li>
</ul>
</li>
<li><p>Github </p>
<ul>
<li><a href="https://git-scm.com/book/zh/v2/GitHub-%E8%B4%A6%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE">参考Git - 账户的创建和配置 (git-scm.com)</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Git差错补救</p>
<ul>
<li><a href="https://ohshitgit.com/#magic-time-machine">如何从错误中恢复</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><p><strong>代码不能完全按照您的想法运行，它只能完全按照您的写法运行，这是编程界的一条金科玉律。</strong></p>
<p><strong>让您的写法符合您的想法是非常困难的。在这节课中，我们会传授给您一些非常有用技术，帮您处理代码中的 bug 和程序性能问题。</strong></p>
<p>Debuging</p>
<ul>
<li>printf<ul>
<li>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</li>
</ul>
</li>
<li>log<ul>
<li>优势<ul>
<li>您可以将日志写入文件、socket 或者甚至是发送到远端服务器而不仅仅是标准输出</li>
<li>日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR等)，这使您可以根据需要过滤日志</li>
<li>对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。</li>
</ul>
</li>
<li>优化日志可读性<ul>
<li><code>echo -e &quot;\e[38;2;255;0;0mThis is red\e[0m&quot; </code>会打印红色的字符串</li>
</ul>
</li>
<li>第三方日志系统<ul>
<li>对于 UNIX 系统来说，程序的日志通常存放在 &#x2F;var&#x2F;log，例如，nginx web 服务器就将其日志存放于 &#x2F;var&#x2F;log&#x2F;nginx</li>
<li>目前，系统开始使用 system log，您所有的日志都会保存在这里。大多数（但不是全部的）Linux 系统都会使用 systemd，systemd 会将日志以某种特殊格式存放于 &#x2F;var&#x2F;log&#x2F;journal</li>
<li>类似地，在 macOS 系统中是 &#x2F;var&#x2F;log&#x2F;system.log，但是有更多的工具会使用系统日志，它的内容可以使用 log show 显示。</li>
<li>对于大多数的 UNIX 系统，您也可以使用 dmesg 命令来读取内核的日志。</li>
</ul>
</li>
<li>向系统日志中写日志<ul>
<li>写入日志<ul>
<li><code>logger “Hello Logs”</code></li>
</ul>
</li>
<li>查看是否写入 <ul>
<li><code>log show --last 1m | grep Hello  MacOS</code></li>
<li><code>journalctl --since  &quot;1m ago&quot; | grep Hello  LINUX</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>代码调试<ul>
<li>调试器是一种可以允许我们和正在执行的程序进行交互的程序<ul>
<li>调试器可以实现<ul>
<li>当到达某一行时将程序暂停；</li>
<li>一次一条指令地逐步执行程序；</li>
<li>程序崩溃后查看变量的值；</li>
<li>满足特定条件时暂停程序；</li>
</ul>
</li>
</ul>
</li>
<li>pdb Python使用的调试器<ul>
<li><code>pip install --user ipdb </code> 下载pdb调试器</li>
<li><code>python -m ipdb  bubble.py</code>  用pdb调试python程序</li>
<li>常用指令<ul>
<li>l(ist) - 显示当前行附近的11行或继续执行之前的显示；</li>
<li>s(tep) - 执行当前行，并在第一个可能的地方停止；</li>
<li>n(ext) - 继续执行直到当前函数的下一条语句或者 return 语句；</li>
<li>b(reak) - 设置断点（基于传入的参数）；</li>
<li>p(rint) - 在当前上下文对表达式求值并打印结果。</li>
<li>r(eturn) - 继续执行直到当前函数返回；</li>
<li>q(uit) - 退出调试器。</li>
<li>len() 长度</li>
<li>！c 检视c的值，！后是python值</li>
</ul>
</li>
<li>参考<ul>
<li><a href="https://github.com/MartinLwx/pdb-tutorial">MartinLwx&#x2F;pdb-tutorial: A simple tutorial about effectively using pdb (github.com)</a></li>
</ul>
</li>
</ul>
</li>
<li>其他调试器<ul>
<li>gdb </li>
<li>lldb</li>
</ul>
</li>
<li>调试工具<ul>
<li>strace  追踪程序执行的系统调用<ul>
<li>strace作为一种动态跟踪工具，能够帮助运维高效地定位进程和服务故障。</li>
<li>strace能够打开应用进程的这个黑盒，通过系统调用的线索，告诉你进程的行为<ul>
<li>系统调用<ul>
<li>系统调用（英语：system call），又称为系统呼叫，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。</li>
<li>linux常见的系统调用<ul>
<li>open&#x2F;close&#x2F;read&#x2F;write&#x2F;chmod等 文件和设备访问类</li>
<li>fork&#x2F;clone&#x2F;execve&#x2F;exit&#x2F;getpid等  进程管理类 </li>
<li>signal&#x2F;sigaction&#x2F;kill 等  信号类 </li>
<li>brk&#x2F;mmap&#x2F;mlock等  内存管理 </li>
<li>IPC shmget&#x2F;semget  进程间通信</li>
<li>socket&#x2F;connect&#x2F;sendto&#x2F;sendmsg 信号量，共享内存，消息队列等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>strace的两种运行模式<ul>
<li><code>strace ls -lh /var/log/messages </code> 通过它启动要跟踪的进程</li>
<li><code>strace -p 17553 </code>通过查看pid通过pid跟踪</li>
</ul>
</li>
<li>strace选项<ul>
<li>-tt 在每行输出的前面，显示毫秒级别的时间</li>
<li>-T 显示每次系统调用所花费的时间</li>
<li>-v 对于某些相关调用，把完整的环境变量，文件stat结构等打出来。</li>
<li>-f 跟踪目标进程，以及目标进程创建的所有子进程</li>
<li>-e 控制要跟踪的事件和跟踪行为,比如指定要跟踪的系统调用名称<ul>
<li>-e trace&#x3D;file   跟踪和文件访问相关的调用(参数中有文件名)</li>
<li>-e trace&#x3D;process  和进程管理相关的调用，比如fork&#x2F;exec&#x2F;exit_group</li>
<li>-e trace&#x3D;network  和网络通信相关的调用，比如socket&#x2F;sendto&#x2F;connect</li>
<li>-e trace&#x3D;signal    信号发送和处理相关，比如kill&#x2F;sigaction</li>
<li>-e trace&#x3D;desc  和文件描述符相关，比如write&#x2F;read&#x2F;select&#x2F;epoll等</li>
<li>-e trace&#x3D;ipc 进程见同学相关，比如shmget等-o 把strace的输出单独写到指定的文件</li>
</ul>
</li>
<li>-s 当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是32个字节</li>
<li>-p 指定要跟踪的进程pid, 要同时跟踪多个pid, 重复多次-p选项即可。</li>
</ul>
</li>
<li>strace 实例<ul>
<li><code>strace -tt -T -f -e trace=file -o /data/log/strace.log -s 1024 ./nginx </code> 跟踪nginx, 看其启动时都访问了哪些文件</li>
</ul>
</li>
</ul>
</li>
<li>tcpdump&#x2F;wireshark 网络数据包分析工具</li>
</ul>
</li>
<li>静态分析<ul>
<li>pyflakes<ul>
<li>当我们使用 pyflakes 分析代码的时候，我们会得到与这两处 bug 相关的错误信息。</li>
</ul>
</li>
<li>mypy</li>
<li>other code linter<ul>
<li>python<ul>
<li>pylint</li>
<li>pep8</li>
<li>bandit</li>
</ul>
</li>
<li>shell<ul>
<li>shellcheck</li>
</ul>
</li>
<li>vim<ul>
<li>ale</li>
<li>syntastic</li>
</ul>
</li>
<li>其他语言<ul>
<li><a href="https://github.com/analysis-tools-dev/static-analysis">analys-tools-dev&#x2F;static-analysis</a></li>
<li><a href="https://github.com/caramelomartins/awesome-linters">caramelomartins&#x2F;awesome-linters</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>性能分析<ul>
<li>time<ul>
<li>对于工具来说，需要区分真实时间、用户时间和系统时间。<ul>
<li>real - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I&#x2F;O或网络）；</li>
<li>user- CPU 执行用户代码所花费的时间；</li>
<li>sys - CPU 执行系统内核代码所花费的时间。</li>
</ul>
</li>
<li>time curl <a href="https://missing.csail.mit.edu/">https://missing.csail.mit.edu</a> &amp;&gt; &#x2F;dev&#x2F;null  可以看到三种时间输出</li>
</ul>
</li>
<li>性能分析工具<ul>
<li>CPU时间<ul>
<li>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具,CPU 性能分析工具有两种： 追踪分析器（tracing）及采样分析器（sampling）<ul>
<li>追踪分析器 会记录程序的每一次函数调用</li>
<li>采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。</li>
</ul>
</li>
<li>Python中的cProfile模块<ul>
<li><code>python -m cProfile -s tottime grep.py 1000 &#39;^(import|\s*def)[^,]*$&#39; *.py *  </code>分析每次函数调用所消耗的时间</li>
<li>它显示的是每次函数调用的时间，看上去可能快到反直觉，尤其是如果您在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用</li>
<li><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319162231081.png" alt="image-20230319162231081"></li>
</ul>
</li>
<li>line profiler 分析器<ul>
<li>如果我们使用 line profiler，它会基于行来显示时间</li>
<li>pip  install line_profiler_  安装kernprof工具</li>
<li>装饰您要用@profile配置文件的功能。装饰器将在运行时自动可用。</li>
<li>kernprof -l -v aaa.py  使用kernprof工具分析，逐行判断所用时间</li>
<li><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319162244327.png" alt="image-20230319162244327"></li>
</ul>
</li>
</ul>
</li>
<li>内存占用<ul>
<li>像 C 或者 C++ 这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。++为了应对内存类的 Bug，我们可以使用类似 <a href="https://valgrind.org/">Valgrind</a> 这样的工具来检查内存泄漏问题。</li>
<li>对于 Python 这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。<ul>
<li>memory-profiler<ul>
<li>python -m memory_profiler example.py _ 逐行分析所占用的内存</li>
<li><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319162251551.png" alt="image-20230319162251551"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>事件分析<ul>
<li>perf<ul>
<li><a href="http://man7.org/linux/man-pages/man1/perf.1.html">perf</a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</li>
</ul>
</li>
</ul>
</li>
<li>可视化<ul>
<li>对于<em>采样分析器</em>来说，常见的显示 CPU 分析数据的形式是 <a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪（您可以尝试点击下面的图片）。<ul>
<li><pre><code>                ![image-20230319162259009](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319162259009.png)
</code></pre>
</li>
</ul>
</li>
<li><em>调用图和控制流图</em>可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。<ul>
<li>在 Python 中您可以使用<a href="http://pycallgraph.slowchop.com/en/master/">pycallgraph</a> 来生成这些图片。</li>
<li><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319162304527.png" alt="image-20230319162304527"></li>
</ul>
</li>
</ul>
</li>
<li>资源监控<ul>
<li>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</li>
<li>通用监控<ul>
<li>htop<ul>
<li>htop 可以显示当前运行进程的多种统计信息。htop 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。</li>
</ul>
</li>
<li>glances<ul>
<li>它的实现类似但是用户界面更好。如果需要合并测量全部的进程，</li>
</ul>
</li>
<li>dstat<ul>
<li>它可以实时地计算不同子系统资源的度量数据，例如 I&#x2F;O、网络、 CPU 利用率、上下文切换等等；</li>
</ul>
</li>
</ul>
</li>
<li>I&#x2F;O<ul>
<li>iotop<ul>
<li>可以显示实时 I&#x2F;O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
</ul>
</li>
</ul>
</li>
<li>磁盘使用<ul>
<li>df<ul>
<li>可以显示每个分区的信息</li>
</ul>
</li>
<li>du<ul>
<li>显示当前目录下每个文件的磁盘使用情况</li>
</ul>
</li>
<li>ncdu<ul>
<li>是一个交互性更好的 du ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
</ul>
</li>
</ul>
</li>
<li>内存使用<ul>
<li>free<ul>
<li>可以显示系统当前空闲的内存</li>
</ul>
</li>
</ul>
</li>
<li>打开文件<ul>
<li>lsof<ul>
<li>可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用</li>
</ul>
</li>
</ul>
</li>
<li>网络链接配置 <ul>
<li>ss<ul>
<li>监控网络包的收发情况以及网络接口的显示信息，常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用ip</li>
</ul>
</li>
</ul>
</li>
<li>网络使用<ul>
<li><a href="https://github.com/raboof/nethogs">nethogs</a> 和<a href="http://www.ex-parrot.com/pdw/iftop/">iftop</a>是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
</li>
</ul>
</li>
<li>软件评估<ul>
<li>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。</li>
<li>hyperfine<ul>
<li>hyperfine可以帮您快速进行基准测试</li>
<li>hyperfine –warmup 3 ‘fd -e jpg’  ‘find . -iname “*.jpg”‘ * 测试fd与find的速度<ul>
<li><pre><code>                    ![image-20230319162312344](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319162312344.png)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h2><p><strong>我们这里说的 “元编程（metaprogramming）” 是什么意思呢？好吧，对于本文要介绍的这些内容，这是我们能够想到的最能概括它们的词。因为我们今天要讲的东西，更多是关于 流程 ，而不是写代码或更高效的工作。本节课我们会学习构建系统、代码测试以及依赖管理。</strong></p>
<p>Metaprogramming</p>
<ul>
<li>构建系统<ul>
<li>对于大多数系统来说，不论其是否包含代码，都会包含一个“构建过程”。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。</li>
<li>从本质上讲，这些工具都是非常类似的。您需要定义依赖、目标和规则。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。</li>
<li>构建工具<ul>
<li>make<ul>
<li>paper.pdf:  paper.tex plot-data.png  | pdflatex paper.tex</li>
<li>plot-%.png:  %.dat plot.py  | .&#x2F;plot.py -i  $<em>.dat -o  $@</em></li>
<li>这个文件中的指令，即如何使用右侧文件构建左侧文件的规则。或者，换句话说，冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段程序。</li>
<li>规则中的 % 是一种模式，它会匹配其左右两侧相同的字符串。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>依赖管理<ul>
<li>就您的项目来说，它的依赖可能本身也是其他的项目。您也许会依赖某些程序(例如 python)、系统包 (例如 openssl)或相关编程语言的库(例如 matplotlib)。</li>
<li>现在，大多数的依赖可以通过某些软件仓库来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如 Ubuntu 系统下面有Ubuntu软件包仓库，您可以通过 apt 这个工具来访问， RubyGems 则包含了 Ruby 的相关库，PyPi 包含了 Python 库，</li>
<li>版本控制<ul>
<li>大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个版本号。通常看上去像 8.1.3 或 64.1.20192004。版本号一般是数字构成的，但也并不绝对。</li>
<li>我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</li>
<li>不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是<a href="https://semver.org/">语义版本号</a>，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。<ul>
<li>如果新的版本没有改变 API，请将补丁号递增；</li>
<li>如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增；</li>
<li>如果您修改了 API 但是它并不向后兼容，请将主版本号递增。</li>
</ul>
</li>
<li>这么做有很多好处。现在如果我们的项目是基于您的项目构建的，那么只要最新版本的主版本号只要没变就是安全的 ，次版本号不低于之前我们使用的版本即可。换句话说，如果我依赖的版本是<code>1.3.7</code>，那么使用<code>1.3.8</code>、<code>1.6.1</code>，甚至是<code>1.3.0</code>都是可以的。如果版本号是 <code>2.2.4</code> 就不一定能用了，因为它的主版本号增加了。</li>
<li>使用依赖管理系统的时候，您可能会遇到锁文件（<em>lock files</em>）这一概念<ul>
<li>锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含 bug）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>持续集成<ul>
<li>随着您接触到的项目规模越来越大，您会发现修改代码之后还有很多额外的工作要做。您可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到 pypi，执行测试套件等等。或许您希望每次有人提交代码到 GitHub 的时候，他们的代码风格被检查过并执行过某些基准测试？如果您有这方面的需求，那么请花些时间了解一下持续集成。</li>
<li>持续集成，或者叫做 CI ，它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样 CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis CI、Azure Pipelines 和 GitHub Actions。</li>
<li>它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。</li>
</ul>
</li>
<li>测试简介<ul>
<li><ul>
<li>测试套件：所有测试的统称。</li>
</ul>
</li>
<li>单元测试：一种“微型测试”，用于对某个封装的特性进行测试。</li>
<li>集成测试：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能协同工作。</li>
<li>回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。</li>
<li>模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接” 或 “模拟硬盘”。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p><strong>我们将关注比如散列函数、密钥生成函数、对称&#x2F;非对称密码体系这些安全和密码学的概念是如何应用于前几节课所学到的工具（Git和SSH）中的。</strong></p>
<p><strong>本课程不能作为计算机系统安全 (6.858) 或者 密码学 (6.857以及6.875)的替代。 如果你不是密码学的专家，请不要试图创造或者修改加密算法。从事和计算机系统安全相关的工作同理。</strong></p>
<p><strong>这节课将对一些基本的概念进行简单（但实用）的说明。 虽然这些说明不足以让你学会如何 设计 安全系统或者加密协议，但我们希望你可以对现在使用的程序和协议有一个大概了解。</strong></p>
<p>Security</p>
<ul>
<li>熵</li>
<li><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">熵</a>度量了不确定性并可以用来决定密码的强度。</li>
<li>熵的单位是 比特。对于一个均匀分布的随机离散变量，熵等于log<em>2(n)</em> n代表所有可能的个数，比如一个骰子就是6，硬币就是2，一个六面骰子的熵为log2（6）</li>
<li>散列函数</li>
<li><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">密码散列函数</a> (Cryptographic hash function) 可以将任意大小的数据映射为一个固定大小的输出。</li>
<li><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a>可以将任意大小的输入映射为一个160比特（可被40位十六进制数表示）的输出。</li>
<li>散列函数可以被认为是一个不可逆，看上去随机，具有确定性的函数 </li>
<li>散列函数的应用<ul>
<li>Git中的内容寻址存储(Content addressed storage)</li>
<li>文件的信息摘要(Message digest)， 用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。</li>
</ul>
</li>
<li>密钥生成函数<ul>
<li>针对每个用户随机生成一个盐 salt &#x3D; random() ，并存储盐，以及密钥生成函数对连接了盐的明文密码生成的哈希值KDF(password + salt)。在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值，KDF(input + salt)，并与存储的哈希值对比。</li>
</ul>
</li>
<li>对称加密</li>
<li>对称加密中加解密所使用的密钥是相同的 </li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 是现在常用的一种对称加密系统。</li>
<li>非对称加密</li>
<li>非对称加密使用两个具有不同功能的密钥： 一个是私钥(private key)，不向外公布；另一个是公钥(public key)，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。</li>
<li>非对称加密进行加密时，使用公钥对信息进行加密，解密时再使用私钥进行解密。</li>
<li>非对称加密的签名与验证<ul>
<li>签名<ul>
<li>首先对信息进行哈希计算，得到哈希值</li>
<li>而后使用私钥对得到的哈希进行运算得到密钥</li>
<li>将签名附在信息后发送</li>
</ul>
</li>
<li>验证签名<ul>
<li>收到消息后，提取消息的签名部分</li>
<li>用公钥对消息进行运算得到哈希1</li>
<li>对消息正文进行哈希运算得到哈希2</li>
<li>比对12得出结论</li>
</ul>
</li>
<li>权威机构的签名称为证书</li>
</ul>
</li>
<li>密钥分发</li>
<li>Signal的信任模型是，信任用户第一次使用时给出的身份，同时支持用户线下面对面交换公钥</li>
<li>PGP使用的是信任网络,简单来说，如果我想加入一个信任网络，则必须让已经在信任网络中的成员对我进行线下验证，验证无误后，信任网络的成员使用私钥对我的公钥进行签名。这样我就成为了信任网络的一部分。<ul>
<li>信任网络的具体实现方式<ul>
<li>比方说，A给了我一个公钥，我信任他给我的公钥，于是将公钥加上自己的签名放入公钥串</li>
<li>当A发送一个加密消息给我时，他将消息用自己的私钥签名后，将签名附带在消息后发送</li>
<li>我收到消息，首先对签名真实性进行验证，要验证发送的消息是否A，那么我就要通过他附带的签名，因此需要A的公钥</li>
<li>我在公钥串中寻找A的公钥，找到后，通过公钥后签名验证公钥合法性后使用该公钥对附带的签名进行验证，合法则说明这个信息确实来自A</li>
</ul>
</li>
<li>GPG 加密软件<ul>
<li>具体实现方式<ul>
<li>生成公私钥</li>
<li>密钥管理<ul>
<li>列出密钥</li>
<li>删除密钥<ul>
<li>删除私钥</li>
<li>删除公钥</li>
</ul>
</li>
<li>输出密钥<ul>
<li>输出二进制密钥</li>
<li>输出ASCII密钥</li>
</ul>
</li>
<li>输入密钥<ul>
<li>从文件输入</li>
<li>从密钥服务器输入</li>
</ul>
</li>
<li>上传密钥</li>
</ul>
</li>
<li>加密与解密<ul>
<li>加密</li>
<li>解密</li>
</ul>
</li>
<li>签名<ul>
<li>对文件签名<ul>
<li>二进制签名</li>
<li>ASCII码签名</li>
<li>单独签名</li>
</ul>
</li>
<li>签名+加密</li>
<li>验证签名</li>
</ul>
</li>
</ul>
</li>
<li>实现参考<ul>
<li><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html">阮一峰的GPG教程</a></li>
<li><a href="https://blog.csdn.net/qq_33919450/article/details/115706604">GPG使用教程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://keybase.io/blog/chat-apps-softer-than-tofu">Keybase</a>主要使用社交网络证明 (social proof)，和一些别的精巧设计。</li>
<li>案例分析</li>
<li>密码管理器<ul>
<li>密码管理器会帮助你对每个网站生成随机且复杂（表现为高熵）的密码，并使用你指定的主密码配合密钥生成函数来对称加密它们。</li>
</ul>
</li>
<li>两步验证<ul>
<li><a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">两步验证</a>要求用户同时使用密码（“你知道的信息”）和一个身份验证器（“你拥有的物品”，比如<a href="https://www.yubico.com/">YubiKey</a>来消除密码泄露或者<a href="https://en.wikipedia.org/wiki/Phishing">钓鱼攻击</a>的威胁。</li>
</ul>
</li>
<li>全盘加密<ul>
<li>使用一个由密码保护的对称密钥来加密盘上的所有信息。</li>
</ul>
</li>
<li>聊天加密<ul>
<li><a href="https://signal.org/">Signal</a>和<a href="https://keybase.io/">Keybase</a>使用非对称加密对用户提供端到端(End-to-end)安全性。</li>
<li>为了保证安全性，应使用线下方式验证Signal或者Keybase的用户公钥，或者信任Keybase用户提供的社交网络证明。</li>
</ul>
</li>
<li>SSH<ul>
<li>当你运行<code>ssh-keygen</code>命令，它会生成一个非对称密钥对：公钥和私钥(public<em>key, private</em>key)。</li>
<li>公钥最终会被分发，它可以直接明文存储。 但是为了防止泄露，私钥必须加密存储。</li>
<li><code>ssh-keygen</code>命令会提示用户输入一个密码，并将它输入密钥生成函数 产生一个密钥。最终，<code>ssh-keygen</code>使用对称加密算法和这个密钥加密私钥。</li>
<li>在实际运用中，当服务器已知用户的公钥（存储在<code>.ssh/authorized_keys</code>文件中，一般在用户HOME目录下），尝试连接的客户端可以使用非对称签名来证明用户的身份——这便是<a href="https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication">挑战应答方式</a>。 简单来说，服务器选择一个随机数字发送给客户端。客户端使用用户私钥对这个数字信息签名后返回服务器。 服务器随后使用<code>.ssh/authorized_keys</code>文件中存储的用户公钥来验证返回的信息是否由所对应的私钥所签名。这种验证方式可以有效证明试图登录的用户持有所需的私钥。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="potpourri"><a href="#potpourri" class="headerlink" title="potpourri"></a>potpourri</h2><p>potpourri</p>
<ul>
<li>修改键位映射<ul>
<li><a href="https://wiki.archlinux.org/index.php/Xmodmap">Linux - xmodmap</a> 或者 <a href="https://github.com/autokey/autokey">Autokey</a></li>
<li>Windows - 控制面板，<a href="https://www.autohotkey.com/">AutoHotkey</a> 或者 <a href="https://www.randyrants.com/category/sharpkeys/">SharpKeys</a></li>
</ul>
</li>
<li>守护进程<ul>
<li>大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。</li>
<li>systemd<ul>
<li>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。</li>
<li>用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</li>
<li>如果你只是想定期运行一些程序，可以直接使用 <a href="https://www.man7.org/linux/man-pages/man8/cron.8.html">cron</a>。它是一个系统内置的，用来执行定期任务的守护进程。</li>
<li>使用了守护进程来运行一个简单的 Python 程序</li>
<li><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20230319165320134.png" alt="image-20230319165320134"></li>
</ul>
</li>
</ul>
</li>
<li>FUSE<ul>
<li><a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>（用户空间文件系统）允许运行在用户空间上的程序实现文件系统调用，并将这些调用与内核接口联系起来。</li>
<li>FUSE 可以用于实现如：一个将所有文件系统操作都使用 SSH 转发到远程主机，由远程主机处理后返回结果到本地计算机的虚拟文件系统。</li>
<li>一些FUSE文件系统<ul>
<li><a href="https://github.com/libfuse/sshfs">sshfs</a>：使用 SSH 连接在本地打开远程主机上的文件</li>
<li><a href="https://rclone.org/commands/rclone_mount/">rclone</a>：将 Dropbox、Google Drive、Amazon S3、或者 Google Cloud Storage 一类的云存储服务挂载为本地文件系统</li>
</ul>
</li>
</ul>
</li>
<li>备份<ul>
<li>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。</li>
</ul>
</li>
<li>API<ul>
<li>大多数线上服务提供的 API（应用程序接口）让你可以通过编程方式来访问这些服务的数据。</li>
<li>这些 API 大多具有类似的格式。它们的结构化 URL 通常使用 <code>api.service.com</code> 作为根路径，用户可以访问不同的子路径来访问需要调用的操作，以及添加查询参数使 API 返回符合查询参数条件的结果。</li>
<li><a href="https://ifttt.com/">IFTTT</a> 这个网站可以将很多 API 整合在一起，让某 API 发生的特定事件触发在其他 API 上执行的任务。IFTTT 的全称If This Then That 足以说明它的用法，比如在检测到用户的新推文后，自动发布在其他平台。</li>
</ul>
</li>
<li>常见命令行标志参数<ul>
<li><ul>
<li>help 帮助</li>
</ul>
</li>
<li>-i  交互式操作</li>
<li><ul>
<li>v 查看版本</li>
</ul>
</li>
<li>-vvv 查看详细版本</li>
<li>-r  递归执行</li>
<li>–   将–后出现的参数作为普通内容</li>
</ul>
</li>
<li>VPN<ul>
<li>MIT 向有访问校内资源需求的成员开放自己运营的 <a href="https://ist.mit.edu/vpn">VPN</a>。如果你也想自己配置一个 VPN，可以了解一下 <a href="https://www.wireguard.com/">WireGuard</a>Live USB 是包含了完整操作系统的闪存盘。 以及 <a href="https://github.com/trailofbits/algo">Algo</a>。</li>
</ul>
</li>
<li>Markdown</li>
<li>Live USB<ul>
<li><a href="https://en.wikipedia.org/wiki/Live_USB">Live USB</a> 是包含了完整操作系统的闪存盘。</li>
<li>Live USB 的用途<ul>
<li>作为安装操作系统的启动盘；</li>
<li>在不将操作系统安装到硬盘的情况下，直接运行 Live USB 上的操作系统；</li>
<li>对硬盘上的相同操作系统进行修复；</li>
<li>恢复硬盘上的数据。</li>
</ul>
</li>
<li>你可以使用<a href="https://unetbootin.github.io/">UNetbootin</a> 、<a href="https://github.com/pbatard/rufus">Rufus</a> 等 Live USB 写入工具制作。</li>
</ul>
</li>
<li>Docker,Vagrant,VMS<ul>
<li><a href="https://en.wikipedia.org/wiki/Virtual_machine">虚拟机</a>（Virtual Machine）以及容器化（containerization）等工具可以帮助你模拟一个包括操作系统的完整计算机系统。</li>
<li><a href="https://www.vagrantup.com/">Vagrant</a> 是一个构建和配置虚拟开发环境的工具。它支持用户在配置文件中写入比如操作系统、系统服务、需要安装的软件包等描述，然后使用 <code>vagrant up</code> 命令在各种环境（VirtualBox，KVM，Hyper-V等）中启动一个虚拟机。<a href="https://www.docker.com/">Docker</a> 是一个使用容器化概念的类似工具。</li>
<li>租用云端虚拟机可以享受以下资源的即时访问：<ul>
<li>便宜、常开、且有公共IP地址的虚拟机用来托管网站等服务</li>
<li>有大量 CPU、磁盘、内存、以及 GPU 资源的虚拟机</li>
<li>超出用户可以使用的物理主机数量的虚拟机</li>
</ul>
</li>
<li>受欢迎的 VPS 服务商有 <a href="https://aws.amazon.com/">Amazon AWS</a>，<a href="https://cloud.google.com/">Google Cloud</a>,<a href="https://azure.microsoft.com/">Microsoft Azure</a>以及<a href="https://www.digitalocean.com/">DigitalOcean</a>。</li>
</ul>
</li>
<li>交互式记事本编程<ul>
<li>现在最受欢迎的交互式记事本环境大概是 <a href="https://jupyter.org/">Jupyter</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1>]]></content>
      <categories>
        <category>Learning Record</category>
      </categories>
      <tags>
        <tag>MIT</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>My year 2022</title>
    <url>/posts/2a24d052/</url>
    <content><![CDATA[<p>就这样，二十三了.</p>
<p>这个生日过的很草率，但并不是无奈之举。</p>
<p>我故意的。</p>
<p>我也可以热热闹闹的叫上一大帮人，觥筹交错，贺词不断，但我觉得太俗套，我就想看看，一个人买蛋糕，点蜡烛，许愿，是种什么感觉。</p>
<p>体验极差。</p>
<p>我还是高估了我的饭量。</p>
<p>在连队里，每次生日我都参加了，气氛很热烈，氛围很浓厚，但是总感觉少了点什么。</p>
<p>后来才发现，少了一个人的独处时光。</p>
<p>点燃一根蜡烛，静静的思考，这种时刻弥足珍贵，闭上眼，过往历历在目，前路愈加清晰。</p>
<p>跨越年岁的重大时刻，最该陪伴你的，不是父母，不是好友，也不是情人，而是你自己。</p>
<p>呼朋引伴，把自己喝的七荤八素，不省人事，这不叫长大一岁，这叫老了一岁。</p>
<p>我觉得长大是需要思考的，而思考需要安静的环境，独处才能安静。</p>
<p>贾平凹说，生命是孤独的旅程，林清玄说，孤独是一个人的清欢，周国平说，要有敢于面对孤独的勇气。</p>
<p>都不如村上说的一句话，人与人之间的沟通和理解几乎是不可能的。任何尝试都可能是徒劳的。</p>
<p>非常直白，也非常真实，孤独是人生常态，越早理解这个道理，就越早得到自由。</p>
<p>这就是我二十三岁生日学会的道理。</p>
<p>祝自己生日快乐，喜怒哀乐一笔勾销，从此开始新的逍遥。</p>
<p><img src="https://s2.loli.net/2022/05/29/V23ceFhztY6Njg8.jpg"></p>
]]></content>
      <categories>
        <category>Article</category>
      </categories>
      <tags>
        <tag>Years</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+picgo+oss快速搭建hexo博客图床</title>
    <url>/posts/d9ee7cbb/</url>
    <content><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><blockquote>
<p>准备工作</p>
<ul>
<li>Picgo下载</li>
<li>OSS对象储存服务开通</li>
</ul>
<p>图床配置</p>
<ul>
<li>Typora配置</li>
<li>Picgo配置</li>
</ul>
<p>测试上传情况</p>
</blockquote>
<p>很长一段时间没有更新博客了，听说Typora收费了，幸好我的版本从来没更新过哈哈哈哈</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007103457780.png" alt="image-20221007103457780"></p>
<hr>
<p>但是呢，这次又遇到了一个问题，之前搭建的smms图床不能用了，怎么调试都没办法，之前崩了之后只要更新下API  key 就行了，这次怎么更新都没有用，可能是smms也开始收费了。</p>
<p>当你上传时候出现这个问题的时候，那就说明你的图床崩了。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007085519282.png" alt="image-20221007085519282"></p>
<p>打开<code>文件</code>—<code>偏好设置</code>-<code>图片</code>，我们会看到这个选项。</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007090126052.png" alt="image-20221007090126052"></p>
<p>点击<code>验证个图片上传选项</code>，验证一下图片上传。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[PicGo INFO]: Before transform</span><br><span class="line">[PicGo INFO]: Transforming...</span><br><span class="line">[PicGo INFO]: Before upload</span><br><span class="line">[PicGo INFO]: Uploading...</span><br><span class="line">[PicGo WARN]: failed</span><br><span class="line">[PicGo ERROR]: RequestError: Error: connect ECONNREFUSED 104.21.83.45:443</span><br></pre></td></tr></table></figure>

<p>恩。。确实是崩了。</p>
<p>接下来我们就利用picgo+oss搭建一个图床供typora使用。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="picgo下载"><a href="#picgo下载" class="headerlink" title="picgo下载"></a>picgo下载</h4><p>首先我们前往Github主页下载picgo最新版本  </p>
<p><a href="https://github.com/Molunerfinn/PicGo/releases">Picgo</a></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104038135.png" alt="image-20221007104038135"></p>
<p>如果不会科学上网的这里还有一个腾讯COS的下载链接</p>
<p><a href="https://picgo-1251750343.cos.ap-chengdu.myqcloud.com/2.3.1-beta.6/PicGo-2.3.1-beta.6.AppImage">Picgo-TecentCOS</a></p>
<p>下载好之后执行以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod a+x PicGo-2.3.1-beta.6.AppImage   #权限</span><br><span class="line">sudo mv PicGo-2.3.1-beta.6.AppImage picgo#重命名</span><br><span class="line">sudo mv picgo /usr/bin #该目录已包含于环境变量，可直接通过picgo指令打开</span><br></pre></td></tr></table></figure>



<p>打开之后它是这样的</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104113254.png" alt="image-20221007104113254"></p>
<p>你得右键打开主界面</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104134513.png" alt="image-20221007104134513"></p>
<h4 id="OSS云对象储存服务"><a href="#OSS云对象储存服务" class="headerlink" title="OSS云对象储存服务"></a>OSS云对象储存服务</h4><p><strong>打开阿里云</strong> </p>
<p><strong>搜索对象储存oss</strong></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104246741.png" alt="image-20221007104246741"></p>
<p><strong>切换至概况一栏</strong></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104334529.png" alt="image-20221007104334529"></p>
<p><strong>点击建立bucket</strong></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104441930.png" alt="image-20221007104441930"></p>
<p><strong># 上图源自CSDN，本人懒</strong></p>
<p><strong>切换至bucket概览，记录下你的地域节点</strong> </p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104523311.png" alt="image-20221007104523311">我这里是广州，所以是<code>oss-cn-guangzhou</code></p>
<p><strong>右上角点击你的头像选择AccessKey管理</strong></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104545235.png" alt="image-20221007104545235"></p>
<p>这个不用管他，继续使用</p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101544965.png" alt="image-20221007101544965"></p>
<p><strong>创建一个新的Access key，然后记住你的ID和Secret</strong></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101612928.png" alt="image-20221007101612928"></p>
<p>到这里oss服务就配置完成了，接下来我们就可以开始在本级搭建图床了。</p>
<h3 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h3><h4 id="Picgo配置"><a href="#Picgo配置" class="headerlink" title="Picgo配置"></a>Picgo配置</h4><p><strong>打开picgo主界面，点击<code>图床设置 </code>- <code>阿里云oss</code></strong></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102114993.png" alt="image-20221007102114993"></p>
<p>这里的keyID和keySecret填写刚才我们建立AccessKey时候得到的两串代码，Bucket填写你建立的bucket名字，储存区域就填写刚才的地域节点，储存路径这个，随便写一个就行了。</p>
<h4 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h4><p>同样，打开<code>文件</code>-<code>偏好设置</code>-<code>图片</code></p>
<p><img src="https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102515260.png" alt="image-20221007102515260"></p>
<p>将上传服务由Picgo-commandline改为Picgo-app，而后Picgo路径填写我们刚刚移动Picgo</p>
<p>到达的位置<code>/usr/bin/picgo</code></p>
<h3 id="测试上传情况"><a href="#测试上传情况" class="headerlink" title="测试上传情况"></a>测试上传情况</h3><p>点击验证图片上传情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&quot;success&quot;:true,&quot;result&quot;:[&quot;https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/typora-icon2.png&quot;,&quot;https://xxx.oss-cn-guangzhou.aliyuncs.com/image/typora-icon.png&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>成功。</p>
]]></content>
      <categories>
        <category>Talk</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
        <tag>typora</tag>
        <tag>picgo</tag>
        <tag>oss</tag>
      </tags>
  </entry>
</search>

{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/ava.png","path":"images/ava.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/images/2.jpg","path":"images/2.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/ava.png","path":"img/ava.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper.png","path":"img/wallpaper.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/cover.jpg","path":"img/cover.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1617889988055},{"_id":"source/about/index.md","hash":"7ea39ed8ae19c939ba024324aca0e391f09fd227","modified":1618144311771},{"_id":"source/categories/index.md","hash":"637d2ca2726b44010ef1bfb9fab385792186e7ed","modified":1617974439394},{"_id":"source/tags/index.md","hash":"c1eaabb9c409522002878de508a7821b61d8204b","modified":1617974314526},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1617893543795},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1617893543795},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1617893543795},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1617893543799},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1617893543799},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1617893543799},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1617893543799},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1617893543799},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1617893543799},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1617893543799},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1617893543803},{"_id":"themes/next/_config.yml","hash":"fbc1381a9358e4cdf29b8b7dcbb53a7a9a0ecd2c","modified":1653790924824},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1617893543795},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1617893543799},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1617893543795},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1617893543799},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1617893543799},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1617893543799},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1617893543799},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1617893543799},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1617893543799},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1617893543799},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1617893543799},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1617893543799},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1617893543799},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1617893543799},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1617893543799},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1617893543799},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1617893543799},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1617893543799},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1617893543799},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1617893543799},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1617893543799},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1617893543799},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1617893543799},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1617893543799},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1617893543799},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1617893543799},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1617893543799},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1617893543799},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1617893543799},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1617893543799},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1617893543799},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1617893543799},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1617893543799},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1617893543799},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1617893543799},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1617893543799},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1617893543799},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1617893543799},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1617893543803},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1617893543803},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1617893543803},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1617893543803},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1617893543803},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1617893543803},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1617893543803},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1617893543803},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1617893543803},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1617893543803},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1617893543803},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1617893543803},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1617893543799},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1617893543799},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1617893543799},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1617893543799},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1617893543799},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1617893543799},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1617893543799},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1617893543799},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1617893543799},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1617893543803},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1617893543799},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1617893543803},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1617893543803},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1617893543803},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1617893543803},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1617893543803},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1617893543803},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1617893543803},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1617893543803},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1617893543803},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1617893543803},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1617893543803},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1617893543803},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1617893543803},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1617893543803},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1617893543803},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1617893543803},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1617893543803},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1617893543803},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1617893543803},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1617893543803},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1617893543803},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1617893543803},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1617893543803},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1617893543803},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1617893543803},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1617893543803},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1617893543803},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1617893543803},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1617893543803},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1617893543803},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1617893543803},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1617893543803},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1617893543803},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1617893543803},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1617893543803},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1617893543803},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1617893543803},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1617893543807},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1617893543807},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1617893543807},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1617893543807},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1617893543807},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1617893543807},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1617893543807},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1617893543807},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1617893543807},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1617893543807},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1617893543807},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1617893543807},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1617893543807},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1617893543807},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1617893543807},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1617893543807},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1617893543807},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1617893543807},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1617893543807},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1617893543807},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1617893543807},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1617893543803},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1617893543807},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1617893543803},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1617893543803},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1617893543803},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1617893543803},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1617893543803},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1617893543803},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1617893543803},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1617893543803},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1617893543803},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1617893543803},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1617893543803},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1617893543803},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1617893543803},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1617893543803},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1617893543803},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1617893543803},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1617893543803},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1617893543803},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1617893543803},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1617893543803},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1617893543803},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1617893543803},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1617893543803},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1617893543803},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1617893543803},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1617893543803},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1617893543803},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1617893543803},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1617893543803},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1617893543803},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1617893543803},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1617893543803},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1617893543803},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1617893543803},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1617893543803},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1617893543803},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1617893543803},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1617893543803},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1617893543803},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1617893543803},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1617893543803},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1617893543803},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1617893543803},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1617893543803},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1617893543803},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1617893543803},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1617893543803},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1617893543803},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1617893543803},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1617893543803},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1617893543803},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1617893543807},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1617893543807},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1617893543807},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1617893543807},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1617893543807},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1617893543807},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1617893543807},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1617893543811},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1617893543807},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1617893543811},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1617893543807},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1617893543811},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1617893543811},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1617893543803},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1617893543803},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1617893543807},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1617893543807},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1617893543807},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1617893543807},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1617893543807},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1617893543811},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1617893543811},{"_id":"themes/next/source/images/ava.png","hash":"257ad54bca4093d2fa03db10fc49739bc1478f3d","modified":1617960617490},{"_id":"public/atom.xml","hash":"b70f5b1ce179be4e685bf501b2ec64102cc84712","modified":1676117628059},{"_id":"public/search.xml","hash":"c88aee2bd59931df11ecf171e52ff678cef98a8d","modified":1676117628059},{"_id":"public/about/index.html","hash":"213bc40d867649cd87377d5ce840168539de6cb6","modified":1618144323473},{"_id":"public/tags/index.html","hash":"35bafcd74ff230b6b1343c4986a17e592daeec32","modified":1676117628059},{"_id":"public/categories/index.html","hash":"d831f664b679db033a316500ec13df0515d31414","modified":1676117628059},{"_id":"public/archives/index.html","hash":"630688aa22bf16a99c29882d4386b2594f416247","modified":1676117628059},{"_id":"public/archives/2021/index.html","hash":"eab49c75adb7711eecd713fe54fe4ddf9f445e8a","modified":1676117628059},{"_id":"public/archives/2021/04/index.html","hash":"4752b9f6b87b60d45cc0170f4b99ec5f17fe7ef8","modified":1676117628059},{"_id":"public/2021/04/08/hello-world/index.html","hash":"0d155769184a42f2dd0fc50a757d8cd601e84a02","modified":1618138638842},{"_id":"public/index.html","hash":"54c80bef3b034e65ad8aecffda083daaaf3701bc","modified":1676117628059},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1617975403674},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1617975403674},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1617975403674},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1617975403674},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1617975403674},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1617975403674},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1617975403674},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1617975403674},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1617975403674},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1617975403674},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1617975403674},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1617975403674},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1617975403674},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1617975403674},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1617975403674},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1617975403674},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1617975403674},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1617975403674},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1617975403674},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1617975403674},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1653792334539},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1617975403674},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1617975403674},{"_id":"public/css/main.css","hash":"0f40195a94c1b88b465cbf10edbdb443e77721f2","modified":1617975403674},{"_id":"public/images/ava.png","hash":"257ad54bca4093d2fa03db10fc49739bc1478f3d","modified":1617975403674},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1617975403674},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1617975403674},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1617975403674},{"_id":"source/_posts/Python学习之路.md","hash":"9b1e7efe4c0741c0864bd456fb6051b323ef6c9a","modified":1620040970362},{"_id":"source/_posts/沉思录.md","hash":"d118fc2fc0ed178f47699ca26bc7a160ecfd01f4","modified":1618012753879},{"_id":"source/_posts/22计算机考研综述.md","hash":"bbe0a877558eb62db0bbc748f6a92179747f8906","modified":1618014003979},{"_id":"source/_posts/计算机考研综述.md","hash":"6aea02950d953032e92bde9ff71d618b763fd337","modified":1618014085283},{"_id":"source/_posts/Linux文件管理与权限控制.md","hash":"0b48066c2f52d829b722413b04b900a9b4457108","modified":1618147630826},{"_id":"source/_posts/世界很大，人心很小.md","hash":"aebaac7b4424082fcb211df680dde2e8ed7c99e8","modified":1630643934437},{"_id":"public/2021/04/10/世界很大，人心很小/index.html","hash":"c303895d585e3d7de8eabfc5cb5a8bf81b981f70","modified":1630643938796},{"_id":"public/2021/04/10/计算机考研综述/index.html","hash":"1e31967850186e6ed5b0194983ae6ecfa0fd4874","modified":1653802872660},{"_id":"public/2021/04/10/Python学习之路/index.html","hash":"35d4dc41ece406bec34b76ca1f09f2350f3bb263","modified":1653802872660},{"_id":"public/categories/编程语言/index.html","hash":"caf09b7e3dd1c5f38afb2d73aae64ff1a18bebf4","modified":1619020254917},{"_id":"public/categories/考研之路/index.html","hash":"b29921d89f15e0f06e4b929f01d556d47f2b04d9","modified":1654527738285},{"_id":"public/categories/Linux/index.html","hash":"688775641ea7e9ea7f9a633f1a84d2c8ba20a234","modified":1676075906532},{"_id":"public/categories/沉思录/index.html","hash":"6349e0280afffd7807cbd473e06b7f140b345f89","modified":1628670789282},{"_id":"public/tags/Python/index.html","hash":"9219dab2a9c58d670518ad49df22a9e5d27201fb","modified":1653803085060},{"_id":"public/tags/研招信息/index.html","hash":"304dd8edd452f20f42cd794526be812b248f2961","modified":1653803085060},{"_id":"public/tags/Linux/index.html","hash":"228f905ee97b14a6dabb0bfb3dbce2aee4550f16","modified":1676117628059},{"_id":"public/tags/权限控制/index.html","hash":"d5a42b32aed2280ce4c3662378653c1d4ccc4b43","modified":1653803085060},{"_id":"public/tags/沉思录/index.html","hash":"4e7dbba5e52800a16a945128ad9bed91726574e4","modified":1630643938796},{"_id":"public/2021/04/10/Linux文件管理与权限控制/index.html","hash":"c7882bbf1763ab3bea5cbdf42c466f2e114241a1","modified":1653802872660},{"_id":"source/_posts/Markdown指南.md","hash":"40bbe60eb3c1851cabe24a08648b18f84d34d742","modified":1676114292089},{"_id":"public/2021/04/11/Markdown指南/index.html","hash":"0226d8a006ab02653d1e450e0a52214330a2f978","modified":1676115863637},{"_id":"public/tags/Markdown/index.html","hash":"5656919d6771e39da618e3b628c4a1ecc7c34a44","modified":1676117628059},{"_id":"source/About/index.md","hash":"f74ec2de025b83c5026324effe7cc767ea3d0910","modified":1676117150400},{"_id":"public/About/index.html","hash":"c62c6d6493cea2ff5a287acef0c04abb77e7d896","modified":1676117628059},{"_id":"themes/next/source/images/2.jpg","hash":"470deb5d0a816a685b67360280927cf76143c083","modified":1618142375621},{"_id":"public/images/2.jpg","hash":"470deb5d0a816a685b67360280927cf76143c083","modified":1618144708335},{"_id":"public/categories/软件文档/index.html","hash":"f55153584e8f3fe6733709b9bdd739c28b9d6548","modified":1665055092677},{"_id":"source/_posts/CS自学路线与课程推荐.md","hash":"aa586748e5fd994c4fde95a96d9bec924f870ed0","modified":1676114232793},{"_id":"public/2021/04/13/CS自学路线与课程推荐/index.html","hash":"e21138fc43d32ef17851c78f62b3c101e9c7f062","modified":1676115863637},{"_id":"public/tags/学习路线/index.html","hash":"0e10a10a986b44e624c65b601fe1d5d9432e428e","modified":1676117628059},{"_id":"public/tags/计算机课程/index.html","hash":"01d3d514b40a2dc63cfb2b586a1163bbe613bd28","modified":1676117628059},{"_id":"source/_posts/美食地图.md","hash":"4112fbab9600aa5cbc98203a007dcc4fb2dadd48","modified":1618373397594},{"_id":"public/2021/04/14/美食地图/index.html","hash":"d4141edc4a34785015c1b5863f417ac662550e50","modified":1622173505299},{"_id":"public/tags/好吃的/index.html","hash":"cd7f36c55b9d6d62fa15e6d0767f1266124d4e3e","modified":1622173505299},{"_id":"public/categories/美食与生活/index.html","hash":"fad58d9f33dc848bebce977ea2db2abd160a4fe9","modified":1622173505299},{"_id":"source/_posts/我走的路和高山的雪.md","hash":"c855846b07898ad231adc529b534b49beb9dd5dd","modified":1618556154277},{"_id":"public/2021/04/16/我走的路和高山的雪/index.html","hash":"6b460663b5ba0ea5e625813a4377bab21747d27f","modified":1628670789282},{"_id":"public/tags/人生/index.html","hash":"7599638786901fa02629ef7020ef3f86e5a36452","modified":1628670789282},{"_id":"source/_posts/清川录.md","hash":"a3925fb17da55423f384499634f0e6f8c1101ba0","modified":1618762460123},{"_id":"public/2021/04/18/清川录/index.html","hash":"e6fb6075a8e1ca58efb97f504832f4ac9b0f8588","modified":1618762466497},{"_id":"public/tags/纪传/index.html","hash":"bde6ea145073c2e31fca4700d03bf5cdfb27f4ee","modified":1618762466497},{"_id":"source/_posts/简明Git使用方法.md","hash":"bd6e13efc6a5646cd9e5298d8c4f9769b3fa7940","modified":1676115677175},{"_id":"source/_posts/CS61A综述.md","hash":"bb29c7d878fb378fa291f65cef80ab25f866297a","modified":1622173664452},{"_id":"source/_posts/Python数据分析精要.md","hash":"5851433316a593c755ff61b1efe0172af3f8bb8c","modified":1621853581803},{"_id":"source/_posts/Python爬虫精要.md","hash":"1e1729a0a06994d58391e885393493473c3bb105","modified":1621853546035},{"_id":"public/2021/05/24/Python数据分析精要/index.html","hash":"251310161850c849eab54079c2d8f48a70ce610b","modified":1653804177835},{"_id":"public/2021/05/24/Python爬虫精要/index.html","hash":"d06ff6b5d467f7625c72137e86f56086857fd0cb","modified":1653802872660},{"_id":"public/archives/2021/05/index.html","hash":"2aa4940e1973793b08295e5e69743228f2f6eb1d","modified":1676117628059},{"_id":"public/categories/Python/index.html","hash":"5357ac2fc9ee0f7794096b6f429d3fec6383121f","modified":1653803085060},{"_id":"public/archives/page/2/index.html","hash":"fea9bffc0702b34d613fa4e39a480a32eadd5c3c","modified":1676117628059},{"_id":"public/archives/2021/page/2/index.html","hash":"911f76122bd6a5f46707d3193e9232b62d9534a6","modified":1676075906532},{"_id":"public/page/2/index.html","hash":"012bb428dbb42c24eabefce8171d1a7b5f776ce7","modified":1676117628059},{"_id":"public/2021/05/27/简明Git使用方法/index.html","hash":"40228a9ab5b54e8f596e42f1658ac51e3c2fa164","modified":1676115863637},{"_id":"public/tags/Git/index.html","hash":"00e77cd207668903d6fbdb444a9c1515bb07358b","modified":1676117628059},{"_id":"source/_posts/CS61A-过程抽象.md","hash":"bbff49ad45bed24e952b28bd5edda277b382132e","modified":1676114211224},{"_id":"source/_posts/CS61A-综述.md","hash":"2811d09e7cf27db0c862ae104e10683a4c7293ed","modified":1676114194783},{"_id":"public/archives/2021/06/index.html","hash":"4b58c83930ab0d5474a67ff8a4d34d3f1b7bb1e6","modified":1676117628059},{"_id":"public/categories/UCB-CS61x/index.html","hash":"183a56c4211c81ebfcaf909f05b05a731f9698da","modified":1623681074088},{"_id":"public/tags/程序结构/index.html","hash":"e7a2e0e6f9248de96c47716f7883c583b9052fd9","modified":1676117628059},{"_id":"public/tags/CS61/index.html","hash":"1202efb477208cbe92b5a58c94ab0ee77674bac5","modified":1676117628059},{"_id":"public/tags/CS61A/index.html","hash":"e2ff9e3a3b8c5e89539814b4813faa5b3a6ad4a8","modified":1676117628059},{"_id":"public/2021/06/12/CS61A-过程抽象/index.html","hash":"78b7babe0df46b2e0b4499c55ef6832349d37cd7","modified":1676115863637},{"_id":"public/categories/CS61x/index.html","hash":"e1be0a70a704f95eef2875c986607b458d2893b7","modified":1625040722964},{"_id":"public/2021/06/12/CS61A-综述/index.html","hash":"8f0ab8a419298611c39e09a0fc7ef2daa9142018","modified":1676115863637},{"_id":"source/_posts/CS61A-数据抽象.md","hash":"558db81557698d43c02357affa0a8bd68e29b2f1","modified":1676114182749},{"_id":"public/2021/06/28/CS61A-数据抽象/index.html","hash":"3b174ccc88d53a843c7a9d62687d808e94735e2d","modified":1676115863637},{"_id":"source/_posts/CS61A-对象抽象.md","hash":"19d2a08d3d04d9fb5cd74d0dbbaaac6608d64b1d","modified":1676114154827},{"_id":"source/_posts/CS61A-流与声明式编程.md","hash":"f5079749fbae2a00bace0ab67ac1599ba55edf9b","modified":1628409579275},{"_id":"source/_posts/CS61A-元语言抽象.md","hash":"b074eb3fcf247964c4d39853f4699f0228beb2a0","modified":1676114116031},{"_id":"public/2021/08/08/CS61A-流与声明式编程/index.html","hash":"3cce1018d445d2ff2c663e959ad6622859dfebd8","modified":1628494991184},{"_id":"public/2021/08/08/CS61A-元语言抽象/index.html","hash":"3a12eb8e8c0f8b4c7120516744e3ee2ba911080f","modified":1676115863637},{"_id":"public/2021/08/08/CS61A-对象抽象/index.html","hash":"eb1aad801623fe86fa2e3148ee6c10f1c7662925","modified":1676115863637},{"_id":"public/archives/2021/08/index.html","hash":"cb3dce5f069b4927366b0c8fe691b591d651905f","modified":1676117628059},{"_id":"public/categories/CS61A/index.html","hash":"1a81960441fab41fbe76612a3aec4d385aed2a1a","modified":1653804177835},{"_id":"source/_posts/My-year-2021.md","hash":"a3a93f5788fde29f5220a698b833624ce3e2e426","modified":1653803404554},{"_id":"public/2021/09/03/My-year-2021/index.html","hash":"f45d3e304038615488955c1c7ca3e1b999a54277","modified":1653803432729},{"_id":"public/archives/2021/09/index.html","hash":"17a1e6db6f1defd0fc15fc29c41680db16fb2425","modified":1676117628059},{"_id":"public/categories/My-year/index.html","hash":"227cab22fcf4471568fb58abededfeb12922438b","modified":1654527738285},{"_id":"public/tags/Years/index.html","hash":"0c9f53afe943277bf000692926f4968539e8b7cc","modified":1676117628059},{"_id":"source/_posts/CS61B-Java.md","hash":"77d4be608dc439d04c136694b568142259e69df3","modified":1665056173297},{"_id":"source/_posts/CS61B-综述.md","hash":"2efb932b44733809ac749ddd81e8289674f45d02","modified":1665056181017},{"_id":"source/_posts/CS61B-算法.md","hash":"08b6d4d879abe455f52ec4230ce180e2205729c0","modified":1653802854633},{"_id":"source/_posts/CS61B-数据结构.md","hash":"1199fb767f81cb1ad4135be437436b9001ed24c4","modified":1630730913432},{"_id":"public/2021/09/04/CS61B-算法/index.html","hash":"8a4f90adb663ca73c1294c790772d4e80ee791ab","modified":1653802872660},{"_id":"public/2021/09/04/CS61B-数据结构/index.html","hash":"3884757a3279c00fddace5b19b51965db1f901d8","modified":1653802872660},{"_id":"public/categories/CS61B/index.html","hash":"bcb4f3146d003472c96a22cb5487dfe99bf11153","modified":1653804177835},{"_id":"public/tags/Java/index.html","hash":"20ad755bc4037a4277f15d5dcd2c668048bf6edc","modified":1676075906532},{"_id":"public/tags/CS61B/index.html","hash":"24d9fbbe8c92b43e542c04617926d84ef804d9dd","modified":1676075906532},{"_id":"public/2021/09/04/CS61B-综述/index.html","hash":"72585a873cde40dcbd0440f82cfebdd500542879","modified":1676074446604},{"_id":"public/2021/09/04/CS61B-Java/index.html","hash":"49935a939a93d2e2467340add603e2254e5be0eb","modified":1676074446604},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1653792200536},{"_id":"themes/butterfly/README.md","hash":"66b4889591d0f36696c4d363412c753b6fe25519","modified":1653792200536},{"_id":"themes/butterfly/README_CN.md","hash":"08afd014fd27019909f341a2ad6162665958c6d6","modified":1653792200536},{"_id":"themes/butterfly/_config.yml","hash":"4b2ca092b98f4018fc9a1d94e4923826f2f41287","modified":1653802277293},{"_id":"themes/butterfly/package.json","hash":"3dc93d95cd757271bbbdfa1d62d96cba021bb897","modified":1653792200540},{"_id":"themes/butterfly/.github/stale.yml","hash":"5e8ea535424e8112439135d21afc5262c0bc0b39","modified":1653792200536},{"_id":"themes/butterfly/languages/default.yml","hash":"1e37a3695d50e3e61d7c36e58a6dac872a4a56cd","modified":1653792200536},{"_id":"themes/butterfly/languages/en.yml","hash":"d1bb560698eb8b0079495b7b18b44facb610f9fd","modified":1653792200536},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"28b6f0c39155651d747eb595e0a283bc97be2e09","modified":1653792200536},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"947f794e862bb2813e36887f777bdb760f70a322","modified":1653792200536},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1653792200536},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1653792200536},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1653792200540},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1653792200540},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1653792200540},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1653792200540},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"67e4f5a66d4b8cabadbaad0410628364ee75e0ae","modified":1653792200536},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1653792200536},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1653792200536},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"594a977ebe8d97e60fa3d7cb40fc260ded4d8a58","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"54511ed299a3bcf4ecbb62e3078f6b0611ccbd2c","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"da27c20f0e672103b984e135eb2fe7770ca7fcce","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1653792200536},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1653792200540},{"_id":"themes/butterfly/scripts/events/config.js","hash":"a12b9f11d7d3f52de5b2090d2805d7303e0187a5","modified":1653792200540},{"_id":"themes/butterfly/scripts/events/init.js","hash":"b4940a5c73d3a5cd8bb5883e3041ecdd905a74e0","modified":1653792200540},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1653792200540},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1653792200540},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1653792200540},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1653792200540},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1653792200540},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1653792200540},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b4cd617c619d1a0df93603721a6fa1317526174b","modified":1653792200540},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1653792200540},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"d368a8830e506c8b5eb6512b709ec8db354d5ea1","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1653792200540},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1653792200540},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1653792200544},{"_id":"themes/butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1653792200544},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1653792200544},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1653792200544},{"_id":"themes/butterfly/source/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1653792200544},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1653792200544},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1653792200544},{"_id":"themes/butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1653792200544},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"8f41fa9732ea654a10f6e666d9c782c7e27e5ea6","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"19a05dccfbffdf31cfa48c3208542b924637303d","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"b9ebb02af8ccf43e3f73be43db19254fa913c57b","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"460c37caeed6e6e72c1e62292e6c5e9699dd5937","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"bae2f32ac96cebef600c1e37eaa8467c9a7e5d92","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1653792200540},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"644d520fe80cc82058467708ab82ccad313b0c27","modified":1653792200540},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"ca58af8903eb1d1d05edae54fc2e23aeac6da6c5","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"15056fba0bd5a45ea8dc97eb557f6929ff16797a","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1653792200540},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"8314e9749eb1ae40c4bae9735b7a6638b2d6876a","modified":1653792200540},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"f67177310f5594954b25a591d186d28d5d450b18","modified":1653792200540},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"826dae759062d8f84eb2bf5ab8fdb80e0f79d58b","modified":1653792200540},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1653792200540},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"51e45625929d57c9df3ba9090af99b9b7bb9a15b","modified":1653792200544},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1653792200544},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"25e58a7a8bda4b73d0a0e551643ca01b09ccd7e5","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"08493b66b9f31f2bd3e9a3115017a0ce16142b20","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1653792200544},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1653792200544},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1653792200544},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1653792200544},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1653792200544},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"e4b7bf91a29bd03181593b63e1f3ee1103af2e48","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"5f648086a33a32d169a2f8d8c549c08aa02f67db","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1653792200536},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"693d999777dd16e0566d29ac3203d4c167b2f9a7","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"2d8fc3fb8f9aec61400acf3c94070bd8539058f8","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"22e2ef30fe5eb1db7566e89943c74ece029b2a8e","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"e4850f2c9ba5f6b2248808f7257662679e0fab0a","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"9302837f1e35f153323bb4f166514c7e96e8ecdd","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"81c6070e06ecc2244040c7007566d7972f46ec4e","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"15462d1ed04651ad3b430c682842ac400f6f9b47","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"31b007dc0f3de52176f278012ecf17a4bcecde2c","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"f4dc7d02c8192979404ae9e134c5048d3d0a76e2","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"dd0bc119029b62dce5dc965d5de7377e438fa29a","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1653792200540},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1653792200540},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1653792200540},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1653792334539},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1653792334539},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1653792334539},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653792334539},{"_id":"public/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1653792334539},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1653792334539},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1653792334539},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1653792334539},{"_id":"public/css/index.css","hash":"61551503130fa9c41cbee888625cc4e871316999","modified":1653792334539},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1653792334539},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1653792334539},{"_id":"themes/butterfly/source/img/ava.png","hash":"257ad54bca4093d2fa03db10fc49739bc1478f3d","modified":1617960617490},{"_id":"themes/butterfly/source/img/Firefox_wallpaper.png","hash":"da0ce02cb372db09b4852ceff19fd5ea2bdb8573","modified":1618118240675},{"_id":"public/img/ava.png","hash":"257ad54bca4093d2fa03db10fc49739bc1478f3d","modified":1653794489621},{"_id":"public/img/Firefox_wallpaper.png","hash":"da0ce02cb372db09b4852ceff19fd5ea2bdb8573","modified":1653794489621},{"_id":"themes/butterfly/source/img/wallpaper.png","hash":"da0ce02cb372db09b4852ceff19fd5ea2bdb8573","modified":1618118240675},{"_id":"public/img/wallpaper.png","hash":"da0ce02cb372db09b4852ceff19fd5ea2bdb8573","modified":1653794828462},{"_id":"themes/butterfly/source/img/cover.jpg","hash":"71b7417b667ceb44c5faa43bd35b4eec35dcc618","modified":1618141884212},{"_id":"public/img/cover.jpg","hash":"71b7417b667ceb44c5faa43bd35b4eec35dcc618","modified":1653800899914},{"_id":"source/books/Markdown指南.md","hash":"9aec619a86988af8bda071760a52d8ef0b705969","modified":1618147613434},{"_id":"source/books/My-year-2021.md","hash":"e44401ebcd6d70a2b189f8bae451ef47f5ef0118","modified":1630644178106},{"_id":"public/books/Markdown指南.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653801193568},{"_id":"public/books/My-year-2021.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653801193568},{"_id":"source/_posts/My-year-2022.md","hash":"c76edff11930d79c026c2bb6662665584c30b921","modified":1676114303452},{"_id":"public/2021/09/03/My-year-2022/index.html","hash":"836d4fdcd25b791a5e16d0bb53f5fa9a35ed14c9","modified":1676115863637},{"_id":"source/_posts/后来的我们.md","hash":"151a72c088d4990d508754b51705c7738a284ca3","modified":1665056258653},{"_id":"public/2022/06/05/后来的我们/index.html","hash":"fbf7ea17071b6770a165eefdeddd989cf78e2c44","modified":1676115863637},{"_id":"public/categories/CS61/index.html","hash":"7f8293884ab01258ab055c48076e0f1819a1f44f","modified":1664287376664},{"_id":"public/categories/沧海巫山/index.html","hash":"4c6f86da88b64d7f7f464ebf3fb70c536aa3c8ad","modified":1654527738285},{"_id":"public/archives/2022/index.html","hash":"63c43519879a8a14b427e39bce1b0049f81cd730","modified":1676117628059},{"_id":"public/archives/2022/06/index.html","hash":"28287c91d220c0b774c9c2bc86574e23fee0888d","modified":1676117628059},{"_id":"public/tags/故事/index.html","hash":"7afbfadd7049f040358a2b1a5e596bae12d5e3f7","modified":1676117628059},{"_id":"public/tags/文章/index.html","hash":"cdb5576c562f8fb710d2b645029491ef7bd9958a","modified":1676117628059},{"_id":"source/link/index.md","hash":"f7c0a279692bdf2588c9d8de74c8f4218f0d1ea7","modified":1654430391162},{"_id":"public/link/index.html","hash":"a904aaecbea2281cbae09403e1013a4ed2c5eb40","modified":1676117628059},{"_id":"source/_data/link.yml","hash":"f6bbaa75c022fb227f51da0d0da90936bbcdd373","modified":1654437626749},{"_id":"source/_posts/如果世界有尽头.md","hash":"dcafafeccdaf0827c7133cc884fa4564c807accc","modified":1665056289208},{"_id":"public/2022/06/06/如果世界有尽头/index.html","hash":"eb37324a73be06e7a8c1f48b59cfd261beb1c074","modified":1676115863637},{"_id":"public/categories/清川文集/index.html","hash":"6faa85d7b2ae4b0ebf5bcb0dbe3527f07cb71e72","modified":1654527738285},{"_id":"source/_posts/Missing-Semester-Shell.md","hash":"94f975b7f810c401676d725958736f6816c85f54","modified":1664281942571},{"_id":"public/2022/09/27/Missing-Semester-Shell/index.html","hash":"fbaea6e8e12103f62ef6b0e28c0aa29225c632c8","modified":1664287439521},{"_id":"public/archives/2022/09/index.html","hash":"56ba4727d4af9ccbd6edbb03a115cef27a2d4260","modified":1664287439521},{"_id":"public/categories/程序结构/index.html","hash":"73b0dd6607237ccaf8e4c5b2b3ce969b1b7911d3","modified":1664287439521},{"_id":"public/categories/数据结构与算法/index.html","hash":"499dc76009ec31f4a8c0d396158082cb7c9e767c","modified":1664287439521},{"_id":"public/categories/学习路线/index.html","hash":"ef43965bcbf8cf1f2dcee3bbf8e6a51ea170144f","modified":1665055092677},{"_id":"public/categories/年之纪/index.html","hash":"d83b6597ad2e5e9eeb6351604c64868341736c6e","modified":1665055092677},{"_id":"public/categories/云中浮浪/index.html","hash":"5ec42496d2d1c61e53570cd22aef413b8a1d7bb9","modified":1665055092677},{"_id":"source/_posts/MSe-Shell-Bsh与命令行编程.md","hash":"e9f913fa6afead39a51fbb0dbebc3a5904214485","modified":1664971660949},{"_id":"source/_posts/Missing-Semaster-命令行与脚本.md","hash":"ad1a639177fe8ac0fd2e4d2109f3dfcd4d64ac4e","modified":1665056453983},{"_id":"source/_posts/Missing-Semaster-综述.md","hash":"a3626b858f2aaa0d882599988d417075a64f0ea0","modified":1665056200017},{"_id":"source/_posts/MSe_Shell-Linux操作系统.md","hash":"7edc6f53e485233a41d8a3e218c794eaab532cb5","modified":1664971571047},{"_id":"public/2022/10/05/Missing-Semaster-命令行与脚本/index.html","hash":"8922d32d9efc31793297410d3f25599ac635e8ab","modified":1676074446604},{"_id":"public/2022/10/05/MSe-Shell-Bsh与命令行编程/index.html","hash":"3d981900d977d408b92f05904444202d2f382a38","modified":1664979088697},{"_id":"public/2022/10/05/MSe_Shell-Linux操作系统/index.html","hash":"800cf2e16c17ad4e43ed6a9e20f3da05f1486b6a","modified":1664979088697},{"_id":"public/2022/10/05/Missing-Semaster-综述/index.html","hash":"7d89db5b2ffbb47870a010ffdda89852ba460fa5","modified":1676074446604},{"_id":"public/archives/2022/10/index.html","hash":"3cbe209d7f3246318c3863468adcc547bdb81698","modified":1676117628059},{"_id":"public/categories/学习进度/index.html","hash":"156056f9629e3abfdc0e19207ff04502587dd8b5","modified":1665056304989},{"_id":"public/tags/MIT/index.html","hash":"faac27128ac6899569e06290422b87edffd77764","modified":1676075906532},{"_id":"public/tags/MissingSemaster/index.html","hash":"f64588d82afc25f78d23e31d612042587591d569","modified":1676075906532},{"_id":"public/tags/编程素养/index.html","hash":"ae7f1c1bdec610bba4904e9d00432b06ffd0743f","modified":1676075906532},{"_id":"themes/butterfly/._config.yml.swp","hash":"99d51930a22c6d8d330acd8dbad50fed629bdf2b","modified":1664979545456},{"_id":"themes/butterfly/._config.yml.swo","hash":"e814b1e506555cf3d105387113f9570e2a335d77","modified":1665054625265},{"_id":"source/_posts/Linux操作与使用.md","hash":"fcdfcb1fef2d1035c59a38f1ef544e1c53f968e1","modified":1676114266013},{"_id":"public/2022/10/05/Linux操作与使用/index.html","hash":"032f258cb20108ed7e4863b0789c311375c49c5d","modified":1676115863637},{"_id":"public/categories/Learn/index.html","hash":"e662bf0ed2ee171244c67d1b47756bdd4d1dbca2","modified":1676075906532},{"_id":"public/categories/Years/index.html","hash":"4dfd76f4d374fc1b2b9b7c1122123a562fca660e","modified":1676075906532},{"_id":"public/categories/Other/index.html","hash":"1ef10710d7e7d37fd46722f9f3875f36f4421b0e","modified":1676075906532},{"_id":"public/categories/Article/index.html","hash":"91ab6a0070fe3f1bc8903ed1256896c08aa97f26","modified":1676117628059},{"_id":"public/categories/Git/index.html","hash":"22555a6213f84ceb3bfd35801fecdf3309d94fdc","modified":1676115515454},{"_id":"public/tags/操作系统/index.html","hash":"0f3249739a67bd70d230b302e367ce6e0ee22b73","modified":1676117628059},{"_id":"public/tags/命令行/index.html","hash":"c7de8bdc28acde55af4e07c47a3560ce6e1b65c4","modified":1676117628059},{"_id":"source/_posts/Linux高级操作与管理.md","hash":"fd589bf76c7d7719754d9cb7757cb84af4b6e592","modified":1676114275948},{"_id":"public/2022/10/06/Linux高级操作与管理/index.html","hash":"6792e166bf60c3efe473c40d0797988868e75675","modified":1676115863637},{"_id":"source/_posts/Typora-picgo-oss搭建hexo博客图床.md","hash":"c46a3b8c78758d2b39bfc4ab8b2c483754979c7f","modified":1676115024170},{"_id":"public/2022/10/07/Typora-picgo-oss搭建hexo博客图床/index.html","hash":"e0e9eba54a16ff11aa0035285df027297e710f97","modified":1676115863637},{"_id":"public/categories/hole/index.html","hash":"1de1c1d46c633d45b11734ea630709d1d62d3f98","modified":1676075906532},{"_id":"public/tags/踩过的坑/index.html","hash":"3583c6659bff4b81b168e1ecc2b8a5ae323d2ec9","modified":1676117628059},{"_id":"public/tags/typora/index.html","hash":"e6086661559b1bd4801fcd1ecb41df861ec9e22c","modified":1676117628059},{"_id":"public/tags/picgo/index.html","hash":"46d21a6b51d9400c791538150affa2e98c5211cd","modified":1676117628059},{"_id":"public/tags/oss/index.html","hash":"6f7cc4c8536170d103705f6740116f2d95ae56f4","modified":1676117628059},{"_id":"source/_posts/《国境以南，太阳以西》人海茫茫，哪来那么多的不期而遇.md","hash":"798a134687341bcb59b2c66e8bab5d1c892f2f52","modified":1676117228327},{"_id":"public/2023/02/11/《国境以南，太阳以西》人海茫茫，哪来那么多的不期而遇/index.html","hash":"25c300de807b29ee13e1757e255c7cbb7300bd6b","modified":1676117628059},{"_id":"public/archives/2023/index.html","hash":"f1eef1e09251b97f1e3df4210699bd298e036605","modified":1676117628059},{"_id":"public/archives/2023/02/index.html","hash":"0223b221871ca28d113f69bf69fb6d4a74772478","modified":1676117628059},{"_id":"public/categories/Learning-Record/index.html","hash":"e6643d68973ca9f9360b83bb613a86a34c82c31c","modified":1676117628059},{"_id":"public/categories/Linux-Unix/index.html","hash":"bb8fc61d1a4d3b09250b080857a2c1890ac0088f","modified":1676117628059},{"_id":"public/categories/Guide/index.html","hash":"aca84dc63db5658ce3a41560b93339810b47f898","modified":1676117628059},{"_id":"public/categories/Tutorial-Error-Fix/index.html","hash":"f15eb3e1cae2d4c947017dbc2668871eb7863e6c","modified":1676117628059},{"_id":"public/categories/Read/index.html","hash":"9e2a3acb53c9b84ddf84cf570af3dd0e00c8db94","modified":1676117628059},{"_id":"public/tags/村上春树/index.html","hash":"4c4dbc259aa5cedeefc61fb1b234d2caa83eccbb","modified":1676117628059}],"Category":[{"name":"编程语言","_id":"cknazds7b000064rh86inbtf0"},{"name":"web前端","_id":"cknazjh3p0000knrh4wob6zxu"},{"name":"考研","_id":"cknazrpqe00011xrh4zy081ml"},{"name":"考研之路","_id":"cknazt6k600081xrhg26n5cbt"},{"name":"Linux","_id":"cknazwu1o0001vbrh0hb5cpx7"},{"name":"沉思录","_id":"cknb0lvat000141rhdn87gvd0"},{"name":"软件文档","_id":"cknd7c3r50000p2rhb9dl3rio"},{"name":"美食与生活","_id":"ckngxqqjv0001itrh8lxe1ri7"},{"name":"Python","_id":"ckp7s77go0002dbrh586191ij"},{"name":"UCB CS61x","_id":"ckpwpsg440001jgrh2nzkg0uv"},{"name":"CS61x","_id":"ckpwpud1u0000lorh6nni1qvf"},{"name":"CS61A","_id":"cks4bvdq600026prh3ys7hlwg"},{"name":"My year","_id":"ckt3vfzs70001xgrhcoyef39f"},{"name":"CS61B","_id":"cktqnxlf400025arh0gpxf1dl"},{"name":"CS61","_id":"cl40x3tio00001erhb9886c3x"},{"name":"沧海巫山","_id":"cl40x3tiw00041erhgkqb0n1a"},{"name":"清川文集","_id":"cl411w4jq00012nrh2xui1m1p"},{"name":"程序结构","_id":"cl8k9qfzn00004vrh06tzam1w"},{"name":"数据结构与算法","_id":"cl8k9qg0900024vrh426k1baw"},{"name":"学习路线","_id":"cl8k9qg0e00044vrhgfxq3d2k"},{"name":"年之纪","_id":"cl8k9qg0h00054vrh54a6bqxb"},{"name":"云中浮浪","_id":"cl8k9qg0j00074vrhf2ej37vp"},{"name":"学习进度","_id":"cl8vpk7fa0001dzrh9x0l9c8r"},{"name":"Learn","_id":"cl8wzj7w80000harh39ny9bex"},{"name":"Years","_id":"cl8wzj7wk0009harhbj6z2dau"},{"name":"Other","_id":"cl8wzj7wl000bharh4snvevvr"},{"name":"Article","_id":"cl8wzj7wm000fharh2rb8dogk"},{"name":"Git","_id":"cl8wzj7wx000oharh4mx42h6t"},{"name":"hole","_id":"cl8xvcrpc0001cwrh1m1y8tj6"},{"name":"Learning Record","_id":"cldzvwhml00002irhc3dh41yl"},{"name":"Linux/Unix","_id":"cldzvwhmu00022irh01iu43h9"},{"name":"Guide","_id":"cldzvwhmv00052irhcxnq7xy9"},{"name":"Tutorial/Error/Fix","_id":"cldzvwhmv00072irhcd8k3kxx"},{"name":"Read","_id":"cldzvwhn9000c2irh00scc01o"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}],"Page":[{"title":"tags","date":"2021-04-09T13:11:03.000Z","type":"tags","comments":0,"_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-04-09 21:11:03\ntype: tags\ncomments: false\n---\n\n","updated":"2021-04-09T13:18:34.526Z","path":"tags/index.html","layout":"page","_id":"cknacs3s10002dwrha7me1l7i","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"categories","date":"2021-04-09T13:20:14.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-04-09 21:20:14\ntype: categories\ncomments: false\n---\n","updated":"2021-04-09T13:20:39.394Z","path":"categories/index.html","layout":"page","_id":"cknacs3s20003dwrhhwx0hl69","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"About","date":"2021-04-11T12:34:12.000Z","_content":"\n\n\n\n\n\n\n\n\n<center><font face=\"微软雅黑\" color=gray size=5>以我为名的小说，是隽永还是深刻。</font></center>\n\n<center><font color=red face=\"微软雅黑\" size=5>ME</font></center>\n\n<center>清川</center>    \n\n<center>INTP-T</center>\n\n<center><font color=red face=\"微软雅黑\" size=5>Concat</font></center>\n\n<center>Github:↗</center>\n\n<center>Eyepetizer： 清 川</center>\n\n<center>Wechat:  D0xffe4</center>\n\n\n\n\n\n\n\n\n\n","source":"About/index.md","raw":"---\ntitle: About\ndate: 2021-04-11 20:34:12\n---\n\n\n\n\n\n\n\n\n\n<center><font face=\"微软雅黑\" color=gray size=5>以我为名的小说，是隽永还是深刻。</font></center>\n\n<center><font color=red face=\"微软雅黑\" size=5>ME</font></center>\n\n<center>清川</center>    \n\n<center>INTP-T</center>\n\n<center><font color=red face=\"微软雅黑\" size=5>Concat</font></center>\n\n<center>Github:↗</center>\n\n<center>Eyepetizer： 清 川</center>\n\n<center>Wechat:  D0xffe4</center>\n\n\n\n\n\n\n\n\n\n","updated":"2023-02-11T12:05:50.400Z","path":"About/index.html","_id":"cknd5e8d90000b6rh9quegjpm","comments":1,"layout":"page","content":"<center><font face=\"微软雅黑\" color=gray size=5>以我为名的小说，是隽永还是深刻。</font></center>\n\n<center><font color=red face=\"微软雅黑\" size=5>ME</font></center>\n\n<center>清川</center>    \n\n<center>INTP-T</center>\n\n<center><font color=red face=\"微软雅黑\" size=5>Concat</font></center>\n\n<center>Github:↗</center>\n\n<center>Eyepetizer： 清 川</center>\n\n<center>Wechat:  D0xffe4</center>\n\n\n\n\n\n\n\n\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"cover":"/img/cover.jpg","length":67,"excerpt":"","more":"<center><font face=\"微软雅黑\" color=gray size=5>以我为名的小说，是隽永还是深刻。</font></center>\n\n<center><font color=red face=\"微软雅黑\" size=5>ME</font></center>\n\n<center>清川</center>    \n\n<center>INTP-T</center>\n\n<center><font color=red face=\"微软雅黑\" size=5>Concat</font></center>\n\n<center>Github:↗</center>\n\n<center>Eyepetizer： 清 川</center>\n\n<center>Wechat:  D0xffe4</center>\n\n\n\n\n\n\n\n\n\n"},{"title":"link","date":"2022-06-05T11:53:22.000Z","type":"link","comment":false,"_content":"\n****","source":"link/index.md","raw":"---\ntitle: link\ndate: 2022-06-05 19:53:22\ntype: \"link\"\ncomment: false\n---\n\n****","updated":"2022-06-05T11:59:51.162Z","path":"link/index.html","comments":1,"layout":"page","_id":"cl411qi160000q6rhd3o7h1hv","content":"<hr>\n","site":{"data":{}},"cover":"/img/cover.jpg","length":0,"excerpt":"","more":"<hr>\n"}],"Post":[{"title":"Markdown使用指南","date":"2021-04-11T02:31:39.000Z","mathjax":true,"cover":"/myimage/doc/markdown_cover.png","_content":"\n# **Markdown使用 指南**\n\n*********\n\n## Markdown 标题\n\n*****\n\n### 使用#标记多级标题\n\n> 一级标题用#号来标记\n>\n> 二级标题用##号来标记\n>\n> ..... 依次类推\n\n### 使用=和-标记一级和二级标题（部分支持）\n\n> 一级标题用=======来标注\n>\n> 二级标题用------------来标注\n\n***********\n\n## Markdown段落格式\n\n### 字体\n\n>*斜体*   * *\n>\n>**粗体**  ** **\n>\n>***斜粗体***   * * *  * * *\n\n### 线条\n\n>分割线 *********\n>\n>~~删除线~~  ~~ ~~\n>\n><u>下划线</u>  <u> </u>\n>\n>脚注  [^脚注]\n\n**********\n\n## Markdown列表\n\n* 第一项\n\n  - 第一个元素\n\n    * 第二个元素\n\n* 第二项\n\n    * 第一个元素\n    * 第二个元素 \n\n**********\n\n## Markdown 区块\n\n### 区块嵌套\n\n> 区块引用符 >\n>\n> > 第一层嵌套 >>\n>\n> > > 第二层嵌套 >>>\n> > >\n> > > \n>\n\n### 区块中使用列表\n\n> * 第一项\n>   * 1.1\n>   * 1.2\n> * 第二项\n>   * 2.1\n>   * 2.2\n> * 第三项\n\n### 列表中使用区块\n\n* 第一项\n\n  > 学技术不仅是技术，而是梦想\n\n* 第二项 \n\n  > 我们的目标是星辰大海。\n\n*******\n\n## Markdown 代码 \n\n### 单个片段代码\n\n> `printf()`函数\n\n### 代码区块\n\n代码块使用三个反引号建立，以下是部分语言的实例代码：\n\n> **Python实例**\n>\n> ```python\n> import os\n> import sys\n> print(\"hello world!\")\n> ```\n>\n> **Javascript实例**\n>\n> ```javascript\n> $(document).ready(function(){\n> alert('RUNO')\n> })\n> ```\n>\n> **PHP实例**\n>\n> ```php\n> <?php\n> echo 1\n> ?>\n> ```\n\n******\n\n## Markdown 链接\n\n链接使用[链接名称](http://www.baidu.com)建立，格式为[]() ，也可以用变量设置来建立一个链接，赋值在文档末尾进行\n\n>这个链接用 1 作为网址变量 [Google][1]\n\n******\n\n## Markdown 图片\n\n### 通过markdown语法插入图片\n\nMarkdown 插入图片的语法格式如下：\n\n> ![属性文本]()\n\n### 通过Typora直接插入图片 (编辑器必须是Typora编辑器)\n\n>格式-->图像-->插入图片\n\n*****\n\n## Markdown 表格\n\nMarkdown表格格式如下：\n\n> | |为分割单元格，-表示长度，：：为中央对齐\n\n| 数据统计表 |  A   |  B   |  C   |  D   |  E   |\n| :--------: | :--: | :--: | :--: | :--: | :--: |\n|    文字    |  1   |  4   |  5   |  8   |  9   |\n|    图标    |  2   |  3   |  6   |  7   |  0   |\n\n******\n\n## Markdown 拓展技巧\n\n### HTML元素\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的HTML元素有：\n\n> \\<kbd>元素：使用<kbd>Shift</kbd> +<kbd>W</kbd> 执行操作\n>\n> \\<b>元素：<b>123</b>    \n>\n> \\<i>元素：<i>admin</i>\n>\n> \\<em>元素：<em>admin</em>\n>\n> \\<sup>元素：A<sup>1</sup>\n>\n> \\<br> 元素：换行\n\n### 转义字符\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字，Markdown 使用反斜杠转义特殊字符：\n\n> \\ * \\ * 转义文本加粗\n\n### 公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如输入：\n\n> ```nginx\n> \\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \n> \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n> \\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n> \\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n> \\end{vmatrix}\n> ${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n> ```\n\n会显示如下公式：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n\n## **参考**\n\n1.菜鸟教程 <u>https://www.runoob.com/markdown/md-tutorial.html</u>\n\n2.知乎专栏 <u>https://zhuanlan.zhihu.com/p/67153848</u>\n\n\n\n\n[^脚注]: 这是一个脚注\n\n[1] : http://www.google.com","source":"_posts/Markdown指南.md","raw":"---\ntitle: Markdown使用指南\ndate: 2021-04-11 10:31:39\ntags:\n- Markdown\ncategories:\n- Guide\nmathjax: true\ncover: /myimage/doc/markdown_cover.png\n---\n\n# **Markdown使用 指南**\n\n*********\n\n## Markdown 标题\n\n*****\n\n### 使用#标记多级标题\n\n> 一级标题用#号来标记\n>\n> 二级标题用##号来标记\n>\n> ..... 依次类推\n\n### 使用=和-标记一级和二级标题（部分支持）\n\n> 一级标题用=======来标注\n>\n> 二级标题用------------来标注\n\n***********\n\n## Markdown段落格式\n\n### 字体\n\n>*斜体*   * *\n>\n>**粗体**  ** **\n>\n>***斜粗体***   * * *  * * *\n\n### 线条\n\n>分割线 *********\n>\n>~~删除线~~  ~~ ~~\n>\n><u>下划线</u>  <u> </u>\n>\n>脚注  [^脚注]\n\n**********\n\n## Markdown列表\n\n* 第一项\n\n  - 第一个元素\n\n    * 第二个元素\n\n* 第二项\n\n    * 第一个元素\n    * 第二个元素 \n\n**********\n\n## Markdown 区块\n\n### 区块嵌套\n\n> 区块引用符 >\n>\n> > 第一层嵌套 >>\n>\n> > > 第二层嵌套 >>>\n> > >\n> > > \n>\n\n### 区块中使用列表\n\n> * 第一项\n>   * 1.1\n>   * 1.2\n> * 第二项\n>   * 2.1\n>   * 2.2\n> * 第三项\n\n### 列表中使用区块\n\n* 第一项\n\n  > 学技术不仅是技术，而是梦想\n\n* 第二项 \n\n  > 我们的目标是星辰大海。\n\n*******\n\n## Markdown 代码 \n\n### 单个片段代码\n\n> `printf()`函数\n\n### 代码区块\n\n代码块使用三个反引号建立，以下是部分语言的实例代码：\n\n> **Python实例**\n>\n> ```python\n> import os\n> import sys\n> print(\"hello world!\")\n> ```\n>\n> **Javascript实例**\n>\n> ```javascript\n> $(document).ready(function(){\n> alert('RUNO')\n> })\n> ```\n>\n> **PHP实例**\n>\n> ```php\n> <?php\n> echo 1\n> ?>\n> ```\n\n******\n\n## Markdown 链接\n\n链接使用[链接名称](http://www.baidu.com)建立，格式为[]() ，也可以用变量设置来建立一个链接，赋值在文档末尾进行\n\n>这个链接用 1 作为网址变量 [Google][1]\n\n******\n\n## Markdown 图片\n\n### 通过markdown语法插入图片\n\nMarkdown 插入图片的语法格式如下：\n\n> ![属性文本]()\n\n### 通过Typora直接插入图片 (编辑器必须是Typora编辑器)\n\n>格式-->图像-->插入图片\n\n*****\n\n## Markdown 表格\n\nMarkdown表格格式如下：\n\n> | |为分割单元格，-表示长度，：：为中央对齐\n\n| 数据统计表 |  A   |  B   |  C   |  D   |  E   |\n| :--------: | :--: | :--: | :--: | :--: | :--: |\n|    文字    |  1   |  4   |  5   |  8   |  9   |\n|    图标    |  2   |  3   |  6   |  7   |  0   |\n\n******\n\n## Markdown 拓展技巧\n\n### HTML元素\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的HTML元素有：\n\n> \\<kbd>元素：使用<kbd>Shift</kbd> +<kbd>W</kbd> 执行操作\n>\n> \\<b>元素：<b>123</b>    \n>\n> \\<i>元素：<i>admin</i>\n>\n> \\<em>元素：<em>admin</em>\n>\n> \\<sup>元素：A<sup>1</sup>\n>\n> \\<br> 元素：换行\n\n### 转义字符\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字，Markdown 使用反斜杠转义特殊字符：\n\n> \\ * \\ * 转义文本加粗\n\n### 公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如输入：\n\n> ```nginx\n> \\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \n> \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n> \\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n> \\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n> \\end{vmatrix}\n> ${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n> ```\n\n会显示如下公式：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n\n## **参考**\n\n1.菜鸟教程 <u>https://www.runoob.com/markdown/md-tutorial.html</u>\n\n2.知乎专栏 <u>https://zhuanlan.zhihu.com/p/67153848</u>\n\n\n\n\n[^脚注]: 这是一个脚注\n\n[1] : http://www.google.com","slug":"Markdown指南","published":1,"updated":"2023-02-11T11:18:12.089Z","_id":"ckncr32gd0000l8rhhz07cxn5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Markdown使用-指南\"><a href=\"#Markdown使用-指南\" class=\"headerlink\" title=\"Markdown使用 指南\"></a><strong>Markdown使用 指南</strong></h1><hr>\n<h2 id=\"Markdown-标题\"><a href=\"#Markdown-标题\" class=\"headerlink\" title=\"Markdown 标题\"></a>Markdown 标题</h2><hr>\n<h3 id=\"使用-标记多级标题\"><a href=\"#使用-标记多级标题\" class=\"headerlink\" title=\"使用#标记多级标题\"></a>使用#标记多级标题</h3><blockquote>\n<p>一级标题用#号来标记</p>\n<p>二级标题用##号来标记</p>\n<p>….. 依次类推</p>\n</blockquote>\n<h3 id=\"使用-和-标记一级和二级标题（部分支持）\"><a href=\"#使用-和-标记一级和二级标题（部分支持）\" class=\"headerlink\" title=\"使用=和-标记一级和二级标题（部分支持）\"></a>使用=和-标记一级和二级标题（部分支持）</h3><blockquote>\n<p>一级标题用=======来标注</p>\n<p>二级标题用————来标注</p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown段落格式\"><a href=\"#Markdown段落格式\" class=\"headerlink\" title=\"Markdown段落格式\"></a>Markdown段落格式</h2><h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><blockquote>\n<p><em>斜体</em>   * *</p>\n<p><strong>粗体</strong>  ** **</p>\n<p><em><strong>斜粗体</strong></em>   * * *  * * *</p>\n</blockquote>\n<h3 id=\"线条\"><a href=\"#线条\" class=\"headerlink\" title=\"线条\"></a>线条</h3><blockquote>\n<p>分割线 *********</p>\n<p><del>删除线</del>  ~~ ~~</p>\n<p><u>下划线</u>  <u> </u></p>\n<p>脚注  <a href=\"%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8\">^脚注</a></p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown列表\"><a href=\"#Markdown列表\" class=\"headerlink\" title=\"Markdown列表\"></a>Markdown列表</h2><ul>\n<li><p>第一项</p>\n<ul>\n<li><p>第一个元素</p>\n<ul>\n<li>第二个元素</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>第二项</p>\n<ul>\n<li>第一个元素</li>\n<li>第二个元素 </li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"Markdown-区块\"><a href=\"#Markdown-区块\" class=\"headerlink\" title=\"Markdown 区块\"></a>Markdown 区块</h2><h3 id=\"区块嵌套\"><a href=\"#区块嵌套\" class=\"headerlink\" title=\"区块嵌套\"></a>区块嵌套</h3><blockquote>\n<p>区块引用符 &gt;</p>\n<blockquote>\n<p>第一层嵌套 &gt;&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>第二层嵌套 &gt;&gt;&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"区块中使用列表\"><a href=\"#区块中使用列表\" class=\"headerlink\" title=\"区块中使用列表\"></a>区块中使用列表</h3><blockquote>\n<ul>\n<li>第一项<ul>\n<li>1.1</li>\n<li>1.2</li>\n</ul>\n</li>\n<li>第二项<ul>\n<li>2.1</li>\n<li>2.2</li>\n</ul>\n</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<h3 id=\"列表中使用区块\"><a href=\"#列表中使用区块\" class=\"headerlink\" title=\"列表中使用区块\"></a>列表中使用区块</h3><ul>\n<li><p>第一项</p>\n<blockquote>\n<p>学技术不仅是技术，而是梦想</p>\n</blockquote>\n</li>\n<li><p>第二项 </p>\n<blockquote>\n<p>我们的目标是星辰大海。</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"Markdown-代码\"><a href=\"#Markdown-代码\" class=\"headerlink\" title=\"Markdown 代码\"></a>Markdown 代码</h2><h3 id=\"单个片段代码\"><a href=\"#单个片段代码\" class=\"headerlink\" title=\"单个片段代码\"></a>单个片段代码</h3><blockquote>\n<p><code>printf()</code>函数</p>\n</blockquote>\n<h3 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h3><p>代码块使用三个反引号建立，以下是部分语言的实例代码：</p>\n<blockquote>\n<p><strong>Python实例</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Javascript实例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">alert(<span class=\"string\">&#x27;RUNO&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>PHP实例</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h2 id=\"Markdown-链接\"><a href=\"#Markdown-链接\" class=\"headerlink\" title=\"Markdown 链接\"></a>Markdown 链接</h2><p>链接使用<a href=\"http://www.baidu.com/\">链接名称</a>建立，格式为<a href=\"\"></a> ，也可以用变量设置来建立一个链接，赋值在文档末尾进行</p>\n<blockquote>\n<p>这个链接用 1 作为网址变量 [Google][1]</p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown-图片\"><a href=\"#Markdown-图片\" class=\"headerlink\" title=\"Markdown 图片\"></a>Markdown 图片</h2><h3 id=\"通过markdown语法插入图片\"><a href=\"#通过markdown语法插入图片\" class=\"headerlink\" title=\"通过markdown语法插入图片\"></a>通过markdown语法插入图片</h3><p>Markdown 插入图片的语法格式如下：</p>\n<blockquote>\n<p><img src=\"\" alt=\"属性文本\"></p>\n</blockquote>\n<h3 id=\"通过Typora直接插入图片-编辑器必须是Typora编辑器\"><a href=\"#通过Typora直接插入图片-编辑器必须是Typora编辑器\" class=\"headerlink\" title=\"通过Typora直接插入图片 (编辑器必须是Typora编辑器)\"></a>通过Typora直接插入图片 (编辑器必须是Typora编辑器)</h3><blockquote>\n<p>格式–&gt;图像–&gt;插入图片</p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown-表格\"><a href=\"#Markdown-表格\" class=\"headerlink\" title=\"Markdown 表格\"></a>Markdown 表格</h2><p>Markdown表格格式如下：</p>\n<blockquote>\n<p>| |为分割单元格，-表示长度，：：为中央对齐</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数据统计表</th>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">C</th>\n<th align=\"center\">D</th>\n<th align=\"center\">E</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">文字</td>\n<td align=\"center\">1</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">图标</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"Markdown-拓展技巧\"><a href=\"#Markdown-拓展技巧\" class=\"headerlink\" title=\"Markdown 拓展技巧\"></a>Markdown 拓展技巧</h2><h3 id=\"HTML元素\"><a href=\"#HTML元素\" class=\"headerlink\" title=\"HTML元素\"></a>HTML元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的HTML元素有：</p>\n<blockquote>\n<p>&lt;kbd&gt;元素：使用<kbd>Shift</kbd> +<kbd>W</kbd> 执行操作</p>\n<p>&lt;b&gt;元素：<b>123</b>    </p>\n<p>&lt;i&gt;元素：<i>admin</i></p>\n<p>&lt;em&gt;元素：<em>admin</em></p>\n<p>&lt;sup&gt;元素：A<sup>1</sup></p>\n<p>&lt;br&gt; 元素：换行</p>\n</blockquote>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字，Markdown 使用反斜杠转义特殊字符：</p>\n<blockquote>\n<p>\\ * \\ * 转义文本加粗</p>\n</blockquote>\n<h3 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如输入：</p>\n<blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 =  \\begin&#123;vmatrix&#125; </span><br><span class=\"line\">\\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\</span><br><span class=\"line\">\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\</span><br><span class=\"line\">\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\</span><br><span class=\"line\">\\end&#123;vmatrix&#125;</span><br><span class=\"line\">$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>会显示如下公式：</p>\n<p>$$<br>\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}<br>\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\<br>\\frac{\\partial X}{\\partial u} &amp;  \\frac{\\partial Y}{\\partial u} &amp; 0 \\<br>\\frac{\\partial X}{\\partial v} &amp;  \\frac{\\partial Y}{\\partial v} &amp; 0 \\<br>\\end{vmatrix}<br>${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p>1.菜鸟教程 <u><a href=\"https://www.runoob.com/markdown/md-tutorial.html\">https://www.runoob.com/markdown/md-tutorial.html</a></u></p>\n<p>2.知乎专栏 <u><a href=\"https://zhuanlan.zhihu.com/p/67153848\">https://zhuanlan.zhihu.com/p/67153848</a></u></p>\n<p>[1] : <a href=\"http://www.google.com/\">http://www.google.com</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":2020,"excerpt":"","more":"<h1 id=\"Markdown使用-指南\"><a href=\"#Markdown使用-指南\" class=\"headerlink\" title=\"Markdown使用 指南\"></a><strong>Markdown使用 指南</strong></h1><hr>\n<h2 id=\"Markdown-标题\"><a href=\"#Markdown-标题\" class=\"headerlink\" title=\"Markdown 标题\"></a>Markdown 标题</h2><hr>\n<h3 id=\"使用-标记多级标题\"><a href=\"#使用-标记多级标题\" class=\"headerlink\" title=\"使用#标记多级标题\"></a>使用#标记多级标题</h3><blockquote>\n<p>一级标题用#号来标记</p>\n<p>二级标题用##号来标记</p>\n<p>….. 依次类推</p>\n</blockquote>\n<h3 id=\"使用-和-标记一级和二级标题（部分支持）\"><a href=\"#使用-和-标记一级和二级标题（部分支持）\" class=\"headerlink\" title=\"使用=和-标记一级和二级标题（部分支持）\"></a>使用=和-标记一级和二级标题（部分支持）</h3><blockquote>\n<p>一级标题用=======来标注</p>\n<p>二级标题用————来标注</p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown段落格式\"><a href=\"#Markdown段落格式\" class=\"headerlink\" title=\"Markdown段落格式\"></a>Markdown段落格式</h2><h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><blockquote>\n<p><em>斜体</em>   * *</p>\n<p><strong>粗体</strong>  ** **</p>\n<p><em><strong>斜粗体</strong></em>   * * *  * * *</p>\n</blockquote>\n<h3 id=\"线条\"><a href=\"#线条\" class=\"headerlink\" title=\"线条\"></a>线条</h3><blockquote>\n<p>分割线 *********</p>\n<p><del>删除线</del>  ~~ ~~</p>\n<p><u>下划线</u>  <u> </u></p>\n<p>脚注  <a href=\"%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8\">^脚注</a></p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown列表\"><a href=\"#Markdown列表\" class=\"headerlink\" title=\"Markdown列表\"></a>Markdown列表</h2><ul>\n<li><p>第一项</p>\n<ul>\n<li><p>第一个元素</p>\n<ul>\n<li>第二个元素</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>第二项</p>\n<ul>\n<li>第一个元素</li>\n<li>第二个元素 </li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"Markdown-区块\"><a href=\"#Markdown-区块\" class=\"headerlink\" title=\"Markdown 区块\"></a>Markdown 区块</h2><h3 id=\"区块嵌套\"><a href=\"#区块嵌套\" class=\"headerlink\" title=\"区块嵌套\"></a>区块嵌套</h3><blockquote>\n<p>区块引用符 &gt;</p>\n<blockquote>\n<p>第一层嵌套 &gt;&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>第二层嵌套 &gt;&gt;&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"区块中使用列表\"><a href=\"#区块中使用列表\" class=\"headerlink\" title=\"区块中使用列表\"></a>区块中使用列表</h3><blockquote>\n<ul>\n<li>第一项<ul>\n<li>1.1</li>\n<li>1.2</li>\n</ul>\n</li>\n<li>第二项<ul>\n<li>2.1</li>\n<li>2.2</li>\n</ul>\n</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<h3 id=\"列表中使用区块\"><a href=\"#列表中使用区块\" class=\"headerlink\" title=\"列表中使用区块\"></a>列表中使用区块</h3><ul>\n<li><p>第一项</p>\n<blockquote>\n<p>学技术不仅是技术，而是梦想</p>\n</blockquote>\n</li>\n<li><p>第二项 </p>\n<blockquote>\n<p>我们的目标是星辰大海。</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"Markdown-代码\"><a href=\"#Markdown-代码\" class=\"headerlink\" title=\"Markdown 代码\"></a>Markdown 代码</h2><h3 id=\"单个片段代码\"><a href=\"#单个片段代码\" class=\"headerlink\" title=\"单个片段代码\"></a>单个片段代码</h3><blockquote>\n<p><code>printf()</code>函数</p>\n</blockquote>\n<h3 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h3><p>代码块使用三个反引号建立，以下是部分语言的实例代码：</p>\n<blockquote>\n<p><strong>Python实例</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Javascript实例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">document</span>).ready(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">alert(<span class=\"string\">&#x27;RUNO&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>PHP实例</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h2 id=\"Markdown-链接\"><a href=\"#Markdown-链接\" class=\"headerlink\" title=\"Markdown 链接\"></a>Markdown 链接</h2><p>链接使用<a href=\"http://www.baidu.com/\">链接名称</a>建立，格式为<a href=\"\"></a> ，也可以用变量设置来建立一个链接，赋值在文档末尾进行</p>\n<blockquote>\n<p>这个链接用 1 作为网址变量 [Google][1]</p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown-图片\"><a href=\"#Markdown-图片\" class=\"headerlink\" title=\"Markdown 图片\"></a>Markdown 图片</h2><h3 id=\"通过markdown语法插入图片\"><a href=\"#通过markdown语法插入图片\" class=\"headerlink\" title=\"通过markdown语法插入图片\"></a>通过markdown语法插入图片</h3><p>Markdown 插入图片的语法格式如下：</p>\n<blockquote>\n<p><img src=\"\" alt=\"属性文本\"></p>\n</blockquote>\n<h3 id=\"通过Typora直接插入图片-编辑器必须是Typora编辑器\"><a href=\"#通过Typora直接插入图片-编辑器必须是Typora编辑器\" class=\"headerlink\" title=\"通过Typora直接插入图片 (编辑器必须是Typora编辑器)\"></a>通过Typora直接插入图片 (编辑器必须是Typora编辑器)</h3><blockquote>\n<p>格式–&gt;图像–&gt;插入图片</p>\n</blockquote>\n<hr>\n<h2 id=\"Markdown-表格\"><a href=\"#Markdown-表格\" class=\"headerlink\" title=\"Markdown 表格\"></a>Markdown 表格</h2><p>Markdown表格格式如下：</p>\n<blockquote>\n<p>| |为分割单元格，-表示长度，：：为中央对齐</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数据统计表</th>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">C</th>\n<th align=\"center\">D</th>\n<th align=\"center\">E</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">文字</td>\n<td align=\"center\">1</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">图标</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"Markdown-拓展技巧\"><a href=\"#Markdown-拓展技巧\" class=\"headerlink\" title=\"Markdown 拓展技巧\"></a>Markdown 拓展技巧</h2><h3 id=\"HTML元素\"><a href=\"#HTML元素\" class=\"headerlink\" title=\"HTML元素\"></a>HTML元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的HTML元素有：</p>\n<blockquote>\n<p>&lt;kbd&gt;元素：使用<kbd>Shift</kbd> +<kbd>W</kbd> 执行操作</p>\n<p>&lt;b&gt;元素：<b>123</b>    </p>\n<p>&lt;i&gt;元素：<i>admin</i></p>\n<p>&lt;em&gt;元素：<em>admin</em></p>\n<p>&lt;sup&gt;元素：A<sup>1</sup></p>\n<p>&lt;br&gt; 元素：换行</p>\n</blockquote>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字，Markdown 使用反斜杠转义特殊字符：</p>\n<blockquote>\n<p>\\ * \\ * 转义文本加粗</p>\n</blockquote>\n<h3 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如输入：</p>\n<blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 =  \\begin&#123;vmatrix&#125; </span><br><span class=\"line\">\\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\</span><br><span class=\"line\">\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\</span><br><span class=\"line\">\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\</span><br><span class=\"line\">\\end&#123;vmatrix&#125;</span><br><span class=\"line\">$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>会显示如下公式：</p>\n<p>$$<br>\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}<br>\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\<br>\\frac{\\partial X}{\\partial u} &amp;  \\frac{\\partial Y}{\\partial u} &amp; 0 \\<br>\\frac{\\partial X}{\\partial v} &amp;  \\frac{\\partial Y}{\\partial v} &amp; 0 \\<br>\\end{vmatrix}<br>${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p>1.菜鸟教程 <u><a href=\"https://www.runoob.com/markdown/md-tutorial.html\">https://www.runoob.com/markdown/md-tutorial.html</a></u></p>\n<p>2.知乎专栏 <u><a href=\"https://zhuanlan.zhihu.com/p/67153848\">https://zhuanlan.zhihu.com/p/67153848</a></u></p>\n<p>[1] : <a href=\"http://www.google.com/\">http://www.google.com</a></p>\n"},{"title":"CS自学路线与课程推荐","date":"2021-04-13T12:30:38.000Z","cover":"/myimage/grade/cslearn_cover.png","_content":"\n# CS基础课程自学路线与课程推荐\n\n简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考\n\n注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。\n\n*************\n\n### 计算机入门\n\n##### 公开课程：\n\n- **哈佛大学 CS50**   \n- 斯坦福大学 CS101\n- 麻省理工学院 6.00.1\n\n##### 书籍推荐：\n\n* 《编码》： 一本讲清编码原理的书\n\n\n\n*********************\n\n### 计算机程序结构与抽象\n\n##### 公开课程：\n\n* **加州大学伯克利分校  CS61A**\n\n* 斯坦福大学 CS106A  [Python]  \n* 卡内基梅隆大学 CMU 15-122 \n\n##### 书籍推荐：\n\n《计算机程序的构造和解释》\n\n> SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。\n\n\n\n**********************\n\n### 计算机系统架构与体系\n\n对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。\n\n##### 公开课程：\n\n* **计算机系统要素  Nand2Tetris**    \n\n> 这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I/O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。\n\n##### 书籍推荐：\n\n* 计算机系统要素  Nand2Tetris的原书\n\n\n\n*******\n\n### 数据结构与算法\n\n问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。\n\n##### 公开课程：\n\n* **加州大学伯克利分校  CS61B**\n\n> cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。\n\n* 斯坦福 CS106B\n* 卡内基梅隆大学 CMU 15-210\n\n##### 书籍推荐：\n\n* 算法导论  \n\n> 老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。\n\n* 大话数据结构\n\n> 深入浅出的讲解数据结构，作为入门当小说看看挺好的。\n\n* 算法图解\n\n> 同样是入门书籍，看看培养兴趣挺好的。\n\n\n\n**********\n\n### 计算机网络\n\n我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。\n\n##### 公开课程：\n\n* 斯坦福大学 CS144\n* 网易云课堂 《计算机网络》\n\n##### 书籍推荐：\n\n* **计算机网络自顶而下**  \n\n>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。\n\n* 计算机网络(谢希仁版)\n\n>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。\n\n\n\n\n\n*******\n\n### 计算机系统与运行\n\n学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。\n\n##### 公开课程:\n\n* **卡内基梅隆大学 CSAPP 配套课程  （B站有）**\n* 卡内基梅隆大学 CMU 15-213\n* 加州大学伯克利大学 CS61C\n* 斯坦福大学 CS107 \n\n##### 书籍推荐：\n\n* 深入理解计算机系统 CSAPP \n\n> 计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。\n\n\n\n\n\n***********\n\n### 参考\n\n1. 知乎文章《计算机名校路线课程》\n2. 网易云课堂  顶尖大学中文计算机课程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/CS自学路线与课程推荐.md","raw":"---\ntitle: CS自学路线与课程推荐\ndate: 2021-04-13 20:30:38\ntags:\n- 学习路线\n- 计算机课程\ncategories:\n- Learning Record\ncover: /myimage/grade/cslearn_cover.png\n---\n\n# CS基础课程自学路线与课程推荐\n\n简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考\n\n注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。\n\n*************\n\n### 计算机入门\n\n##### 公开课程：\n\n- **哈佛大学 CS50**   \n- 斯坦福大学 CS101\n- 麻省理工学院 6.00.1\n\n##### 书籍推荐：\n\n* 《编码》： 一本讲清编码原理的书\n\n\n\n*********************\n\n### 计算机程序结构与抽象\n\n##### 公开课程：\n\n* **加州大学伯克利分校  CS61A**\n\n* 斯坦福大学 CS106A  [Python]  \n* 卡内基梅隆大学 CMU 15-122 \n\n##### 书籍推荐：\n\n《计算机程序的构造和解释》\n\n> SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。\n\n\n\n**********************\n\n### 计算机系统架构与体系\n\n对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。\n\n##### 公开课程：\n\n* **计算机系统要素  Nand2Tetris**    \n\n> 这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I/O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。\n\n##### 书籍推荐：\n\n* 计算机系统要素  Nand2Tetris的原书\n\n\n\n*******\n\n### 数据结构与算法\n\n问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。\n\n##### 公开课程：\n\n* **加州大学伯克利分校  CS61B**\n\n> cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。\n\n* 斯坦福 CS106B\n* 卡内基梅隆大学 CMU 15-210\n\n##### 书籍推荐：\n\n* 算法导论  \n\n> 老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。\n\n* 大话数据结构\n\n> 深入浅出的讲解数据结构，作为入门当小说看看挺好的。\n\n* 算法图解\n\n> 同样是入门书籍，看看培养兴趣挺好的。\n\n\n\n**********\n\n### 计算机网络\n\n我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。\n\n##### 公开课程：\n\n* 斯坦福大学 CS144\n* 网易云课堂 《计算机网络》\n\n##### 书籍推荐：\n\n* **计算机网络自顶而下**  \n\n>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。\n\n* 计算机网络(谢希仁版)\n\n>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。\n\n\n\n\n\n*******\n\n### 计算机系统与运行\n\n学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。\n\n##### 公开课程:\n\n* **卡内基梅隆大学 CSAPP 配套课程  （B站有）**\n* 卡内基梅隆大学 CMU 15-213\n* 加州大学伯克利大学 CS61C\n* 斯坦福大学 CS107 \n\n##### 书籍推荐：\n\n* 深入理解计算机系统 CSAPP \n\n> 计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。\n\n\n\n\n\n***********\n\n### 参考\n\n1. 知乎文章《计算机名校路线课程》\n2. 网易云课堂  顶尖大学中文计算机课程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"CS自学路线与课程推荐","published":1,"updated":"2023-02-11T11:17:12.793Z","_id":"ckng69t8o0000e4rh5kz3b781","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"CS基础课程自学路线与课程推荐\"><a href=\"#CS基础课程自学路线与课程推荐\" class=\"headerlink\" title=\"CS基础课程自学路线与课程推荐\"></a>CS基础课程自学路线与课程推荐</h1><p>简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考</p>\n<p>注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。</p>\n<hr>\n<h3 id=\"计算机入门\"><a href=\"#计算机入门\" class=\"headerlink\" title=\"计算机入门\"></a>计算机入门</h3><h5 id=\"公开课程：\"><a href=\"#公开课程：\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><strong>哈佛大学 CS50</strong>   </li>\n<li>斯坦福大学 CS101</li>\n<li>麻省理工学院 6.00.1</li>\n</ul>\n<h5 id=\"书籍推荐：\"><a href=\"#书籍推荐：\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>《编码》： 一本讲清编码原理的书</li>\n</ul>\n<hr>\n<h3 id=\"计算机程序结构与抽象\"><a href=\"#计算机程序结构与抽象\" class=\"headerlink\" title=\"计算机程序结构与抽象\"></a>计算机程序结构与抽象</h3><h5 id=\"公开课程：-1\"><a href=\"#公开课程：-1\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><p><strong>加州大学伯克利分校  CS61A</strong></p>\n</li>\n<li><p>斯坦福大学 CS106A  [Python]  </p>\n</li>\n<li><p>卡内基梅隆大学 CMU 15-122 </p>\n</li>\n</ul>\n<h5 id=\"书籍推荐：-1\"><a href=\"#书籍推荐：-1\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><p>《计算机程序的构造和解释》</p>\n<blockquote>\n<p>SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。</p>\n</blockquote>\n<hr>\n<h3 id=\"计算机系统架构与体系\"><a href=\"#计算机系统架构与体系\" class=\"headerlink\" title=\"计算机系统架构与体系\"></a>计算机系统架构与体系</h3><p>对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。</p>\n<h5 id=\"公开课程：-2\"><a href=\"#公开课程：-2\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><strong>计算机系统要素  Nand2Tetris</strong>    </li>\n</ul>\n<blockquote>\n<p>这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I/O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。</p>\n</blockquote>\n<h5 id=\"书籍推荐：-2\"><a href=\"#书籍推荐：-2\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>计算机系统要素  Nand2Tetris的原书</li>\n</ul>\n<hr>\n<h3 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h3><p>问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。</p>\n<h5 id=\"公开课程：-3\"><a href=\"#公开课程：-3\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><strong>加州大学伯克利分校  CS61B</strong></li>\n</ul>\n<blockquote>\n<p>cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。</p>\n</blockquote>\n<ul>\n<li>斯坦福 CS106B</li>\n<li>卡内基梅隆大学 CMU 15-210</li>\n</ul>\n<h5 id=\"书籍推荐：-3\"><a href=\"#书籍推荐：-3\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>算法导论  </li>\n</ul>\n<blockquote>\n<p>老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。</p>\n</blockquote>\n<ul>\n<li>大话数据结构</li>\n</ul>\n<blockquote>\n<p>深入浅出的讲解数据结构，作为入门当小说看看挺好的。</p>\n</blockquote>\n<ul>\n<li>算法图解</li>\n</ul>\n<blockquote>\n<p>同样是入门书籍，看看培养兴趣挺好的。</p>\n</blockquote>\n<hr>\n<h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><p>我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。</p>\n<h5 id=\"公开课程：-4\"><a href=\"#公开课程：-4\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li>斯坦福大学 CS144</li>\n<li>网易云课堂 《计算机网络》</li>\n</ul>\n<h5 id=\"书籍推荐：-4\"><a href=\"#书籍推荐：-4\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li><strong>计算机网络自顶而下</strong>  </li>\n</ul>\n<blockquote>\n<p>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。</p>\n</blockquote>\n<ul>\n<li>计算机网络(谢希仁版)</li>\n</ul>\n<blockquote>\n<p>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。</p>\n</blockquote>\n<hr>\n<h3 id=\"计算机系统与运行\"><a href=\"#计算机系统与运行\" class=\"headerlink\" title=\"计算机系统与运行\"></a>计算机系统与运行</h3><p>学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。</p>\n<h5 id=\"公开课程\"><a href=\"#公开课程\" class=\"headerlink\" title=\"公开课程:\"></a>公开课程:</h5><ul>\n<li><strong>卡内基梅隆大学 CSAPP 配套课程  （B站有）</strong></li>\n<li>卡内基梅隆大学 CMU 15-213</li>\n<li>加州大学伯克利大学 CS61C</li>\n<li>斯坦福大学 CS107 </li>\n</ul>\n<h5 id=\"书籍推荐：-5\"><a href=\"#书籍推荐：-5\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>深入理解计算机系统 CSAPP </li>\n</ul>\n<blockquote>\n<p>计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。</p>\n</blockquote>\n<hr>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li>知乎文章《计算机名校路线课程》</li>\n<li>网易云课堂  顶尖大学中文计算机课程</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":1829,"excerpt":"","more":"<h1 id=\"CS基础课程自学路线与课程推荐\"><a href=\"#CS基础课程自学路线与课程推荐\" class=\"headerlink\" title=\"CS基础课程自学路线与课程推荐\"></a>CS基础课程自学路线与课程推荐</h1><p>简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考</p>\n<p>注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。</p>\n<hr>\n<h3 id=\"计算机入门\"><a href=\"#计算机入门\" class=\"headerlink\" title=\"计算机入门\"></a>计算机入门</h3><h5 id=\"公开课程：\"><a href=\"#公开课程：\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><strong>哈佛大学 CS50</strong>   </li>\n<li>斯坦福大学 CS101</li>\n<li>麻省理工学院 6.00.1</li>\n</ul>\n<h5 id=\"书籍推荐：\"><a href=\"#书籍推荐：\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>《编码》： 一本讲清编码原理的书</li>\n</ul>\n<hr>\n<h3 id=\"计算机程序结构与抽象\"><a href=\"#计算机程序结构与抽象\" class=\"headerlink\" title=\"计算机程序结构与抽象\"></a>计算机程序结构与抽象</h3><h5 id=\"公开课程：-1\"><a href=\"#公开课程：-1\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><p><strong>加州大学伯克利分校  CS61A</strong></p>\n</li>\n<li><p>斯坦福大学 CS106A  [Python]  </p>\n</li>\n<li><p>卡内基梅隆大学 CMU 15-122 </p>\n</li>\n</ul>\n<h5 id=\"书籍推荐：-1\"><a href=\"#书籍推荐：-1\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><p>《计算机程序的构造和解释》</p>\n<blockquote>\n<p>SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。</p>\n</blockquote>\n<hr>\n<h3 id=\"计算机系统架构与体系\"><a href=\"#计算机系统架构与体系\" class=\"headerlink\" title=\"计算机系统架构与体系\"></a>计算机系统架构与体系</h3><p>对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。</p>\n<h5 id=\"公开课程：-2\"><a href=\"#公开课程：-2\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><strong>计算机系统要素  Nand2Tetris</strong>    </li>\n</ul>\n<blockquote>\n<p>这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I/O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。</p>\n</blockquote>\n<h5 id=\"书籍推荐：-2\"><a href=\"#书籍推荐：-2\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>计算机系统要素  Nand2Tetris的原书</li>\n</ul>\n<hr>\n<h3 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h3><p>问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。</p>\n<h5 id=\"公开课程：-3\"><a href=\"#公开课程：-3\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li><strong>加州大学伯克利分校  CS61B</strong></li>\n</ul>\n<blockquote>\n<p>cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。</p>\n</blockquote>\n<ul>\n<li>斯坦福 CS106B</li>\n<li>卡内基梅隆大学 CMU 15-210</li>\n</ul>\n<h5 id=\"书籍推荐：-3\"><a href=\"#书籍推荐：-3\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>算法导论  </li>\n</ul>\n<blockquote>\n<p>老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。</p>\n</blockquote>\n<ul>\n<li>大话数据结构</li>\n</ul>\n<blockquote>\n<p>深入浅出的讲解数据结构，作为入门当小说看看挺好的。</p>\n</blockquote>\n<ul>\n<li>算法图解</li>\n</ul>\n<blockquote>\n<p>同样是入门书籍，看看培养兴趣挺好的。</p>\n</blockquote>\n<hr>\n<h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><p>我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。</p>\n<h5 id=\"公开课程：-4\"><a href=\"#公开课程：-4\" class=\"headerlink\" title=\"公开课程：\"></a>公开课程：</h5><ul>\n<li>斯坦福大学 CS144</li>\n<li>网易云课堂 《计算机网络》</li>\n</ul>\n<h5 id=\"书籍推荐：-4\"><a href=\"#书籍推荐：-4\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li><strong>计算机网络自顶而下</strong>  </li>\n</ul>\n<blockquote>\n<p>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。</p>\n</blockquote>\n<ul>\n<li>计算机网络(谢希仁版)</li>\n</ul>\n<blockquote>\n<p>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。</p>\n</blockquote>\n<hr>\n<h3 id=\"计算机系统与运行\"><a href=\"#计算机系统与运行\" class=\"headerlink\" title=\"计算机系统与运行\"></a>计算机系统与运行</h3><p>学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。</p>\n<h5 id=\"公开课程\"><a href=\"#公开课程\" class=\"headerlink\" title=\"公开课程:\"></a>公开课程:</h5><ul>\n<li><strong>卡内基梅隆大学 CSAPP 配套课程  （B站有）</strong></li>\n<li>卡内基梅隆大学 CMU 15-213</li>\n<li>加州大学伯克利大学 CS61C</li>\n<li>斯坦福大学 CS107 </li>\n</ul>\n<h5 id=\"书籍推荐：-5\"><a href=\"#书籍推荐：-5\" class=\"headerlink\" title=\"书籍推荐：\"></a>书籍推荐：</h5><ul>\n<li>深入理解计算机系统 CSAPP </li>\n</ul>\n<blockquote>\n<p>计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。</p>\n</blockquote>\n<hr>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li>知乎文章《计算机名校路线课程》</li>\n<li>网易云课堂  顶尖大学中文计算机课程</li>\n</ol>\n"},{"title":"简明Git使用方法","date":"2021-05-27T07:37:40.000Z","cover":"/myimage/doc/git_cover.png","_content":"\n近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的\n\n## 目录\n\n>版本库的创建\n>\n>*  Git的安装\n>*  版本库的创建\n>\n>版本库的操作\n>\n>*  文件操作\n>*  版本回退\n>*  修改撤销 \n>\n>远程库连接\n>\n>* 远程库添加与解除\n>* 从远程库克隆\n>\n>分支管理\n>\n>* 创建与合并分支\n>* 多人协作\n>\n>标签管理\n>\n>* 创建标签\n>* 操作标签\n>\n\n## 版本库的创建\n\n******\n\n### Git的安装\n\n在Ubuntu Linux上使用apt软件包管理工具进行安装\n\n``` bash\nsudo apt-get install git\n```\n\n在windows上直接进入[Git官网](https://git-scm.com/downloads)下载安装程序，而后按照默认选项安装即可\n\n\n\n### 版本库的创建\n\n选择一个合适的位置利用mkdir指令创建一个空目录，而后进入后输入指令\n\n```bash\ngit init\n```\n\n于是该目录就变成了Git可以管理的仓库，细心的读者可以发现当前目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n\n\n## 版本库的操作\n\n*******\n\n### 文件操作\n\n在文件操作之前首先明确几个概念\n\n**工作区**\n\n就是电脑中能直接看见的目录\n\n![working-dir](https://i.loli.net/2021/05/28/Vc1mn4w6MZIaRSB.png)\n\n**版本库**\n\n工作区目录中有一个隐藏目录.git。这个是Git的版本库，版本库主要由两个部分组成，stage暂存区和分支区。\n\n![git-repo](https://i.loli.net/2021/05/28/nzqcBheNH58kMAG.jpg)\n\n **将文件添加至Git版本库中时，有三个步骤：**\n\n**首先**在工作区创建一个文件Read.txt\n\n```bash\nvim/typora Read.txt\n```\n\n将文件修改添加至暂存区，在添加至暂存区前，我们首先看一下git的状态\n\n```bash\n~/CS61A$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tRead.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\n```\n\nGit清楚的告诉我们，有一个文件出现了，而`Read.txt`还从来没有被添加过，所以它的状态是`Untracked`。\n\n**而后**我们创建文件这次操作添加至暂存区\n\n```bash\ngit add Read.txt\n```\n\n*如果添加的是文件夹可以使用*\n\n```bash\ngit add vs/*\n```\n\n如果想删除文件可以用\n\n````bash\ngit rm Read.txt\n````\n\n再次查看git的状态\n\n```bash\n~/CS61A$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   Read.txt\n\n```\n\n`Changes to be committed`我们发现git已经识别了这个文件，可见这个文件已经被添加到了暂存区。\n\n**最后**我们将文件创建这次操作提交至仓库的master分支（分支的概念后面会讲到）\n\n```bash\ngit commit Read.txt -m \"commit\"\n```\n\n*如果想提交全部文件的操作可以用*\n\n```bash\ngit commit -m \"commit\"\n```\n\n这里的-m参数是对这次提交进行文字说明\n\n再次查看git的状态\n\n```bash\n~/CS61A$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\n```\n\n可见此时暂存区为空，修改已提交至仓库\n\n我们可以将创建文件并提交至仓库的过程用流程图表示\n\n```mermaid\ngraph LR\nA[在工作区创建文件]===>B[将修改/创建/删除操作添加至暂存区]====>C[将操作提交至仓库]\n```\n\n估计很多人都有疑问，为什么这里写的是操作，而不是将文件添加至暂存区，因为Git管理的是修改而不是文件，我们用一个例子来说明这个问题。\n\n首先，我们在Read.txt中添加一段文字`hello me`，而后将这次操作添加到暂存区，我们查看此时的状态\n\n```bash\nit status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   Read.txt\n\n```\n\n可见此次修改已经添加到了暂存区，而后我们再对文件进行修改，增加一行`hello you`，不将此次修改添加至暂存区。\n\n```bash\ngit status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   Read.txt\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   Read.txt\n\n```\n\n我们执行提交指令将修改提交至仓库，而后查看git状态\n\n```bash\ngit status\nOn branch master\nYour branch is ahead of 'origin/master' by 8 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   Read.txt\n\n\n```\n\n我们发现，未添加至暂存区的修改并未提交至仓库，我们查看一下工作区和最新版本库的区别\n\n```bash\n~/CS61A$ git diff -- Read.txt\ndiff --git a/Read.txt b/Read.txt\nindex 1f8eec4..12ee40e 100644\n--- a/Read.txt\n+++ b/Read.txt\n@@ -1,2 +1,3 @@\n hello world\n hello me\n+hello you\n```\n\n如果Git管理的是文件本身，那么文件在提交时是什么样，提交的文件就是什么样，然而经过对比发现，版本库的文件和工作区的文件是不一样，我们每次添加到暂存区的是对文件的操作步骤，比如创建删除文件，添加几行，删除几行，由于刚才添加`hello you`这一行文字的修改操作并未添加至暂存区，提交时只提交暂存区有的操作，因此该操作未提交至仓库。\n\n\n\n### 版本回退\n\n上面i讲到，Git管理的是修改，如果我们在进行修改提交的过程中，不小心删除了最后一行`hello me` ，而我们又需要这行文字该怎么办呢？\n\n这时候就需要利用版本回退的功能了。\n\n在Git中，我们可以查看每次操作的记录\n\n```bash\n~/CS61A$ git log --pretty=oneline\naa03a474011bcb97e9f596d3b5c9a1b517726d05 (HEAD -> master) delete a line\n05491fda20edff579daf14f24b7afed61d591842 add a line\na58d42838b1284034c4a9d52f0d2780ad251bda2 a\nf67db85d1deeb3d7ca0020a332ac4e07bccf12b0 all\nb96112ab41f972a9949e213347d7403dd2f8a03b 1\n```\n\n我们要将版本回退到`delete a line`操作前，因此我们使用`reset`指令\n\n```bash\n~/CS61A$ git reset --hard HEAD^\nHEAD is now at 05491fd add a line\n```\n\n这里的HEAD^表示上一个版本，如果上两个版本则为^^,以此类推。\n\n但是问题来了，如果我们现在又想回到`delete a line`版本该怎么办呢？版本已经回退了。\n\ngit有一个命令记录了你的每次命令\n\n```bash\n~/CS61A$ git reflog\n05491fd (HEAD -> master) HEAD@{0}: reset: moving to HEAD^\naa03a47 HEAD@{1}: commit: delete a line\n05491fd (HEAD -> master) HEAD@{2}: commit: add a line\n```\n\n于是我们就可以利用`aa03a47`这个id来回到原来版本。\n\n```bash\ngit reset --hard aa03a47\nHEAD is now at aa03a47 delete a line\n```\n\n于是，版本又回来了。\n\n\n\n### 修改撤销\n\n有的时候我们会因为手抖写错代码，比如我们在Read.txt（.sh）文件中添加一行‘rm -rf’，懂点Linux都知道这是个致命操作。\n\n**如果你还没有将这次文件修改提交到暂存区**，那么很简单，直接修改就好了，或者也可以使用指令\n\n```bash\ngit checkout -- Read.txt\n```\n\n工作区的修改就被丢弃了，工作区文件的内容和版本库文件的内容相同。\n\n**如果你已经将文件修改添加到了暂存区**，那么我们需要使用另一个指令\n\n```bash\ngit reset HEAD Read.txt\n```\n\nreset指令不仅可以回退版本，当HEAD不^时，reset指令也可以将暂存区的修改操作移除，而后再利用`checkout`指令同步版本库和工作区内容。\n\n**如果你已经将修改提交到了版本库**，那么按照版本回退的方式进行即可\n\n```\ngit reset --hard HEAD^\n```\n\n如果你已经将版本库内的内容推送到远程库，比如Github，那就只能听天由命了，谁运行，谁遭殃。\n\n\n\n## 远程库连接\n\n************\n\n### 远程库添加/解除\n\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库\n\n（图借的廖雪峰大L的）：\n\n![github-create-repo-1](https://i.loli.net/2021/05/28/HYRADbO3nfjtW9T.png)\n\n在Repository name填入`Read`，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![github-create-repo-2](https://i.loli.net/2021/05/28/P62pheNWtkZSVcB.png)\n\n而后，我们在本地运行命令\n\n```bash\n git remote add origin git@github.com:xxxx/Read.git\n```\n\nxxx处为你自己的Github账户名，就可以将本地的版本库和远程的库连接起来了。\n\n将本地库所有内容推送至Github远程库的master分支。\n\n````\ngit push （-u） origin master\n````\n\n加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令，不许需要加入-u参数。\n\n\n\n**SSH警告**\n\n当你第一次使用Git的`clone`或者`push`命令连接GitHub时，会得到一个警告：\n\n```\nThe authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.\nRSA key fingerprint is xx.xx.xx.xx.xx.\nAre you sure you want to continue connecting (yes/no)?\n```\n\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入`yes`回车即可。\n\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\n\n```\nWarning: Permanently added 'github.com' (RSA) to the list of known hosts.\n```\n\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n\n如果你实在担心有人冒充GitHub服务器，输入`yes`前可以对照[GitHub的RSA Key的指纹信息](https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/)是否与SSH连接给出的一致。\n\n\n\n**解除远程库与本地库的关联关系**\n\n如果我们需要解除本地库与远程库的关联关系，可以使用命令\n\n```bash\ngit remote rm origin\n```\n\n\n\n### 远程库克隆\n\n我们有时需要把远程库从Github克隆下来，为了借鉴代码或是进行分布式工作，使用以下指令将远程库克隆至本地\n\n```bash\ngit clone git@github.com:xxx/Read.git\n```\n\n\n\n## 分支管理 \n\n*********\n\n### 创建与合并分支\n\n在[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。\n\n![git-br-initial](https://i.loli.net/2021/05/28/X69umbEgxRBfh3w.png)\n\n当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上\n\n![git-br-create](https://i.loli.net/2021/05/28/EXNTRAfMmV2B63a.png)\n\n我们建立一个新分支`dev`并切换至新分支\n\n```bash\ngit checkout -b dev    /   git switch -c dev\n```\n\n*如果切换至已有分支则*\n\n```bash\ngit checkout dev    /    git switch dev\n```\n\n如果只是创建分支\n\n```bash\ngit branch dev\n```\n\n从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：\n\n![git-br-dev-fd](https://www.liaoxuefeng.com/files/attachments/919022387118368/l)\n\n假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：\n\n![git-br-ff-merge](https://i.loli.net/2021/05/28/dQuX31cxi6RTeDO.png)\n\n我们切换至主分支，而后将dev分支合并至主分支master\n\n```\ngit checkout master\ngit merge dev\n```\n\n而后我们可以保留分支，也可以删除分支，如果删除分支\n\n```\ngit branch -d dev\n```\n\n\n\n### 多人协作\n\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n首先，`master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n那在哪干活呢？干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如1.0版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布1.0版本；\n\n你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n\n![git-br-policy](https://i.loli.net/2021/05/28/tWO9ydfr5miY3EP.png)\n\n**远程库克隆**\n\n团队合作的过程中首先要将远程库克隆至本地，具体方式见前文远程库克隆一节\n\n完成克隆后，Git自动把本地的master分支和远程的master分支对应起来了，默认远程仓库的名称为origin\n\n查看远程库的信息\n\n```bash\n~/CS61A$ git remote -v\norigin\tgit@github.com:x/CS61A.git (fetch)\norigin\tgit@github.com:x/CS61A.git (push)\n```\n\n上面显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址。\n\n\n\n**分支的推送**\n\n分支的推送有很多种模式，这里只介绍最简单的模式，假设，我们已经将远程库的master分支克隆到了本地，而后我们创建了一个新的分支dev，在新的分支进行工作，工作完毕后我们将dev分支合并至master分支，而后使用\n\n```\ngit push origin master\n```\n\n就将该分支推送到了远程库\n\n\n\n**分支的抓取**\n\n在多人协作时可能会出现一些问题，比如有一天，你的小伙伴已经向origin/master分支推送了他的提交，而你碰巧也对同样的文件进行了修改，并试图推送，这时候你会发现，git提示推送失败，因为你的小伙伴的最新提交和你的提交有冲突。\n\n因此我们要在推送前先将master最新情况从远程抓下来，然后在本地进行合并和解决冲突。\n\n解决冲突的方法如下\n\n我们知道当我们把远程的master分支抓取下来后，我们本地的dev分支和远程pull下来的master分支存在冲突\n\n![git-br-feature1](https://i.loli.net/2021/05/28/ve3HlyfWtqB7bYN.png)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并会有冲突，我们查看 一下git的状态\n\n```bash\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   Read.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n```\n\nGit告诉我们，Read.txt文件存在冲突，我们可以直接查看文件内容\n\n```txt\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> dev\n```\n\nGit用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，我们修改如下后保存：\n\n```\nCreating a new branch is quick and simple.\n```\n\n```\nCreating a new branch is quick and simple.\n```\n\n再提交修改给master分支\n\n```bash\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n[master cf810e4] conflict fixed\n```\n\nGit告诉我们冲突被解决了，于是我们将dev分支合并至master，而后执行push\n\n```bash\ngit push origin master\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo github.com:x/Read.git\n   7a5e5dd..57c53ab  master -> master\n```\n\n成功。\n\n\n\n## 标签管理\n\n为什么需要标签？\n\nGit有commit，为什么还要引入tag？\n\n“请把上周一的那个版本打包发布，commit号是6a5819e...”\n\n“一串乱七八糟的数字不好找！”\n\n如果换一个办法：\n\n“请把上周一的那个版本打包发布，版本号是v1.2”\n\n“好的，按照tag v1.2查找commit就行！”\n\n所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n\n### 创建标签\n\n在Git中打标签非常简单，首先，切换到需要打标签的分支上，而后敲击tag就可以打一个标签\n\n```bash\ngit tag v1.0\n```\n\n利用`git tag`查看所有标签\n\n```bash\n$ git tag\nv1.0\nv2.0\nv2.1\n```\n\n如果要对历史commit打标签，那就通过git log找到commit号\n\n```bash\ngit tag v0.9 f287d34\n```\n\n查看每个标签的信息\n\n```bash\n$ git show v0.9\ncommit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:56:54 2018 +0800\n\n    add merge\n\ndiff --git a/readme.txt b/readme.txt\n...\n```\n\n然后按照版本回退一节的方法使用`reset`指令回退至对应版本打包即可。\n\n注意，标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n\n\n\n### 操作标签\n\n如果标签打错了，也可以删除：\n\n```bash\n$ git tag -d v0.1\nDeleted tag 'v0.1' (was f15b0dd)\n```\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令`git push origin <tagname>`，或使用`git push origin --tags`推送所有标签。\n\n如果要删除远程标签则先从本地删除标签，而后向远程同步删除指令\n\n```bash\n$ git push origin :refs/tags/v0.9\nTo github.com:x/Read.gi0t\n - [deleted]         v0.9\n```\n\n\n\n## 参考\n\n1.[菜鸟教程Git](https://www.runoob.com/git/git-tutorial.html)\n\n2.[廖雪峰的Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n3.[Git官方网站](https://git-scm.com/)\n\n","source":"_posts/简明Git使用方法.md","raw":"---\ntitle: 简明Git使用方法\ndate: 2021-05-27 15:37:40\ntags: \n- Git\ncategories: \n- Guide\ncover: /myimage/doc/git_cover.png\n---\n\n近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的\n\n## 目录\n\n>版本库的创建\n>\n>*  Git的安装\n>*  版本库的创建\n>\n>版本库的操作\n>\n>*  文件操作\n>*  版本回退\n>*  修改撤销 \n>\n>远程库连接\n>\n>* 远程库添加与解除\n>* 从远程库克隆\n>\n>分支管理\n>\n>* 创建与合并分支\n>* 多人协作\n>\n>标签管理\n>\n>* 创建标签\n>* 操作标签\n>\n\n## 版本库的创建\n\n******\n\n### Git的安装\n\n在Ubuntu Linux上使用apt软件包管理工具进行安装\n\n``` bash\nsudo apt-get install git\n```\n\n在windows上直接进入[Git官网](https://git-scm.com/downloads)下载安装程序，而后按照默认选项安装即可\n\n\n\n### 版本库的创建\n\n选择一个合适的位置利用mkdir指令创建一个空目录，而后进入后输入指令\n\n```bash\ngit init\n```\n\n于是该目录就变成了Git可以管理的仓库，细心的读者可以发现当前目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n\n\n## 版本库的操作\n\n*******\n\n### 文件操作\n\n在文件操作之前首先明确几个概念\n\n**工作区**\n\n就是电脑中能直接看见的目录\n\n![working-dir](https://i.loli.net/2021/05/28/Vc1mn4w6MZIaRSB.png)\n\n**版本库**\n\n工作区目录中有一个隐藏目录.git。这个是Git的版本库，版本库主要由两个部分组成，stage暂存区和分支区。\n\n![git-repo](https://i.loli.net/2021/05/28/nzqcBheNH58kMAG.jpg)\n\n **将文件添加至Git版本库中时，有三个步骤：**\n\n**首先**在工作区创建一个文件Read.txt\n\n```bash\nvim/typora Read.txt\n```\n\n将文件修改添加至暂存区，在添加至暂存区前，我们首先看一下git的状态\n\n```bash\n~/CS61A$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tRead.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\n```\n\nGit清楚的告诉我们，有一个文件出现了，而`Read.txt`还从来没有被添加过，所以它的状态是`Untracked`。\n\n**而后**我们创建文件这次操作添加至暂存区\n\n```bash\ngit add Read.txt\n```\n\n*如果添加的是文件夹可以使用*\n\n```bash\ngit add vs/*\n```\n\n如果想删除文件可以用\n\n````bash\ngit rm Read.txt\n````\n\n再次查看git的状态\n\n```bash\n~/CS61A$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tnew file:   Read.txt\n\n```\n\n`Changes to be committed`我们发现git已经识别了这个文件，可见这个文件已经被添加到了暂存区。\n\n**最后**我们将文件创建这次操作提交至仓库的master分支（分支的概念后面会讲到）\n\n```bash\ngit commit Read.txt -m \"commit\"\n```\n\n*如果想提交全部文件的操作可以用*\n\n```bash\ngit commit -m \"commit\"\n```\n\n这里的-m参数是对这次提交进行文字说明\n\n再次查看git的状态\n\n```bash\n~/CS61A$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\n```\n\n可见此时暂存区为空，修改已提交至仓库\n\n我们可以将创建文件并提交至仓库的过程用流程图表示\n\n```mermaid\ngraph LR\nA[在工作区创建文件]===>B[将修改/创建/删除操作添加至暂存区]====>C[将操作提交至仓库]\n```\n\n估计很多人都有疑问，为什么这里写的是操作，而不是将文件添加至暂存区，因为Git管理的是修改而不是文件，我们用一个例子来说明这个问题。\n\n首先，我们在Read.txt中添加一段文字`hello me`，而后将这次操作添加到暂存区，我们查看此时的状态\n\n```bash\nit status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   Read.txt\n\n```\n\n可见此次修改已经添加到了暂存区，而后我们再对文件进行修改，增加一行`hello you`，不将此次修改添加至暂存区。\n\n```bash\ngit status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   Read.txt\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   Read.txt\n\n```\n\n我们执行提交指令将修改提交至仓库，而后查看git状态\n\n```bash\ngit status\nOn branch master\nYour branch is ahead of 'origin/master' by 8 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   Read.txt\n\n\n```\n\n我们发现，未添加至暂存区的修改并未提交至仓库，我们查看一下工作区和最新版本库的区别\n\n```bash\n~/CS61A$ git diff -- Read.txt\ndiff --git a/Read.txt b/Read.txt\nindex 1f8eec4..12ee40e 100644\n--- a/Read.txt\n+++ b/Read.txt\n@@ -1,2 +1,3 @@\n hello world\n hello me\n+hello you\n```\n\n如果Git管理的是文件本身，那么文件在提交时是什么样，提交的文件就是什么样，然而经过对比发现，版本库的文件和工作区的文件是不一样，我们每次添加到暂存区的是对文件的操作步骤，比如创建删除文件，添加几行，删除几行，由于刚才添加`hello you`这一行文字的修改操作并未添加至暂存区，提交时只提交暂存区有的操作，因此该操作未提交至仓库。\n\n\n\n### 版本回退\n\n上面i讲到，Git管理的是修改，如果我们在进行修改提交的过程中，不小心删除了最后一行`hello me` ，而我们又需要这行文字该怎么办呢？\n\n这时候就需要利用版本回退的功能了。\n\n在Git中，我们可以查看每次操作的记录\n\n```bash\n~/CS61A$ git log --pretty=oneline\naa03a474011bcb97e9f596d3b5c9a1b517726d05 (HEAD -> master) delete a line\n05491fda20edff579daf14f24b7afed61d591842 add a line\na58d42838b1284034c4a9d52f0d2780ad251bda2 a\nf67db85d1deeb3d7ca0020a332ac4e07bccf12b0 all\nb96112ab41f972a9949e213347d7403dd2f8a03b 1\n```\n\n我们要将版本回退到`delete a line`操作前，因此我们使用`reset`指令\n\n```bash\n~/CS61A$ git reset --hard HEAD^\nHEAD is now at 05491fd add a line\n```\n\n这里的HEAD^表示上一个版本，如果上两个版本则为^^,以此类推。\n\n但是问题来了，如果我们现在又想回到`delete a line`版本该怎么办呢？版本已经回退了。\n\ngit有一个命令记录了你的每次命令\n\n```bash\n~/CS61A$ git reflog\n05491fd (HEAD -> master) HEAD@{0}: reset: moving to HEAD^\naa03a47 HEAD@{1}: commit: delete a line\n05491fd (HEAD -> master) HEAD@{2}: commit: add a line\n```\n\n于是我们就可以利用`aa03a47`这个id来回到原来版本。\n\n```bash\ngit reset --hard aa03a47\nHEAD is now at aa03a47 delete a line\n```\n\n于是，版本又回来了。\n\n\n\n### 修改撤销\n\n有的时候我们会因为手抖写错代码，比如我们在Read.txt（.sh）文件中添加一行‘rm -rf’，懂点Linux都知道这是个致命操作。\n\n**如果你还没有将这次文件修改提交到暂存区**，那么很简单，直接修改就好了，或者也可以使用指令\n\n```bash\ngit checkout -- Read.txt\n```\n\n工作区的修改就被丢弃了，工作区文件的内容和版本库文件的内容相同。\n\n**如果你已经将文件修改添加到了暂存区**，那么我们需要使用另一个指令\n\n```bash\ngit reset HEAD Read.txt\n```\n\nreset指令不仅可以回退版本，当HEAD不^时，reset指令也可以将暂存区的修改操作移除，而后再利用`checkout`指令同步版本库和工作区内容。\n\n**如果你已经将修改提交到了版本库**，那么按照版本回退的方式进行即可\n\n```\ngit reset --hard HEAD^\n```\n\n如果你已经将版本库内的内容推送到远程库，比如Github，那就只能听天由命了，谁运行，谁遭殃。\n\n\n\n## 远程库连接\n\n************\n\n### 远程库添加/解除\n\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库\n\n（图借的廖雪峰大L的）：\n\n![github-create-repo-1](https://i.loli.net/2021/05/28/HYRADbO3nfjtW9T.png)\n\n在Repository name填入`Read`，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![github-create-repo-2](https://i.loli.net/2021/05/28/P62pheNWtkZSVcB.png)\n\n而后，我们在本地运行命令\n\n```bash\n git remote add origin git@github.com:xxxx/Read.git\n```\n\nxxx处为你自己的Github账户名，就可以将本地的版本库和远程的库连接起来了。\n\n将本地库所有内容推送至Github远程库的master分支。\n\n````\ngit push （-u） origin master\n````\n\n加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令，不许需要加入-u参数。\n\n\n\n**SSH警告**\n\n当你第一次使用Git的`clone`或者`push`命令连接GitHub时，会得到一个警告：\n\n```\nThe authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.\nRSA key fingerprint is xx.xx.xx.xx.xx.\nAre you sure you want to continue connecting (yes/no)?\n```\n\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入`yes`回车即可。\n\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\n\n```\nWarning: Permanently added 'github.com' (RSA) to the list of known hosts.\n```\n\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n\n如果你实在担心有人冒充GitHub服务器，输入`yes`前可以对照[GitHub的RSA Key的指纹信息](https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/)是否与SSH连接给出的一致。\n\n\n\n**解除远程库与本地库的关联关系**\n\n如果我们需要解除本地库与远程库的关联关系，可以使用命令\n\n```bash\ngit remote rm origin\n```\n\n\n\n### 远程库克隆\n\n我们有时需要把远程库从Github克隆下来，为了借鉴代码或是进行分布式工作，使用以下指令将远程库克隆至本地\n\n```bash\ngit clone git@github.com:xxx/Read.git\n```\n\n\n\n## 分支管理 \n\n*********\n\n### 创建与合并分支\n\n在[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。\n\n![git-br-initial](https://i.loli.net/2021/05/28/X69umbEgxRBfh3w.png)\n\n当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上\n\n![git-br-create](https://i.loli.net/2021/05/28/EXNTRAfMmV2B63a.png)\n\n我们建立一个新分支`dev`并切换至新分支\n\n```bash\ngit checkout -b dev    /   git switch -c dev\n```\n\n*如果切换至已有分支则*\n\n```bash\ngit checkout dev    /    git switch dev\n```\n\n如果只是创建分支\n\n```bash\ngit branch dev\n```\n\n从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：\n\n![git-br-dev-fd](https://www.liaoxuefeng.com/files/attachments/919022387118368/l)\n\n假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：\n\n![git-br-ff-merge](https://i.loli.net/2021/05/28/dQuX31cxi6RTeDO.png)\n\n我们切换至主分支，而后将dev分支合并至主分支master\n\n```\ngit checkout master\ngit merge dev\n```\n\n而后我们可以保留分支，也可以删除分支，如果删除分支\n\n```\ngit branch -d dev\n```\n\n\n\n### 多人协作\n\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n首先，`master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n那在哪干活呢？干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如1.0版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布1.0版本；\n\n你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n\n![git-br-policy](https://i.loli.net/2021/05/28/tWO9ydfr5miY3EP.png)\n\n**远程库克隆**\n\n团队合作的过程中首先要将远程库克隆至本地，具体方式见前文远程库克隆一节\n\n完成克隆后，Git自动把本地的master分支和远程的master分支对应起来了，默认远程仓库的名称为origin\n\n查看远程库的信息\n\n```bash\n~/CS61A$ git remote -v\norigin\tgit@github.com:x/CS61A.git (fetch)\norigin\tgit@github.com:x/CS61A.git (push)\n```\n\n上面显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址。\n\n\n\n**分支的推送**\n\n分支的推送有很多种模式，这里只介绍最简单的模式，假设，我们已经将远程库的master分支克隆到了本地，而后我们创建了一个新的分支dev，在新的分支进行工作，工作完毕后我们将dev分支合并至master分支，而后使用\n\n```\ngit push origin master\n```\n\n就将该分支推送到了远程库\n\n\n\n**分支的抓取**\n\n在多人协作时可能会出现一些问题，比如有一天，你的小伙伴已经向origin/master分支推送了他的提交，而你碰巧也对同样的文件进行了修改，并试图推送，这时候你会发现，git提示推送失败，因为你的小伙伴的最新提交和你的提交有冲突。\n\n因此我们要在推送前先将master最新情况从远程抓下来，然后在本地进行合并和解决冲突。\n\n解决冲突的方法如下\n\n我们知道当我们把远程的master分支抓取下来后，我们本地的dev分支和远程pull下来的master分支存在冲突\n\n![git-br-feature1](https://i.loli.net/2021/05/28/ve3HlyfWtqB7bYN.png)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并会有冲突，我们查看 一下git的状态\n\n```bash\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   Read.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n```\n\nGit告诉我们，Read.txt文件存在冲突，我们可以直接查看文件内容\n\n```txt\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> dev\n```\n\nGit用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，我们修改如下后保存：\n\n```\nCreating a new branch is quick and simple.\n```\n\n```\nCreating a new branch is quick and simple.\n```\n\n再提交修改给master分支\n\n```bash\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n[master cf810e4] conflict fixed\n```\n\nGit告诉我们冲突被解决了，于是我们将dev分支合并至master，而后执行push\n\n```bash\ngit push origin master\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo github.com:x/Read.git\n   7a5e5dd..57c53ab  master -> master\n```\n\n成功。\n\n\n\n## 标签管理\n\n为什么需要标签？\n\nGit有commit，为什么还要引入tag？\n\n“请把上周一的那个版本打包发布，commit号是6a5819e...”\n\n“一串乱七八糟的数字不好找！”\n\n如果换一个办法：\n\n“请把上周一的那个版本打包发布，版本号是v1.2”\n\n“好的，按照tag v1.2查找commit就行！”\n\n所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n\n### 创建标签\n\n在Git中打标签非常简单，首先，切换到需要打标签的分支上，而后敲击tag就可以打一个标签\n\n```bash\ngit tag v1.0\n```\n\n利用`git tag`查看所有标签\n\n```bash\n$ git tag\nv1.0\nv2.0\nv2.1\n```\n\n如果要对历史commit打标签，那就通过git log找到commit号\n\n```bash\ngit tag v0.9 f287d34\n```\n\n查看每个标签的信息\n\n```bash\n$ git show v0.9\ncommit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:56:54 2018 +0800\n\n    add merge\n\ndiff --git a/readme.txt b/readme.txt\n...\n```\n\n然后按照版本回退一节的方法使用`reset`指令回退至对应版本打包即可。\n\n注意，标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n\n\n\n### 操作标签\n\n如果标签打错了，也可以删除：\n\n```bash\n$ git tag -d v0.1\nDeleted tag 'v0.1' (was f15b0dd)\n```\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令`git push origin <tagname>`，或使用`git push origin --tags`推送所有标签。\n\n如果要删除远程标签则先从本地删除标签，而后向远程同步删除指令\n\n```bash\n$ git push origin :refs/tags/v0.9\nTo github.com:x/Read.gi0t\n - [deleted]         v0.9\n```\n\n\n\n## 参考\n\n1.[菜鸟教程Git](https://www.runoob.com/git/git-tutorial.html)\n\n2.[廖雪峰的Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n3.[Git官方网站](https://git-scm.com/)\n\n","slug":"简明Git使用方法","published":1,"updated":"2023-02-11T11:41:17.175Z","_id":"ckp7s7zru0000hjrh9lrc508u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><blockquote>\n<p>版本库的创建</p>\n<ul>\n<li> Git的安装</li>\n<li> 版本库的创建</li>\n</ul>\n<p>版本库的操作</p>\n<ul>\n<li> 文件操作</li>\n<li> 版本回退</li>\n<li> 修改撤销 </li>\n</ul>\n<p>远程库连接</p>\n<ul>\n<li>远程库添加与解除</li>\n<li>从远程库克隆</li>\n</ul>\n<p>分支管理</p>\n<ul>\n<li>创建与合并分支</li>\n<li>多人协作</li>\n</ul>\n<p>标签管理</p>\n<ul>\n<li>创建标签</li>\n<li>操作标签</li>\n</ul>\n</blockquote>\n<h2 id=\"版本库的创建\"><a href=\"#版本库的创建\" class=\"headerlink\" title=\"版本库的创建\"></a>版本库的创建</h2><hr>\n<h3 id=\"Git的安装\"><a href=\"#Git的安装\" class=\"headerlink\" title=\"Git的安装\"></a>Git的安装</h3><p>在Ubuntu Linux上使用apt软件包管理工具进行安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<p>在windows上直接进入<a href=\"https://git-scm.com/downloads\">Git官网</a>下载安装程序，而后按照默认选项安装即可</p>\n<h3 id=\"版本库的创建-1\"><a href=\"#版本库的创建-1\" class=\"headerlink\" title=\"版本库的创建\"></a>版本库的创建</h3><p>选择一个合适的位置利用mkdir指令创建一个空目录，而后进入后输入指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>于是该目录就变成了Git可以管理的仓库，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>\n<h2 id=\"版本库的操作\"><a href=\"#版本库的操作\" class=\"headerlink\" title=\"版本库的操作\"></a>版本库的操作</h2><hr>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><p>在文件操作之前首先明确几个概念</p>\n<p><strong>工作区</strong></p>\n<p>就是电脑中能直接看见的目录</p>\n<p><img src=\"https://i.loli.net/2021/05/28/Vc1mn4w6MZIaRSB.png\" alt=\"working-dir\"></p>\n<p><strong>版本库</strong></p>\n<p>工作区目录中有一个隐藏目录.git。这个是Git的版本库，版本库主要由两个部分组成，stage暂存区和分支区。</p>\n<p><img src=\"https://i.loli.net/2021/05/28/nzqcBheNH58kMAG.jpg\" alt=\"git-repo\"></p>\n<p> <strong>将文件添加至Git版本库中时，有三个步骤：</strong></p>\n<p><strong>首先</strong>在工作区创建一个文件Read.txt</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim/typora Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>将文件修改添加至暂存区，在添加至暂存区前，我们首先看一下git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to include <span class=\"keyword\">in</span> what will be committed)</span><br><span class=\"line\">\tRead.txt</span><br><span class=\"line\"></span><br><span class=\"line\">nothing added to commit but untracked files present (use <span class=\"string\">&quot;git add&quot;</span> to track)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Git清楚的告诉我们，有一个文件出现了，而<code>Read.txt</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>\n<p><strong>而后</strong>我们创建文件这次操作添加至暂存区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add Read.txt</span><br></pre></td></tr></table></figure>\n\n<p><em>如果添加的是文件夹可以使用</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add vs/*</span><br></pre></td></tr></table></figure>\n\n<p>如果想删除文件可以用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>再次查看git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\">\tnew file:   Read.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>Changes to be committed</code>我们发现git已经识别了这个文件，可见这个文件已经被添加到了暂存区。</p>\n<p><strong>最后</strong>我们将文件创建这次操作提交至仓库的master分支（分支的概念后面会讲到）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit Read.txt -m <span class=\"string\">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>如果想提交全部文件的操作可以用</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的-m参数是对这次提交进行文字说明</p>\n<p>再次查看git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">nothing to commit, working tree clean</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可见此时暂存区为空，修改已提交至仓库</p>\n<p>我们可以将创建文件并提交至仓库的过程用流程图表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[在工作区创建文件]&#x3D;&#x3D;&#x3D;&gt;B[将修改&#x2F;创建&#x2F;删除操作添加至暂存区]&#x3D;&#x3D;&#x3D;&#x3D;&gt;C[将操作提交至仓库]</span><br></pre></td></tr></table></figure>\n\n<p>估计很多人都有疑问，为什么这里写的是操作，而不是将文件添加至暂存区，因为Git管理的是修改而不是文件，我们用一个例子来说明这个问题。</p>\n<p>首先，我们在Read.txt中添加一段文字<code>hello me</code>，而后将这次操作添加到暂存区，我们查看此时的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可见此次修改已经添加到了暂存区，而后我们再对文件进行修改，增加一行<code>hello you</code>，不将此次修改添加至暂存区。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们执行提交指令将修改提交至仓库，而后查看git状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 8 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，未添加至暂存区的修改并未提交至仓库，我们查看一下工作区和最新版本库的区别</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git diff -- Read.txt</span><br><span class=\"line\">diff --git a/Read.txt b/Read.txt</span><br><span class=\"line\">index 1f8eec4..12ee40e 100644</span><br><span class=\"line\">--- a/Read.txt</span><br><span class=\"line\">+++ b/Read.txt</span><br><span class=\"line\">@@ -1,2 +1,3 @@</span><br><span class=\"line\"> hello world</span><br><span class=\"line\"> hello me</span><br><span class=\"line\">+hello you</span><br></pre></td></tr></table></figure>\n\n<p>如果Git管理的是文件本身，那么文件在提交时是什么样，提交的文件就是什么样，然而经过对比发现，版本库的文件和工作区的文件是不一样，我们每次添加到暂存区的是对文件的操作步骤，比如创建删除文件，添加几行，删除几行，由于刚才添加<code>hello you</code>这一行文字的修改操作并未添加至暂存区，提交时只提交暂存区有的操作，因此该操作未提交至仓库。</p>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><p>上面i讲到，Git管理的是修改，如果我们在进行修改提交的过程中，不小心删除了最后一行<code>hello me</code> ，而我们又需要这行文字该怎么办呢？</p>\n<p>这时候就需要利用版本回退的功能了。</p>\n<p>在Git中，我们可以查看每次操作的记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git <span class=\"built_in\">log</span> --pretty=oneline</span><br><span class=\"line\">aa03a474011bcb97e9f596d3b5c9a1b517726d05 (HEAD -&gt; master) delete a line</span><br><span class=\"line\">05491fda20edff579daf14f24b7afed61d591842 add a line</span><br><span class=\"line\">a58d42838b1284034c4a9d52f0d2780ad251bda2 a</span><br><span class=\"line\">f67db85d1deeb3d7ca0020a332ac4e07bccf12b0 all</span><br><span class=\"line\">b96112ab41f972a9949e213347d7403dd2f8a03b 1</span><br></pre></td></tr></table></figure>\n\n<p>我们要将版本回退到<code>delete a line</code>操作前，因此我们使用<code>reset</code>指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git reset --hard HEAD^</span><br><span class=\"line\">HEAD is now at 05491fd add a line</span><br></pre></td></tr></table></figure>\n\n<p>这里的HEAD^表示上一个版本，如果上两个版本则为^^,以此类推。</p>\n<p>但是问题来了，如果我们现在又想回到<code>delete a line</code>版本该怎么办呢？版本已经回退了。</p>\n<p>git有一个命令记录了你的每次命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git reflog</span><br><span class=\"line\">05491fd (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class=\"line\">aa03a47 HEAD@&#123;1&#125;: commit: delete a line</span><br><span class=\"line\">05491fd (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add a line</span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以利用<code>aa03a47</code>这个id来回到原来版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard aa03a47</span><br><span class=\"line\">HEAD is now at aa03a47 delete a line</span><br></pre></td></tr></table></figure>\n\n<p>于是，版本又回来了。</p>\n<h3 id=\"修改撤销\"><a href=\"#修改撤销\" class=\"headerlink\" title=\"修改撤销\"></a>修改撤销</h3><p>有的时候我们会因为手抖写错代码，比如我们在Read.txt（.sh）文件中添加一行‘rm -rf’，懂点Linux都知道这是个致命操作。</p>\n<p><strong>如果你还没有将这次文件修改提交到暂存区</strong>，那么很简单，直接修改就好了，或者也可以使用指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>工作区的修改就被丢弃了，工作区文件的内容和版本库文件的内容相同。</p>\n<p><strong>如果你已经将文件修改添加到了暂存区</strong>，那么我们需要使用另一个指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>reset指令不仅可以回退版本，当HEAD不^时，reset指令也可以将暂存区的修改操作移除，而后再利用<code>checkout</code>指令同步版本库和工作区内容。</p>\n<p><strong>如果你已经将修改提交到了版本库</strong>，那么按照版本回退的方式进行即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n\n<p>如果你已经将版本库内的内容推送到远程库，比如Github，那就只能听天由命了，谁运行，谁遭殃。</p>\n<h2 id=\"远程库连接\"><a href=\"#远程库连接\" class=\"headerlink\" title=\"远程库连接\"></a>远程库连接</h2><hr>\n<h3 id=\"远程库添加-解除\"><a href=\"#远程库添加-解除\" class=\"headerlink\" title=\"远程库添加/解除\"></a>远程库添加/解除</h3><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>\n<p>（图借的廖雪峰大L的）：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/HYRADbO3nfjtW9T.png\" alt=\"github-create-repo-1\"></p>\n<p>在Repository name填入<code>Read</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/P62pheNWtkZSVcB.png\" alt=\"github-create-repo-2\"></p>\n<p>而后，我们在本地运行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:xxxx/Read.git</span><br></pre></td></tr></table></figure>\n\n<p>xxx处为你自己的Github账户名，就可以将本地的版本库和远程的库连接起来了。</p>\n<p>将本地库所有内容推送至Github远程库的master分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push （-u） origin master</span><br></pre></td></tr></table></figure>\n\n<p>加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令，不许需要加入-u参数。</p>\n<p><strong>SSH警告</strong></p>\n<p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.</span><br><span class=\"line\">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>\n\n<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>\n<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>\n\n<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>\n<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href=\"https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/\">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>\n<p><strong>解除远程库与本地库的关联关系</strong></p>\n<p>如果我们需要解除本地库与远程库的关联关系，可以使用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"远程库克隆\"><a href=\"#远程库克隆\" class=\"headerlink\" title=\"远程库克隆\"></a>远程库克隆</h3><p>我们有时需要把远程库从Github克隆下来，为了借鉴代码或是进行分布式工作，使用以下指令将远程库克隆至本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:xxx/Read.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><hr>\n<h3 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h3><p>在<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>\n<p><img src=\"https://i.loli.net/2021/05/28/X69umbEgxRBfh3w.png\" alt=\"git-br-initial\"></p>\n<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p>\n<p><img src=\"https://i.loli.net/2021/05/28/EXNTRAfMmV2B63a.png\" alt=\"git-br-create\"></p>\n<p>我们建立一个新分支<code>dev</code>并切换至新分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev    /   git switch -c dev</span><br></pre></td></tr></table></figure>\n\n<p><em>如果切换至已有分支则</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout dev    /    git switch dev</span><br></pre></td></tr></table></figure>\n\n<p>如果只是创建分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch dev</span><br></pre></td></tr></table></figure>\n\n<p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/919022387118368/l\" alt=\"git-br-dev-fd\"></p>\n<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/dQuX31cxi6RTeDO.png\" alt=\"git-br-ff-merge\"></p>\n<p>我们切换至主分支，而后将dev分支合并至主分支master</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n\n<p>而后我们可以保留分支，也可以删除分支，如果删除分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>\n<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>\n<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>\n<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>\n<p>所以，团队合作的分支看起来就像这样：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/tWO9ydfr5miY3EP.png\" alt=\"git-br-policy\"></p>\n<p><strong>远程库克隆</strong></p>\n<p>团队合作的过程中首先要将远程库克隆至本地，具体方式见前文远程库克隆一节</p>\n<p>完成克隆后，Git自动把本地的master分支和远程的master分支对应起来了，默认远程仓库的名称为origin</p>\n<p>查看远程库的信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git remote -v</span><br><span class=\"line\">origin\tgit@github.com:x/CS61A.git (fetch)</span><br><span class=\"line\">origin\tgit@github.com:x/CS61A.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>\n<p><strong>分支的推送</strong></p>\n<p>分支的推送有很多种模式，这里只介绍最简单的模式，假设，我们已经将远程库的master分支克隆到了本地，而后我们创建了一个新的分支dev，在新的分支进行工作，工作完毕后我们将dev分支合并至master分支，而后使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>就将该分支推送到了远程库</p>\n<p><strong>分支的抓取</strong></p>\n<p>在多人协作时可能会出现一些问题，比如有一天，你的小伙伴已经向origin/master分支推送了他的提交，而你碰巧也对同样的文件进行了修改，并试图推送，这时候你会发现，git提示推送失败，因为你的小伙伴的最新提交和你的提交有冲突。</p>\n<p>因此我们要在推送前先将master最新情况从远程抓下来，然后在本地进行合并和解决冲突。</p>\n<p>解决冲突的方法如下</p>\n<p>我们知道当我们把远程的master分支抓取下来后，我们本地的dev分支和远程pull下来的master分支存在冲突</p>\n<p><img src=\"https://i.loli.net/2021/05/28/ve3HlyfWtqB7bYN.png\" alt=\"git-br-feature1\"></p>\n<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并会有冲突，我们查看 一下git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">You have unmerged paths.</span><br><span class=\"line\">  (fix conflicts and run <span class=\"string\">&quot;git commit&quot;</span>)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class=\"line\"></span><br><span class=\"line\">Unmerged paths:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboth modified:   Read.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Git告诉我们，Read.txt文件存在冲突，我们可以直接查看文件内容</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Git has a mutable index called stage.</span><br><span class=\"line\">Git tracks changes of files.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">=======</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>\n\n<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>\n\n<p>再提交修改给master分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;conflict fixed&quot;</span></span><br><span class=\"line\">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>\n\n<p>Git告诉我们冲突被解决了，于是我们将dev分支合并至master，而后执行push</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br><span class=\"line\">Counting objects: 6, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (4/4), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:x/Read.git</span><br><span class=\"line\">   7a5e5dd..57c53ab  master -&gt; master</span><br></pre></td></tr></table></figure>\n\n<p>成功。</p>\n<h2 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h2><p>为什么需要标签？</p>\n<p>Git有commit，为什么还要引入tag？</p>\n<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>\n<p>“一串乱七八糟的数字不好找！”</p>\n<p>如果换一个办法：</p>\n<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>\n<p>“好的，按照tag v1.2查找commit就行！”</p>\n<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>\n<h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，而后敲击tag就可以打一个标签</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>git tag</code>查看所有标签</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag</span><br><span class=\"line\">v1.0</span><br><span class=\"line\">v2.0</span><br><span class=\"line\">v2.1</span><br></pre></td></tr></table></figure>\n\n<p>如果要对历史commit打标签，那就通过git log找到commit号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v0.9 f287d34</span><br></pre></td></tr></table></figure>\n\n<p>查看每个标签的信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show v0.9</span><br><span class=\"line\">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add merge</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a/readme.txt b/readme.txt</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>然后按照版本回退一节的方法使用<code>reset</code>指令回退至对应版本打包即可。</p>\n<p>注意，标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>\n<h3 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.1</span><br><span class=\"line\">Deleted tag <span class=\"string\">&#x27;v0.1&#x27;</span> (was f15b0dd)</span><br></pre></td></tr></table></figure>\n\n<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或使用<code>git push origin --tags</code>推送所有标签。</p>\n<p>如果要删除远程标签则先从本地删除标签，而后向远程同步删除指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin :refs/tags/v0.9</span><br><span class=\"line\">To github.com:x/Read.gi0t</span><br><span class=\"line\"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>1.<a href=\"https://www.runoob.com/git/git-tutorial.html\">菜鸟教程Git</a></p>\n<p>2.<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的Git教程</a></p>\n<p>3.<a href=\"https://git-scm.com/\">Git官方网站</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":9386,"excerpt":"","more":"<p>近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><blockquote>\n<p>版本库的创建</p>\n<ul>\n<li> Git的安装</li>\n<li> 版本库的创建</li>\n</ul>\n<p>版本库的操作</p>\n<ul>\n<li> 文件操作</li>\n<li> 版本回退</li>\n<li> 修改撤销 </li>\n</ul>\n<p>远程库连接</p>\n<ul>\n<li>远程库添加与解除</li>\n<li>从远程库克隆</li>\n</ul>\n<p>分支管理</p>\n<ul>\n<li>创建与合并分支</li>\n<li>多人协作</li>\n</ul>\n<p>标签管理</p>\n<ul>\n<li>创建标签</li>\n<li>操作标签</li>\n</ul>\n</blockquote>\n<h2 id=\"版本库的创建\"><a href=\"#版本库的创建\" class=\"headerlink\" title=\"版本库的创建\"></a>版本库的创建</h2><hr>\n<h3 id=\"Git的安装\"><a href=\"#Git的安装\" class=\"headerlink\" title=\"Git的安装\"></a>Git的安装</h3><p>在Ubuntu Linux上使用apt软件包管理工具进行安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<p>在windows上直接进入<a href=\"https://git-scm.com/downloads\">Git官网</a>下载安装程序，而后按照默认选项安装即可</p>\n<h3 id=\"版本库的创建-1\"><a href=\"#版本库的创建-1\" class=\"headerlink\" title=\"版本库的创建\"></a>版本库的创建</h3><p>选择一个合适的位置利用mkdir指令创建一个空目录，而后进入后输入指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>于是该目录就变成了Git可以管理的仓库，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>\n<h2 id=\"版本库的操作\"><a href=\"#版本库的操作\" class=\"headerlink\" title=\"版本库的操作\"></a>版本库的操作</h2><hr>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><p>在文件操作之前首先明确几个概念</p>\n<p><strong>工作区</strong></p>\n<p>就是电脑中能直接看见的目录</p>\n<p><img src=\"https://i.loli.net/2021/05/28/Vc1mn4w6MZIaRSB.png\" alt=\"working-dir\"></p>\n<p><strong>版本库</strong></p>\n<p>工作区目录中有一个隐藏目录.git。这个是Git的版本库，版本库主要由两个部分组成，stage暂存区和分支区。</p>\n<p><img src=\"https://i.loli.net/2021/05/28/nzqcBheNH58kMAG.jpg\" alt=\"git-repo\"></p>\n<p> <strong>将文件添加至Git版本库中时，有三个步骤：</strong></p>\n<p><strong>首先</strong>在工作区创建一个文件Read.txt</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim/typora Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>将文件修改添加至暂存区，在添加至暂存区前，我们首先看一下git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to include <span class=\"keyword\">in</span> what will be committed)</span><br><span class=\"line\">\tRead.txt</span><br><span class=\"line\"></span><br><span class=\"line\">nothing added to commit but untracked files present (use <span class=\"string\">&quot;git add&quot;</span> to track)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Git清楚的告诉我们，有一个文件出现了，而<code>Read.txt</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>\n<p><strong>而后</strong>我们创建文件这次操作添加至暂存区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add Read.txt</span><br></pre></td></tr></table></figure>\n\n<p><em>如果添加的是文件夹可以使用</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add vs/*</span><br></pre></td></tr></table></figure>\n\n<p>如果想删除文件可以用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>再次查看git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\">\tnew file:   Read.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>Changes to be committed</code>我们发现git已经识别了这个文件，可见这个文件已经被添加到了暂存区。</p>\n<p><strong>最后</strong>我们将文件创建这次操作提交至仓库的master分支（分支的概念后面会讲到）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit Read.txt -m <span class=\"string\">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>如果想提交全部文件的操作可以用</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的-m参数是对这次提交进行文字说明</p>\n<p>再次查看git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">nothing to commit, working tree clean</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可见此时暂存区为空，修改已提交至仓库</p>\n<p>我们可以将创建文件并提交至仓库的过程用流程图表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[在工作区创建文件]&#x3D;&#x3D;&#x3D;&gt;B[将修改&#x2F;创建&#x2F;删除操作添加至暂存区]&#x3D;&#x3D;&#x3D;&#x3D;&gt;C[将操作提交至仓库]</span><br></pre></td></tr></table></figure>\n\n<p>估计很多人都有疑问，为什么这里写的是操作，而不是将文件添加至暂存区，因为Git管理的是修改而不是文件，我们用一个例子来说明这个问题。</p>\n<p>首先，我们在Read.txt中添加一段文字<code>hello me</code>，而后将这次操作添加到暂存区，我们查看此时的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可见此次修改已经添加到了暂存区，而后我们再对文件进行修改，增加一行<code>hello you</code>，不将此次修改添加至暂存区。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们执行提交指令将修改提交至仓库，而后查看git状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 8 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\">\tmodified:   Read.txt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，未添加至暂存区的修改并未提交至仓库，我们查看一下工作区和最新版本库的区别</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git diff -- Read.txt</span><br><span class=\"line\">diff --git a/Read.txt b/Read.txt</span><br><span class=\"line\">index 1f8eec4..12ee40e 100644</span><br><span class=\"line\">--- a/Read.txt</span><br><span class=\"line\">+++ b/Read.txt</span><br><span class=\"line\">@@ -1,2 +1,3 @@</span><br><span class=\"line\"> hello world</span><br><span class=\"line\"> hello me</span><br><span class=\"line\">+hello you</span><br></pre></td></tr></table></figure>\n\n<p>如果Git管理的是文件本身，那么文件在提交时是什么样，提交的文件就是什么样，然而经过对比发现，版本库的文件和工作区的文件是不一样，我们每次添加到暂存区的是对文件的操作步骤，比如创建删除文件，添加几行，删除几行，由于刚才添加<code>hello you</code>这一行文字的修改操作并未添加至暂存区，提交时只提交暂存区有的操作，因此该操作未提交至仓库。</p>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><p>上面i讲到，Git管理的是修改，如果我们在进行修改提交的过程中，不小心删除了最后一行<code>hello me</code> ，而我们又需要这行文字该怎么办呢？</p>\n<p>这时候就需要利用版本回退的功能了。</p>\n<p>在Git中，我们可以查看每次操作的记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git <span class=\"built_in\">log</span> --pretty=oneline</span><br><span class=\"line\">aa03a474011bcb97e9f596d3b5c9a1b517726d05 (HEAD -&gt; master) delete a line</span><br><span class=\"line\">05491fda20edff579daf14f24b7afed61d591842 add a line</span><br><span class=\"line\">a58d42838b1284034c4a9d52f0d2780ad251bda2 a</span><br><span class=\"line\">f67db85d1deeb3d7ca0020a332ac4e07bccf12b0 all</span><br><span class=\"line\">b96112ab41f972a9949e213347d7403dd2f8a03b 1</span><br></pre></td></tr></table></figure>\n\n<p>我们要将版本回退到<code>delete a line</code>操作前，因此我们使用<code>reset</code>指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git reset --hard HEAD^</span><br><span class=\"line\">HEAD is now at 05491fd add a line</span><br></pre></td></tr></table></figure>\n\n<p>这里的HEAD^表示上一个版本，如果上两个版本则为^^,以此类推。</p>\n<p>但是问题来了，如果我们现在又想回到<code>delete a line</code>版本该怎么办呢？版本已经回退了。</p>\n<p>git有一个命令记录了你的每次命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git reflog</span><br><span class=\"line\">05491fd (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class=\"line\">aa03a47 HEAD@&#123;1&#125;: commit: delete a line</span><br><span class=\"line\">05491fd (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add a line</span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以利用<code>aa03a47</code>这个id来回到原来版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard aa03a47</span><br><span class=\"line\">HEAD is now at aa03a47 delete a line</span><br></pre></td></tr></table></figure>\n\n<p>于是，版本又回来了。</p>\n<h3 id=\"修改撤销\"><a href=\"#修改撤销\" class=\"headerlink\" title=\"修改撤销\"></a>修改撤销</h3><p>有的时候我们会因为手抖写错代码，比如我们在Read.txt（.sh）文件中添加一行‘rm -rf’，懂点Linux都知道这是个致命操作。</p>\n<p><strong>如果你还没有将这次文件修改提交到暂存区</strong>，那么很简单，直接修改就好了，或者也可以使用指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>工作区的修改就被丢弃了，工作区文件的内容和版本库文件的内容相同。</p>\n<p><strong>如果你已经将文件修改添加到了暂存区</strong>，那么我们需要使用另一个指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD Read.txt</span><br></pre></td></tr></table></figure>\n\n<p>reset指令不仅可以回退版本，当HEAD不^时，reset指令也可以将暂存区的修改操作移除，而后再利用<code>checkout</code>指令同步版本库和工作区内容。</p>\n<p><strong>如果你已经将修改提交到了版本库</strong>，那么按照版本回退的方式进行即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n\n<p>如果你已经将版本库内的内容推送到远程库，比如Github，那就只能听天由命了，谁运行，谁遭殃。</p>\n<h2 id=\"远程库连接\"><a href=\"#远程库连接\" class=\"headerlink\" title=\"远程库连接\"></a>远程库连接</h2><hr>\n<h3 id=\"远程库添加-解除\"><a href=\"#远程库添加-解除\" class=\"headerlink\" title=\"远程库添加/解除\"></a>远程库添加/解除</h3><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>\n<p>（图借的廖雪峰大L的）：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/HYRADbO3nfjtW9T.png\" alt=\"github-create-repo-1\"></p>\n<p>在Repository name填入<code>Read</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/P62pheNWtkZSVcB.png\" alt=\"github-create-repo-2\"></p>\n<p>而后，我们在本地运行命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:xxxx/Read.git</span><br></pre></td></tr></table></figure>\n\n<p>xxx处为你自己的Github账户名，就可以将本地的版本库和远程的库连接起来了。</p>\n<p>将本地库所有内容推送至Github远程库的master分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push （-u） origin master</span><br></pre></td></tr></table></figure>\n\n<p>加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令，不许需要加入-u参数。</p>\n<p><strong>SSH警告</strong></p>\n<p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.</span><br><span class=\"line\">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>\n\n<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>\n<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>\n\n<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>\n<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href=\"https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/\">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>\n<p><strong>解除远程库与本地库的关联关系</strong></p>\n<p>如果我们需要解除本地库与远程库的关联关系，可以使用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"远程库克隆\"><a href=\"#远程库克隆\" class=\"headerlink\" title=\"远程库克隆\"></a>远程库克隆</h3><p>我们有时需要把远程库从Github克隆下来，为了借鉴代码或是进行分布式工作，使用以下指令将远程库克隆至本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:xxx/Read.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><hr>\n<h3 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h3><p>在<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>\n<p><img src=\"https://i.loli.net/2021/05/28/X69umbEgxRBfh3w.png\" alt=\"git-br-initial\"></p>\n<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p>\n<p><img src=\"https://i.loli.net/2021/05/28/EXNTRAfMmV2B63a.png\" alt=\"git-br-create\"></p>\n<p>我们建立一个新分支<code>dev</code>并切换至新分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev    /   git switch -c dev</span><br></pre></td></tr></table></figure>\n\n<p><em>如果切换至已有分支则</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout dev    /    git switch dev</span><br></pre></td></tr></table></figure>\n\n<p>如果只是创建分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch dev</span><br></pre></td></tr></table></figure>\n\n<p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/919022387118368/l\" alt=\"git-br-dev-fd\"></p>\n<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/dQuX31cxi6RTeDO.png\" alt=\"git-br-ff-merge\"></p>\n<p>我们切换至主分支，而后将dev分支合并至主分支master</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n\n<p>而后我们可以保留分支，也可以删除分支，如果删除分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>\n<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>\n<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>\n<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>\n<p>所以，团队合作的分支看起来就像这样：</p>\n<p><img src=\"https://i.loli.net/2021/05/28/tWO9ydfr5miY3EP.png\" alt=\"git-br-policy\"></p>\n<p><strong>远程库克隆</strong></p>\n<p>团队合作的过程中首先要将远程库克隆至本地，具体方式见前文远程库克隆一节</p>\n<p>完成克隆后，Git自动把本地的master分支和远程的master分支对应起来了，默认远程仓库的名称为origin</p>\n<p>查看远程库的信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/CS61A$ git remote -v</span><br><span class=\"line\">origin\tgit@github.com:x/CS61A.git (fetch)</span><br><span class=\"line\">origin\tgit@github.com:x/CS61A.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>\n<p><strong>分支的推送</strong></p>\n<p>分支的推送有很多种模式，这里只介绍最简单的模式，假设，我们已经将远程库的master分支克隆到了本地，而后我们创建了一个新的分支dev，在新的分支进行工作，工作完毕后我们将dev分支合并至master分支，而后使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>就将该分支推送到了远程库</p>\n<p><strong>分支的抓取</strong></p>\n<p>在多人协作时可能会出现一些问题，比如有一天，你的小伙伴已经向origin/master分支推送了他的提交，而你碰巧也对同样的文件进行了修改，并试图推送，这时候你会发现，git提示推送失败，因为你的小伙伴的最新提交和你的提交有冲突。</p>\n<p>因此我们要在推送前先将master最新情况从远程抓下来，然后在本地进行合并和解决冲突。</p>\n<p>解决冲突的方法如下</p>\n<p>我们知道当我们把远程的master分支抓取下来后，我们本地的dev分支和远程pull下来的master分支存在冲突</p>\n<p><img src=\"https://i.loli.net/2021/05/28/ve3HlyfWtqB7bYN.png\" alt=\"git-br-feature1\"></p>\n<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并会有冲突，我们查看 一下git的状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git push&quot;</span> to publish your <span class=\"built_in\">local</span> commits)</span><br><span class=\"line\"></span><br><span class=\"line\">You have unmerged paths.</span><br><span class=\"line\">  (fix conflicts and run <span class=\"string\">&quot;git commit&quot;</span>)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class=\"line\"></span><br><span class=\"line\">Unmerged paths:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboth modified:   Read.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Git告诉我们，Read.txt文件存在冲突，我们可以直接查看文件内容</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Git has a mutable index called stage.</span><br><span class=\"line\">Git tracks changes of files.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">=======</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>\n\n<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>\n\n<p>再提交修改给master分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;conflict fixed&quot;</span></span><br><span class=\"line\">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>\n\n<p>Git告诉我们冲突被解决了，于是我们将dev分支合并至master，而后执行push</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br><span class=\"line\">Counting objects: 6, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (4/4), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:x/Read.git</span><br><span class=\"line\">   7a5e5dd..57c53ab  master -&gt; master</span><br></pre></td></tr></table></figure>\n\n<p>成功。</p>\n<h2 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h2><p>为什么需要标签？</p>\n<p>Git有commit，为什么还要引入tag？</p>\n<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>\n<p>“一串乱七八糟的数字不好找！”</p>\n<p>如果换一个办法：</p>\n<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>\n<p>“好的，按照tag v1.2查找commit就行！”</p>\n<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>\n<h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，而后敲击tag就可以打一个标签</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>git tag</code>查看所有标签</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag</span><br><span class=\"line\">v1.0</span><br><span class=\"line\">v2.0</span><br><span class=\"line\">v2.1</span><br></pre></td></tr></table></figure>\n\n<p>如果要对历史commit打标签，那就通过git log找到commit号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v0.9 f287d34</span><br></pre></td></tr></table></figure>\n\n<p>查看每个标签的信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show v0.9</span><br><span class=\"line\">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add merge</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a/readme.txt b/readme.txt</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>然后按照版本回退一节的方法使用<code>reset</code>指令回退至对应版本打包即可。</p>\n<p>注意，标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>\n<h3 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.1</span><br><span class=\"line\">Deleted tag <span class=\"string\">&#x27;v0.1&#x27;</span> (was f15b0dd)</span><br></pre></td></tr></table></figure>\n\n<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或使用<code>git push origin --tags</code>推送所有标签。</p>\n<p>如果要删除远程标签则先从本地删除标签，而后向远程同步删除指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin :refs/tags/v0.9</span><br><span class=\"line\">To github.com:x/Read.gi0t</span><br><span class=\"line\"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>1.<a href=\"https://www.runoob.com/git/git-tutorial.html\">菜鸟教程Git</a></p>\n<p>2.<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的Git教程</a></p>\n<p>3.<a href=\"https://git-scm.com/\">Git官方网站</a></p>\n"},{"title":"CS61A-过程抽象","date":"2021-06-12T07:15:32.000Z","cover":"/myimage/cs61/cs61a_procedure_cover.png","_content":"\n## CS61A 过程抽象\n\n#### 目录\n\n>程序设计的基本元素\n>\n>* 表达式\n>* 变量与环境\n>* 复合过程与函数\n>* 条件表达式与判定符号\n>* 过程作为黑箱抽象\n>\n>过程产生的计算\n>\n>* 线性递归与迭代\n>* 树形递归\n>\n>高阶函数抽象\n>\n>* 过程作为参数\n>* 过程作为一般性的方法\n>* 过程作为返回值\n>* 使用匿名函数构造过程\n\n\n\n### 程序设计的基本元素\n\n********\n\n一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：\n\n一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int('s'),这叫做复合表达式，表达式是语言最简单的个体。\n\n二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素\n\n三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用\n\n#### 表达式 \n\n以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串\n\n```python\n's',1,'hello'\n```\n\n通过将基本表达式进行组合，我们可以得到组合式\n\n>3-1\n>\n>'s' + 'e'\n\n组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如\n\n```python\n(2+(4*6))*(3+5+7)\n```\n\n 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。\n\n![image-20210612194156857](https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png)\n\n\n\n#### 变量与环境\n\n我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用`pi*(2**2)`进行计算，当我们想要计算的半径变为3时，我们又得写表达`pi*(3**2)`,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用`pi*(r**2)`就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。\n\n不同语言定义变量的方式不同\n\nLisp\n\n```lisp\n(define r 2)\n```\n\nPython\n\n````python\nr = 2\n````\n\nC\n\n```C\nint r = 2\n```\n\n变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。\n\n#### 复合过程与函数\n\n由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象\n\n那么如果我们要对过程进行抽象该怎么办呢？\n\n过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，**为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。**\n\n例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square\n\n不同语言定义函数/复合过程名称的方式不同\n\n*Lisp*\n\n```lisp\n(define (square x) (* x x))\n```\n\n*Python*\n\n```python\ndef square(x):\n    return x**2\n```\n\n定义好之后就可以使用square进行调用\n\n```python\n(sqare 21)\nsquare(2)\n```\n\n我们可以利用已定义好的函数去构建其他过程，以python为例\n\n```python\ndef sum_sq(x,y):\n    return square(x) + square(y)\n```\n\n还可以利用sum_sq去构造其他过程\n\n```python\ndef f(a):\n    return sum_aq(a,a)\n```\n\n#### 条件表达式与符号\n\n至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式\n\n不同的语言中条件表达式不同\n\n*Lisp*\n\n```lisp\n(define (abs x)\n     (cond  (> x 0)x)\n            (= x 0)0)\n            (< x 0)(-x))\n     )\n)\n```\n\nPython没有switch语句，可以用if..elif...替代\n\n```python\ndef abs(x):\n    if x > 0:\n        return x\n    elif x = 0:\n        return 0\n    else x <0:\n        return -x\n```\n\nif是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。\n\n除了><=之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。\n\n例如Lisp中\n\n```lisp\n(and(> x 5)(< x 10))\n```\n\n#### 函数作为黑箱抽象\n\nsqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的\n\n![image-20210612202953454](https://i.loli.net/2021/06/12/u4zixB95rycdopg.png)\n\n这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。\n\n##### 内部定义与块结构\n\n为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。\n\n\n\n### 函数产生的计算\n\n*****\n\n#### 线性递归与迭代\n\n我们以函数的阶乘为例，讲解函数的递归和迭代。\n\n首先，我们使用递归来计算阶乘\n\n考虑阶乘函数：\n\n```python\nn! = n*(n-1)*(n-2)...1\n(n-1)! = (n-1)*(n-2)...1\nn! = n*(n-1)! \n```\n\n这样，我们就能通过算出(n-1)!，i进而计算出n！\n\n```python\ndef factorial(n):\n     return n*factorial(n-1)\n```\n\n但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。\n\n```python\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n*factorial(n-1)\n```\n\n这个过程如图所示\n\n![image-20210612215413983](https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png)\n\n\n\n于是我们总结出迭代所需要的三个要素：\n\n*一是base_case也就是迭代终止条件*\n\n*二是可迭代拆分的结构，比如`factorial(n)`的结果就可以分解成为`n * factorial(n-1)`\n\n*三是可以连续传递*，验证n与n-1的规则是否通用。\n\n\n\n但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如\n\n>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：\n>\n>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,\n>\n>def pingpong(n): ?\n\n这里的`pingpong(n)`和`pingpong(n-1)`无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。\n\n```python\n\ndef pingpong(n):\n    def itera(out,index=1,adder=1)\n        if index == n:\n            return out\n        if index%7==0:\n            return itera(out+adder,index+1,adder=-adder)\n        else:\n            return itera(out+adder,index+1,adder=adder)\n    out = itera(1,1,1)\n    return out \n            \n```\n\n这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。\n\n\n\n而后，我们再使用迭代对阶乘进行计算：\n\n```python\ndef factorial(n):\n    a = 1\n    for i in range(n):\n        a = a*i\n    return a\n```\n\n由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。\n\n迭代的表示如下：\n\n![image-20210613110228758](https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png)\n\n\n\n迭代和递归是两种最常见的循环过程，其主要不同点在于：\n\n一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。\n\n迭代：\n\n![image-20210613110437725](https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png)\n\n递归：\n\n![image-20210613110636563](https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png)\n\n二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。\n\n\n\n#### 树形递归\n\n树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。\n\n首先我们以递归的思路来考虑\n\n`feb(n)`和`feb(n-1)`有什么关系？\n\n貌似没有关系，但是我们知道`feb(n)=feb(n-1)+feb(n-2)`\n\n因此我们可以这样设计递归\n\n```python\ndef feb(n):\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n-1)+fib(n-2)\n        \n```\n\n这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：\n\n![image-20210613112437233](https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png)\n\n树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题\n\n> Q7：河内塔\n> 一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。\n>\n> ![image-20210613154038670](https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png)\n>\n> 拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：\n>\n> 一次只能移动一个磁盘。\n> 每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。\n> 任何磁盘都不能放置在较小磁盘的顶部。\n> 完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。\n>\n> 题目给出了两个内置函数\n>\n> ```python\n> def print_move(origin, destination):\n>     \"\"\"Print instructions to move a disk.\"\"\"\n>     print(\"Move the top disk from rod\", origin, \"to rod\", destination)\n> \n> def move_stack(n, start, end):\n>     \"\"\"Print the moves required to move n disks on the start pole to the end\n>     pole without violating the rules of Towers of Hanoi.\n> ```\n\n我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该`move_stack(3,1,3)`,而`move_stack(3,1,3)`这个过程可以分解为\n\n一.先将上面两层移动至2,即`move_stack(2,1,2)`\n\n二.将底层移动到3,即`move_stack(1,1,3)`\n\n三.将在2的两层移至3,即`move_stack(2,2,3)`\n\n我们会发现实际上`move_stack(n,a,c)`可以分解为`move_stack(n-1,a,b)`，`move_stack(1,a,c)`,`move_stack(n-1,b,c)`\n\n因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。\n\n具体实现如下：\n\n```python\ndef move_stack(n,start,end):\n        bars = [1,2,3]\n    if n == 1:\n        print_move(start,end)\n    else:\n        c=[bar for bar in bars if bar not in [start,end] ]\n        c = c[0]\n        a = start\n        b = end \n        move_stack(n-1,a,c)\n        move_stack(1,a,b)\n        move_stack(n-1,c,b)\n\n```\n\n这里的base_case就是n==1。\n\n\n\n### 高阶函数抽象\n\n******\n\n#### 函数作为参数\n\n思考一下以下两个函数\n\n第一个 sum_naturals函数计算最大为n的自然数之和\n\n```python\ndef sum_naturals(n):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + [k], k + 1\n    return total\n\n```\n\n第二个sum_pi计算系列中的项的总和\n\n```python\ndef pi_sum(n):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + [8 / ((4*k-3) * (4*k-1))], k + 1\n    return total\n```\n\n我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数\n\n```python\ndef xx (n):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + <term>(k), k + 1\n    return total\n```\n\n因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：\n\n```python\ndef sum(n,term):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\ndef natural(k):\n    return k\n\ndef pi(k):\n    return 8 / ((4*k-3) * (4*k-1))\n\n```\n\n这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。\n\n\n\n#### 函数作为一般性方法\n\n\n\n刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。\n\n```python\n1\tdef improve(update, close, guess=1):\n2\t    while not close(guess):\n3\t        guess = update(guess)\n4\t    return guess\n5\t\n6\tdef golden_update(guess):\n7\t    return 1/guess + 1\n8\t\n9\tdef square_close_to_successor(guess):\n10\t    return approx_eq(guess * guess,\n11\t                     guess + 1)\n12\t\n13\tdef approx_eq(x, y, tolerance=1e-3):\n14\t    return abs(x - y) < tolerance\n15\t\n16\tphi = improve(golden_update,\n17\t              square_close_to_successor)\n```\n\n我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：\n\n```python\n\tdef improve(guess=1):\n\t    def golden_update(guess):\n\t        return 1/guess + 1\n        \n\t    def square_close_to_successor(guess):\n            return approx_eq(guess * guess,guess + 1)\n\t\n\t    def approx_eq(x, y, tolerance=1e-3):\n\t        return abs(x - y) < tolerance\n        \n        while not square_close_to_successor(guess):\n\t        guess = golden_update(guess)\n\t    return guess\n\t\n\tphi = improve()\n```\n\n这样一来整体的函数结构就清晰多了。\n\n\n\n#### 函数作为返回值\n\n通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。\n\n一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用现有工具定义函数组合：\n\n```python\ndef compose1(f, g):\n        def h(x):\n            return f(g(x))\n        return h\n```\n\n这时候返回的函数就是f(g(x))\n\n函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。\n\n柯里化的具体实现过程如下：\n\n```python\ndef curi_pow(x):\n    def f(y):\n        return pow(x,y)\n    return f\n\n```\n\n当调用`curi_pow(2)(3)`时，首先计算curi_pow(2),返回的函数实际上就是 `lambda  x: pow(2,x)`，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此`curi_pow(2)（3）`实际上是`lambda x:pow(2,x)(3)`也就是pow(2,3)\n\n我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化\n\n```python\ndef curi(f):\n    def g(x):\n        def h(y):\n            return f(x,y)\n        return h\n    return g\n```\n\n具体推导过程 如下：\n\n要使得  s(x)(y) = f(x,y)，则s = lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。\n\n柯里化也可以反向进行，具体实现过程为：\n\n```python\ndef uncuri(g):\n     def h(x,y):\n            return g(x)(y)\n     return h\n```\n\n同理，要使得 f(x,y) = g(x)(y)，则 f = lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。\n\n\n\n#### 使用匿名函数构造过程\n\n到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。\n\nlambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。\n\n```python\ns = lambda x:x*x\ns(2) = 4\n```\n\n这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。\n\n一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。\n\n```python\n compose1=lambda f,g:lambda x:f(g(x))\n```\n\n匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。\n\n我们知道，使用递归来进行阶乘的计算如下所示：\n\n```python\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n*factorial(n-1)\n\n```\n\n那么如果使用匿名函数来进行递归，结构又该是什么样的呢？\n\n我们先来看一个简单一点的方案。\n\n```python\nfact = lambda n:1 if n==1 else n*fact(n-1)\n```\n\n这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f\n\n```python\nlambda n,f:1 if n==1 else n*f(n-1,f) \n```\n\n于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact= lambda n,f:1 if n==1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。\n\n解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。\n\nfact = lambda n:(lambda g:g(n,f))(lambda n,f:1 if n==1 else n*f(n-1,f))\n\n这个结构的原理是这样的，fact(3)首先等于`(lambda f:f(3,f))`，然而由于后i面还有一个`(lambda n,f:1 if n==1 else n*f(n-1,f))`因此f函数的值被填充为匿名函数，成为f(3,f) 其中 `f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))`。","source":"_posts/CS61A-过程抽象.md","raw":"---\n\ntitle: CS61A-过程抽象\ndate: 2021-06-12 15:15:32\ntags:\n- 程序结构\n- CS61\n- CS61A\ncategories:\n- Learning Record\ncover: /myimage/cs61/cs61a_procedure_cover.png\n---\n\n## CS61A 过程抽象\n\n#### 目录\n\n>程序设计的基本元素\n>\n>* 表达式\n>* 变量与环境\n>* 复合过程与函数\n>* 条件表达式与判定符号\n>* 过程作为黑箱抽象\n>\n>过程产生的计算\n>\n>* 线性递归与迭代\n>* 树形递归\n>\n>高阶函数抽象\n>\n>* 过程作为参数\n>* 过程作为一般性的方法\n>* 过程作为返回值\n>* 使用匿名函数构造过程\n\n\n\n### 程序设计的基本元素\n\n********\n\n一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：\n\n一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int('s'),这叫做复合表达式，表达式是语言最简单的个体。\n\n二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素\n\n三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用\n\n#### 表达式 \n\n以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串\n\n```python\n's',1,'hello'\n```\n\n通过将基本表达式进行组合，我们可以得到组合式\n\n>3-1\n>\n>'s' + 'e'\n\n组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如\n\n```python\n(2+(4*6))*(3+5+7)\n```\n\n 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。\n\n![image-20210612194156857](https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png)\n\n\n\n#### 变量与环境\n\n我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用`pi*(2**2)`进行计算，当我们想要计算的半径变为3时，我们又得写表达`pi*(3**2)`,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用`pi*(r**2)`就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。\n\n不同语言定义变量的方式不同\n\nLisp\n\n```lisp\n(define r 2)\n```\n\nPython\n\n````python\nr = 2\n````\n\nC\n\n```C\nint r = 2\n```\n\n变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。\n\n#### 复合过程与函数\n\n由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象\n\n那么如果我们要对过程进行抽象该怎么办呢？\n\n过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，**为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。**\n\n例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square\n\n不同语言定义函数/复合过程名称的方式不同\n\n*Lisp*\n\n```lisp\n(define (square x) (* x x))\n```\n\n*Python*\n\n```python\ndef square(x):\n    return x**2\n```\n\n定义好之后就可以使用square进行调用\n\n```python\n(sqare 21)\nsquare(2)\n```\n\n我们可以利用已定义好的函数去构建其他过程，以python为例\n\n```python\ndef sum_sq(x,y):\n    return square(x) + square(y)\n```\n\n还可以利用sum_sq去构造其他过程\n\n```python\ndef f(a):\n    return sum_aq(a,a)\n```\n\n#### 条件表达式与符号\n\n至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式\n\n不同的语言中条件表达式不同\n\n*Lisp*\n\n```lisp\n(define (abs x)\n     (cond  (> x 0)x)\n            (= x 0)0)\n            (< x 0)(-x))\n     )\n)\n```\n\nPython没有switch语句，可以用if..elif...替代\n\n```python\ndef abs(x):\n    if x > 0:\n        return x\n    elif x = 0:\n        return 0\n    else x <0:\n        return -x\n```\n\nif是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。\n\n除了><=之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。\n\n例如Lisp中\n\n```lisp\n(and(> x 5)(< x 10))\n```\n\n#### 函数作为黑箱抽象\n\nsqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的\n\n![image-20210612202953454](https://i.loli.net/2021/06/12/u4zixB95rycdopg.png)\n\n这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。\n\n##### 内部定义与块结构\n\n为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。\n\n\n\n### 函数产生的计算\n\n*****\n\n#### 线性递归与迭代\n\n我们以函数的阶乘为例，讲解函数的递归和迭代。\n\n首先，我们使用递归来计算阶乘\n\n考虑阶乘函数：\n\n```python\nn! = n*(n-1)*(n-2)...1\n(n-1)! = (n-1)*(n-2)...1\nn! = n*(n-1)! \n```\n\n这样，我们就能通过算出(n-1)!，i进而计算出n！\n\n```python\ndef factorial(n):\n     return n*factorial(n-1)\n```\n\n但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。\n\n```python\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n*factorial(n-1)\n```\n\n这个过程如图所示\n\n![image-20210612215413983](https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png)\n\n\n\n于是我们总结出迭代所需要的三个要素：\n\n*一是base_case也就是迭代终止条件*\n\n*二是可迭代拆分的结构，比如`factorial(n)`的结果就可以分解成为`n * factorial(n-1)`\n\n*三是可以连续传递*，验证n与n-1的规则是否通用。\n\n\n\n但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如\n\n>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：\n>\n>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,\n>\n>def pingpong(n): ?\n\n这里的`pingpong(n)`和`pingpong(n-1)`无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。\n\n```python\n\ndef pingpong(n):\n    def itera(out,index=1,adder=1)\n        if index == n:\n            return out\n        if index%7==0:\n            return itera(out+adder,index+1,adder=-adder)\n        else:\n            return itera(out+adder,index+1,adder=adder)\n    out = itera(1,1,1)\n    return out \n            \n```\n\n这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。\n\n\n\n而后，我们再使用迭代对阶乘进行计算：\n\n```python\ndef factorial(n):\n    a = 1\n    for i in range(n):\n        a = a*i\n    return a\n```\n\n由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。\n\n迭代的表示如下：\n\n![image-20210613110228758](https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png)\n\n\n\n迭代和递归是两种最常见的循环过程，其主要不同点在于：\n\n一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。\n\n迭代：\n\n![image-20210613110437725](https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png)\n\n递归：\n\n![image-20210613110636563](https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png)\n\n二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。\n\n\n\n#### 树形递归\n\n树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。\n\n首先我们以递归的思路来考虑\n\n`feb(n)`和`feb(n-1)`有什么关系？\n\n貌似没有关系，但是我们知道`feb(n)=feb(n-1)+feb(n-2)`\n\n因此我们可以这样设计递归\n\n```python\ndef feb(n):\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n-1)+fib(n-2)\n        \n```\n\n这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：\n\n![image-20210613112437233](https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png)\n\n树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题\n\n> Q7：河内塔\n> 一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。\n>\n> ![image-20210613154038670](https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png)\n>\n> 拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：\n>\n> 一次只能移动一个磁盘。\n> 每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。\n> 任何磁盘都不能放置在较小磁盘的顶部。\n> 完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。\n>\n> 题目给出了两个内置函数\n>\n> ```python\n> def print_move(origin, destination):\n>     \"\"\"Print instructions to move a disk.\"\"\"\n>     print(\"Move the top disk from rod\", origin, \"to rod\", destination)\n> \n> def move_stack(n, start, end):\n>     \"\"\"Print the moves required to move n disks on the start pole to the end\n>     pole without violating the rules of Towers of Hanoi.\n> ```\n\n我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该`move_stack(3,1,3)`,而`move_stack(3,1,3)`这个过程可以分解为\n\n一.先将上面两层移动至2,即`move_stack(2,1,2)`\n\n二.将底层移动到3,即`move_stack(1,1,3)`\n\n三.将在2的两层移至3,即`move_stack(2,2,3)`\n\n我们会发现实际上`move_stack(n,a,c)`可以分解为`move_stack(n-1,a,b)`，`move_stack(1,a,c)`,`move_stack(n-1,b,c)`\n\n因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。\n\n具体实现如下：\n\n```python\ndef move_stack(n,start,end):\n        bars = [1,2,3]\n    if n == 1:\n        print_move(start,end)\n    else:\n        c=[bar for bar in bars if bar not in [start,end] ]\n        c = c[0]\n        a = start\n        b = end \n        move_stack(n-1,a,c)\n        move_stack(1,a,b)\n        move_stack(n-1,c,b)\n\n```\n\n这里的base_case就是n==1。\n\n\n\n### 高阶函数抽象\n\n******\n\n#### 函数作为参数\n\n思考一下以下两个函数\n\n第一个 sum_naturals函数计算最大为n的自然数之和\n\n```python\ndef sum_naturals(n):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + [k], k + 1\n    return total\n\n```\n\n第二个sum_pi计算系列中的项的总和\n\n```python\ndef pi_sum(n):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + [8 / ((4*k-3) * (4*k-1))], k + 1\n    return total\n```\n\n我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数\n\n```python\ndef xx (n):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + <term>(k), k + 1\n    return total\n```\n\n因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：\n\n```python\ndef sum(n,term):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\ndef natural(k):\n    return k\n\ndef pi(k):\n    return 8 / ((4*k-3) * (4*k-1))\n\n```\n\n这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。\n\n\n\n#### 函数作为一般性方法\n\n\n\n刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。\n\n```python\n1\tdef improve(update, close, guess=1):\n2\t    while not close(guess):\n3\t        guess = update(guess)\n4\t    return guess\n5\t\n6\tdef golden_update(guess):\n7\t    return 1/guess + 1\n8\t\n9\tdef square_close_to_successor(guess):\n10\t    return approx_eq(guess * guess,\n11\t                     guess + 1)\n12\t\n13\tdef approx_eq(x, y, tolerance=1e-3):\n14\t    return abs(x - y) < tolerance\n15\t\n16\tphi = improve(golden_update,\n17\t              square_close_to_successor)\n```\n\n我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：\n\n```python\n\tdef improve(guess=1):\n\t    def golden_update(guess):\n\t        return 1/guess + 1\n        \n\t    def square_close_to_successor(guess):\n            return approx_eq(guess * guess,guess + 1)\n\t\n\t    def approx_eq(x, y, tolerance=1e-3):\n\t        return abs(x - y) < tolerance\n        \n        while not square_close_to_successor(guess):\n\t        guess = golden_update(guess)\n\t    return guess\n\t\n\tphi = improve()\n```\n\n这样一来整体的函数结构就清晰多了。\n\n\n\n#### 函数作为返回值\n\n通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。\n\n一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用现有工具定义函数组合：\n\n```python\ndef compose1(f, g):\n        def h(x):\n            return f(g(x))\n        return h\n```\n\n这时候返回的函数就是f(g(x))\n\n函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。\n\n柯里化的具体实现过程如下：\n\n```python\ndef curi_pow(x):\n    def f(y):\n        return pow(x,y)\n    return f\n\n```\n\n当调用`curi_pow(2)(3)`时，首先计算curi_pow(2),返回的函数实际上就是 `lambda  x: pow(2,x)`，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此`curi_pow(2)（3）`实际上是`lambda x:pow(2,x)(3)`也就是pow(2,3)\n\n我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化\n\n```python\ndef curi(f):\n    def g(x):\n        def h(y):\n            return f(x,y)\n        return h\n    return g\n```\n\n具体推导过程 如下：\n\n要使得  s(x)(y) = f(x,y)，则s = lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。\n\n柯里化也可以反向进行，具体实现过程为：\n\n```python\ndef uncuri(g):\n     def h(x,y):\n            return g(x)(y)\n     return h\n```\n\n同理，要使得 f(x,y) = g(x)(y)，则 f = lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。\n\n\n\n#### 使用匿名函数构造过程\n\n到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。\n\nlambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。\n\n```python\ns = lambda x:x*x\ns(2) = 4\n```\n\n这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。\n\n一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。\n\n```python\n compose1=lambda f,g:lambda x:f(g(x))\n```\n\n匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。\n\n我们知道，使用递归来进行阶乘的计算如下所示：\n\n```python\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n*factorial(n-1)\n\n```\n\n那么如果使用匿名函数来进行递归，结构又该是什么样的呢？\n\n我们先来看一个简单一点的方案。\n\n```python\nfact = lambda n:1 if n==1 else n*fact(n-1)\n```\n\n这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f\n\n```python\nlambda n,f:1 if n==1 else n*f(n-1,f) \n```\n\n于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact= lambda n,f:1 if n==1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。\n\n解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。\n\nfact = lambda n:(lambda g:g(n,f))(lambda n,f:1 if n==1 else n*f(n-1,f))\n\n这个结构的原理是这样的，fact(3)首先等于`(lambda f:f(3,f))`，然而由于后i面还有一个`(lambda n,f:1 if n==1 else n*f(n-1,f))`因此f函数的值被填充为匿名函数，成为f(3,f) 其中 `f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))`。","slug":"CS61A-过程抽象","published":1,"updated":"2023-02-11T11:16:51.224Z","_id":"ckpwpsg3n0000jgrh87z2bjun","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CS61A-过程抽象\"><a href=\"#CS61A-过程抽象\" class=\"headerlink\" title=\"CS61A 过程抽象\"></a>CS61A 过程抽象</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>程序设计的基本元素</p>\n<ul>\n<li>表达式</li>\n<li>变量与环境</li>\n<li>复合过程与函数</li>\n<li>条件表达式与判定符号</li>\n<li>过程作为黑箱抽象</li>\n</ul>\n<p>过程产生的计算</p>\n<ul>\n<li>线性递归与迭代</li>\n<li>树形递归</li>\n</ul>\n<p>高阶函数抽象</p>\n<ul>\n<li>过程作为参数</li>\n<li>过程作为一般性的方法</li>\n<li>过程作为返回值</li>\n<li>使用匿名函数构造过程</li>\n</ul>\n</blockquote>\n<h3 id=\"程序设计的基本元素\"><a href=\"#程序设计的基本元素\" class=\"headerlink\" title=\"程序设计的基本元素\"></a>程序设计的基本元素</h3><hr>\n<p>一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：</p>\n<p>一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int(‘s’),这叫做复合表达式，表达式是语言最简单的个体。</p>\n<p>二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素</p>\n<p>三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用</p>\n<h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><p>以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;s&#x27;</span>,<span class=\"number\">1</span>,<span class=\"string\">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过将基本表达式进行组合，我们可以得到组合式</p>\n<blockquote>\n<p>3-1</p>\n<p>‘s’ + ‘e’</p>\n</blockquote>\n<p>组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">2</span>+(<span class=\"number\">4</span>*<span class=\"number\">6</span>))*(<span class=\"number\">3</span>+<span class=\"number\">5</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n\n<p> 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。</p>\n<p><img src=\"https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png\" alt=\"image-20210612194156857\"></p>\n<h4 id=\"变量与环境\"><a href=\"#变量与环境\" class=\"headerlink\" title=\"变量与环境\"></a>变量与环境</h4><p>我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用<code>pi*(2**2)</code>进行计算，当我们想要计算的半径变为3时，我们又得写表达<code>pi*(3**2)</code>,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用<code>pi*(r**2)</code>就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。</p>\n<p>不同语言定义变量的方式不同</p>\n<p>Lisp</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define</span> r <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Python</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> r = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。</p>\n<h4 id=\"复合过程与函数\"><a href=\"#复合过程与函数\" class=\"headerlink\" title=\"复合过程与函数\"></a>复合过程与函数</h4><p>由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象</p>\n<p>那么如果我们要对过程进行抽象该怎么办呢？</p>\n<p>过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，<strong>为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。</strong></p>\n<p>例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square</p>\n<p>不同语言定义函数/复合过程名称的方式不同</p>\n<p><em>Lisp</em></p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define</span> (<span class=\"name\">square</span> x) (<span class=\"name\">*</span> x x))</span><br></pre></td></tr></table></figure>\n\n<p><em>Python</em></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x**<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>定义好之后就可以使用square进行调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(sqare <span class=\"number\">21</span>)</span><br><span class=\"line\">square(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以利用已定义好的函数去构建其他过程，以python为例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_sq</span>(<span class=\"params\">x,y</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> square(x) + square(y)</span><br></pre></td></tr></table></figure>\n\n<p>还可以利用sum_sq去构造其他过程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">a</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum_aq(a,a)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"条件表达式与符号\"><a href=\"#条件表达式与符号\" class=\"headerlink\" title=\"条件表达式与符号\"></a>条件表达式与符号</h4><p>至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式</p>\n<p>不同的语言中条件表达式不同</p>\n<p><em>Lisp</em></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define</span> (<span class=\"name\">abs</span> x)</span><br><span class=\"line\">     (<span class=\"name\">cond</span>  (<span class=\"name\">&gt;</span> x <span class=\"number\">0</span>)x)</span><br><span class=\"line\">            (<span class=\"name\">=</span> x <span class=\"number\">0</span>)<span class=\"number\">0</span>)</span><br><span class=\"line\">            (&lt; x 0)(-x))</span><br><span class=\"line\">     )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Python没有switch语句，可以用if..elif…替代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> x = <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> x &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure>\n\n<p>if是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。</p>\n<p>除了&gt;&lt;=之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。</p>\n<p>例如Lisp中</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">and</span>(<span class=\"name\">&gt;</span> x <span class=\"number\">5</span>)(<span class=\"name\">&lt;</span> x <span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数作为黑箱抽象\"><a href=\"#函数作为黑箱抽象\" class=\"headerlink\" title=\"函数作为黑箱抽象\"></a>函数作为黑箱抽象</h4><p>sqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的</p>\n<p><img src=\"https://i.loli.net/2021/06/12/u4zixB95rycdopg.png\" alt=\"image-20210612202953454\"></p>\n<p>这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。</p>\n<h5 id=\"内部定义与块结构\"><a href=\"#内部定义与块结构\" class=\"headerlink\" title=\"内部定义与块结构\"></a>内部定义与块结构</h5><p>为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。</p>\n<h3 id=\"函数产生的计算\"><a href=\"#函数产生的计算\" class=\"headerlink\" title=\"函数产生的计算\"></a>函数产生的计算</h3><hr>\n<h4 id=\"线性递归与迭代\"><a href=\"#线性递归与迭代\" class=\"headerlink\" title=\"线性递归与迭代\"></a>线性递归与迭代</h4><p>我们以函数的阶乘为例，讲解函数的递归和迭代。</p>\n<p>首先，我们使用递归来计算阶乘</p>\n<p>考虑阶乘函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n! = n*(n-<span class=\"number\">1</span>)*(n-<span class=\"number\">2</span>)..<span class=\"number\">.1</span></span><br><span class=\"line\">(n-<span class=\"number\">1</span>)! = (n-<span class=\"number\">1</span>)*(n-<span class=\"number\">2</span>)..<span class=\"number\">.1</span></span><br><span class=\"line\">n! = n*(n-<span class=\"number\">1</span>)! </span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就能通过算出(n-1)!，i进而计算出n！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个过程如图所示</p>\n<p><img src=\"https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png\" alt=\"image-20210612215413983\"></p>\n<p>于是我们总结出迭代所需要的三个要素：</p>\n<p><em>一是base_case也就是迭代终止条件</em></p>\n<p>*二是可迭代拆分的结构，比如<code>factorial(n)</code>的结果就可以分解成为<code>n * factorial(n-1)</code></p>\n<p><em>三是可以连续传递</em>，验证n与n-1的规则是否通用。</p>\n<p>但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如</p>\n<blockquote>\n<p>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：</p>\n<p>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,</p>\n<p>def pingpong(n): ?</p>\n</blockquote>\n<p>这里的<code>pingpong(n)</code>和<code>pingpong(n-1)</code>无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pingpong</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">itera</span>(<span class=\"params\">out,index=<span class=\"number\">1</span>,adder=<span class=\"number\">1</span></span>)</span></span><br><span class=\"line\">        if index == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> out</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index%<span class=\"number\">7</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itera(out+adder,index+<span class=\"number\">1</span>,adder=-adder)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itera(out+adder,index+<span class=\"number\">1</span>,adder=adder)</span><br><span class=\"line\">    out = itera(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out </span><br><span class=\"line\">            </span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。</p>\n<p>而后，我们再使用迭代对阶乘进行计算：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        a = a*i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n\n<p>由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。</p>\n<p>迭代的表示如下：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png\" alt=\"image-20210613110228758\"></p>\n<p>迭代和递归是两种最常见的循环过程，其主要不同点在于：</p>\n<p>一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。</p>\n<p>迭代：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png\" alt=\"image-20210613110437725\"></p>\n<p>递归：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png\" alt=\"image-20210613110636563\"></p>\n<p>二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。</p>\n<h4 id=\"树形递归\"><a href=\"#树形递归\" class=\"headerlink\" title=\"树形递归\"></a>树形递归</h4><p>树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。</p>\n<p>首先我们以递归的思路来考虑</p>\n<p><code>feb(n)</code>和<code>feb(n-1)</code>有什么关系？</p>\n<p>貌似没有关系，但是我们知道<code>feb(n)=feb(n-1)+feb(n-2)</code></p>\n<p>因此我们可以这样设计递归</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">feb</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n-<span class=\"number\">1</span>)+fib(n-<span class=\"number\">2</span>)</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n\n<p>这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png\" alt=\"image-20210613112437233\"></p>\n<p>树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题</p>\n<blockquote>\n<p>Q7：河内塔<br>一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。</p>\n<p><img src=\"https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png\" alt=\"image-20210613154038670\"></p>\n<p>拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：</p>\n<p>一次只能移动一个磁盘。<br>每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。<br>任何磁盘都不能放置在较小磁盘的顶部。<br>完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。</p>\n<p>题目给出了两个内置函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_move</span>(<span class=\"params\">origin, destination</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Print instructions to move a disk.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Move the top disk from rod&quot;</span>, origin, <span class=\"string\">&quot;to rod&quot;</span>, destination)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_stack</span>(<span class=\"params\">n, start, end</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Print the moves required to move n disks on the start pole to the end</span></span><br><span class=\"line\"><span class=\"string\">    pole without violating the rules of Towers of Hanoi.</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该<code>move_stack(3,1,3)</code>,而<code>move_stack(3,1,3)</code>这个过程可以分解为</p>\n<p>一.先将上面两层移动至2,即<code>move_stack(2,1,2)</code></p>\n<p>二.将底层移动到3,即<code>move_stack(1,1,3)</code></p>\n<p>三.将在2的两层移至3,即<code>move_stack(2,2,3)</code></p>\n<p>我们会发现实际上<code>move_stack(n,a,c)</code>可以分解为<code>move_stack(n-1,a,b)</code>，<code>move_stack(1,a,c)</code>,<code>move_stack(n-1,b,c)</code></p>\n<p>因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。</p>\n<p>具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_stack</span>(<span class=\"params\">n,start,end</span>):</span></span><br><span class=\"line\">        bars = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        print_move(start,end)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        c=[bar <span class=\"keyword\">for</span> bar <span class=\"keyword\">in</span> bars <span class=\"keyword\">if</span> bar <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> [start,end] ]</span><br><span class=\"line\">        c = c[<span class=\"number\">0</span>]</span><br><span class=\"line\">        a = start</span><br><span class=\"line\">        b = end </span><br><span class=\"line\">        move_stack(n-<span class=\"number\">1</span>,a,c)</span><br><span class=\"line\">        move_stack(<span class=\"number\">1</span>,a,b)</span><br><span class=\"line\">        move_stack(n-<span class=\"number\">1</span>,c,b)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的base_case就是n==1。</p>\n<h3 id=\"高阶函数抽象\"><a href=\"#高阶函数抽象\" class=\"headerlink\" title=\"高阶函数抽象\"></a>高阶函数抽象</h3><hr>\n<h4 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h4><p>思考一下以下两个函数</p>\n<p>第一个 sum_naturals函数计算最大为n的自然数之和</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_naturals</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + [k], k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二个sum_pi计算系列中的项的总和</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pi_sum</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + [<span class=\"number\">8</span> / ((<span class=\"number\">4</span>*k-<span class=\"number\">3</span>) * (<span class=\"number\">4</span>*k-<span class=\"number\">1</span>))], k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br></pre></td></tr></table></figure>\n\n<p>我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">xx</span> (<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + &lt;term&gt;(k), k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span>(<span class=\"params\">n,term</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + term(k), k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">natural</span>(<span class=\"params\">k</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pi</span>(<span class=\"params\">k</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">8</span> / ((<span class=\"number\">4</span>*k-<span class=\"number\">3</span>) * (<span class=\"number\">4</span>*k-<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。</p>\n<h4 id=\"函数作为一般性方法\"><a href=\"#函数作为一般性方法\" class=\"headerlink\" title=\"函数作为一般性方法\"></a>函数作为一般性方法</h4><p>刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">improve</span>(<span class=\"params\">update, close, guess=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\"><span class=\"number\">2</span>\t    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> close(guess):</span><br><span class=\"line\"><span class=\"number\">3</span>\t        guess = update(guess)</span><br><span class=\"line\"><span class=\"number\">4</span>\t    <span class=\"keyword\">return</span> guess</span><br><span class=\"line\"><span class=\"number\">5</span>\t</span><br><span class=\"line\"><span class=\"number\">6</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">golden_update</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\"><span class=\"number\">7</span>\t    <span class=\"keyword\">return</span> <span class=\"number\">1</span>/guess + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">8</span>\t</span><br><span class=\"line\"><span class=\"number\">9</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square_close_to_successor</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\"><span class=\"number\">10</span>\t    <span class=\"keyword\">return</span> approx_eq(guess * guess,</span><br><span class=\"line\"><span class=\"number\">11</span>\t                     guess + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">12</span>\t</span><br><span class=\"line\"><span class=\"number\">13</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">approx_eq</span>(<span class=\"params\">x, y, tolerance=<span class=\"number\">1e-3</span></span>):</span></span><br><span class=\"line\"><span class=\"number\">14</span>\t    <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(x - y) &lt; tolerance</span><br><span class=\"line\"><span class=\"number\">15</span>\t</span><br><span class=\"line\"><span class=\"number\">16</span>\tphi = improve(golden_update,</span><br><span class=\"line\"><span class=\"number\">17</span>\t              square_close_to_successor)</span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">improve</span>(<span class=\"params\">guess=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">golden_update</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>/guess + <span class=\"number\">1</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square_close_to_successor</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> approx_eq(guess * guess,guess + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">approx_eq</span>(<span class=\"params\">x, y, tolerance=<span class=\"number\">1e-3</span></span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(x - y) &lt; tolerance</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> square_close_to_successor(guess):</span><br><span class=\"line\">        guess = golden_update(guess)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> guess</span><br><span class=\"line\"></span><br><span class=\"line\">phi = improve()</span><br></pre></td></tr></table></figure>\n\n<p>这样一来整体的函数结构就清晰多了。</p>\n<h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。</p>\n<p>一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用现有工具定义函数组合：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compose1</span>(<span class=\"params\">f, g</span>):</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">h</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> f(g(x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h</span><br></pre></td></tr></table></figure>\n\n<p>这时候返回的函数就是f(g(x))</p>\n<p>函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。</p>\n<p>柯里化的具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curi_pow</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">y</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(x,y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当调用<code>curi_pow(2)(3)</code>时，首先计算curi_pow(2),返回的函数实际上就是 <code>lambda  x: pow(2,x)</code>，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此<code>curi_pow(2)（3）</code>实际上是<code>lambda x:pow(2,x)(3)</code>也就是pow(2,3)</p>\n<p>我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curi</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">h</span>(<span class=\"params\">y</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> f(x,y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g</span><br></pre></td></tr></table></figure>\n\n<p>具体推导过程 如下：</p>\n<p>要使得  s(x)(y) = f(x,y)，则s = lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。</p>\n<p>柯里化也可以反向进行，具体实现过程为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uncuri</span>(<span class=\"params\">g</span>):</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">h</span>(<span class=\"params\">x,y</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> g(x)(y)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> h</span><br></pre></td></tr></table></figure>\n\n<p>同理，要使得 f(x,y) = g(x)(y)，则 f = lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。</p>\n<h4 id=\"使用匿名函数构造过程\"><a href=\"#使用匿名函数构造过程\" class=\"headerlink\" title=\"使用匿名函数构造过程\"></a>使用匿名函数构造过程</h4><p>到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。</p>\n<p>lambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"keyword\">lambda</span> x:x*x</span><br><span class=\"line\">s(<span class=\"number\">2</span>) = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。</p>\n<p>一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose1=<span class=\"keyword\">lambda</span> f,g:<span class=\"keyword\">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。</p>\n<p>我们知道，使用递归来进行阶乘的计算如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>那么如果使用匿名函数来进行递归，结构又该是什么样的呢？</p>\n<p>我们先来看一个简单一点的方案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fact = <span class=\"keyword\">lambda</span> n:<span class=\"number\">1</span> <span class=\"keyword\">if</span> n==<span class=\"number\">1</span> <span class=\"keyword\">else</span> n*fact(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lambda</span> n,f:<span class=\"number\">1</span> <span class=\"keyword\">if</span> n==<span class=\"number\">1</span> <span class=\"keyword\">else</span> n*f(n-<span class=\"number\">1</span>,f) </span><br></pre></td></tr></table></figure>\n\n<p>于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact= lambda n,f:1 if n==1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。</p>\n<p>解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。</p>\n<p>fact = lambda n:(lambda g:g(n,f))(lambda n,f:1 if n==1 else n*f(n-1,f))</p>\n<p>这个结构的原理是这样的，fact(3)首先等于<code>(lambda f:f(3,f))</code>，然而由于后i面还有一个<code>(lambda n,f:1 if n==1 else n*f(n-1,f))</code>因此f函数的值被填充为匿名函数，成为f(3,f) 其中 <code>f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))</code>。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":8300,"excerpt":"","more":"<h2 id=\"CS61A-过程抽象\"><a href=\"#CS61A-过程抽象\" class=\"headerlink\" title=\"CS61A 过程抽象\"></a>CS61A 过程抽象</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>程序设计的基本元素</p>\n<ul>\n<li>表达式</li>\n<li>变量与环境</li>\n<li>复合过程与函数</li>\n<li>条件表达式与判定符号</li>\n<li>过程作为黑箱抽象</li>\n</ul>\n<p>过程产生的计算</p>\n<ul>\n<li>线性递归与迭代</li>\n<li>树形递归</li>\n</ul>\n<p>高阶函数抽象</p>\n<ul>\n<li>过程作为参数</li>\n<li>过程作为一般性的方法</li>\n<li>过程作为返回值</li>\n<li>使用匿名函数构造过程</li>\n</ul>\n</blockquote>\n<h3 id=\"程序设计的基本元素\"><a href=\"#程序设计的基本元素\" class=\"headerlink\" title=\"程序设计的基本元素\"></a>程序设计的基本元素</h3><hr>\n<p>一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：</p>\n<p>一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int(‘s’),这叫做复合表达式，表达式是语言最简单的个体。</p>\n<p>二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素</p>\n<p>三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用</p>\n<h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><p>以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;s&#x27;</span>,<span class=\"number\">1</span>,<span class=\"string\">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过将基本表达式进行组合，我们可以得到组合式</p>\n<blockquote>\n<p>3-1</p>\n<p>‘s’ + ‘e’</p>\n</blockquote>\n<p>组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">2</span>+(<span class=\"number\">4</span>*<span class=\"number\">6</span>))*(<span class=\"number\">3</span>+<span class=\"number\">5</span>+<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n\n<p> 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。</p>\n<p><img src=\"https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png\" alt=\"image-20210612194156857\"></p>\n<h4 id=\"变量与环境\"><a href=\"#变量与环境\" class=\"headerlink\" title=\"变量与环境\"></a>变量与环境</h4><p>我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用<code>pi*(2**2)</code>进行计算，当我们想要计算的半径变为3时，我们又得写表达<code>pi*(3**2)</code>,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用<code>pi*(r**2)</code>就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。</p>\n<p>不同语言定义变量的方式不同</p>\n<p>Lisp</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define</span> r <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Python</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> r = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。</p>\n<h4 id=\"复合过程与函数\"><a href=\"#复合过程与函数\" class=\"headerlink\" title=\"复合过程与函数\"></a>复合过程与函数</h4><p>由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象</p>\n<p>那么如果我们要对过程进行抽象该怎么办呢？</p>\n<p>过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，<strong>为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。</strong></p>\n<p>例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square</p>\n<p>不同语言定义函数/复合过程名称的方式不同</p>\n<p><em>Lisp</em></p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define</span> (<span class=\"name\">square</span> x) (<span class=\"name\">*</span> x x))</span><br></pre></td></tr></table></figure>\n\n<p><em>Python</em></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x**<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>定义好之后就可以使用square进行调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(sqare <span class=\"number\">21</span>)</span><br><span class=\"line\">square(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以利用已定义好的函数去构建其他过程，以python为例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_sq</span>(<span class=\"params\">x,y</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> square(x) + square(y)</span><br></pre></td></tr></table></figure>\n\n<p>还可以利用sum_sq去构造其他过程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">a</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum_aq(a,a)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"条件表达式与符号\"><a href=\"#条件表达式与符号\" class=\"headerlink\" title=\"条件表达式与符号\"></a>条件表达式与符号</h4><p>至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式</p>\n<p>不同的语言中条件表达式不同</p>\n<p><em>Lisp</em></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define</span> (<span class=\"name\">abs</span> x)</span><br><span class=\"line\">     (<span class=\"name\">cond</span>  (<span class=\"name\">&gt;</span> x <span class=\"number\">0</span>)x)</span><br><span class=\"line\">            (<span class=\"name\">=</span> x <span class=\"number\">0</span>)<span class=\"number\">0</span>)</span><br><span class=\"line\">            (&lt; x 0)(-x))</span><br><span class=\"line\">     )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Python没有switch语句，可以用if..elif…替代</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> x = <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> x &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure>\n\n<p>if是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。</p>\n<p>除了&gt;&lt;=之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。</p>\n<p>例如Lisp中</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">and</span>(<span class=\"name\">&gt;</span> x <span class=\"number\">5</span>)(<span class=\"name\">&lt;</span> x <span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数作为黑箱抽象\"><a href=\"#函数作为黑箱抽象\" class=\"headerlink\" title=\"函数作为黑箱抽象\"></a>函数作为黑箱抽象</h4><p>sqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的</p>\n<p><img src=\"https://i.loli.net/2021/06/12/u4zixB95rycdopg.png\" alt=\"image-20210612202953454\"></p>\n<p>这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。</p>\n<h5 id=\"内部定义与块结构\"><a href=\"#内部定义与块结构\" class=\"headerlink\" title=\"内部定义与块结构\"></a>内部定义与块结构</h5><p>为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。</p>\n<h3 id=\"函数产生的计算\"><a href=\"#函数产生的计算\" class=\"headerlink\" title=\"函数产生的计算\"></a>函数产生的计算</h3><hr>\n<h4 id=\"线性递归与迭代\"><a href=\"#线性递归与迭代\" class=\"headerlink\" title=\"线性递归与迭代\"></a>线性递归与迭代</h4><p>我们以函数的阶乘为例，讲解函数的递归和迭代。</p>\n<p>首先，我们使用递归来计算阶乘</p>\n<p>考虑阶乘函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n! = n*(n-<span class=\"number\">1</span>)*(n-<span class=\"number\">2</span>)..<span class=\"number\">.1</span></span><br><span class=\"line\">(n-<span class=\"number\">1</span>)! = (n-<span class=\"number\">1</span>)*(n-<span class=\"number\">2</span>)..<span class=\"number\">.1</span></span><br><span class=\"line\">n! = n*(n-<span class=\"number\">1</span>)! </span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就能通过算出(n-1)!，i进而计算出n！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个过程如图所示</p>\n<p><img src=\"https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png\" alt=\"image-20210612215413983\"></p>\n<p>于是我们总结出迭代所需要的三个要素：</p>\n<p><em>一是base_case也就是迭代终止条件</em></p>\n<p>*二是可迭代拆分的结构，比如<code>factorial(n)</code>的结果就可以分解成为<code>n * factorial(n-1)</code></p>\n<p><em>三是可以连续传递</em>，验证n与n-1的规则是否通用。</p>\n<p>但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如</p>\n<blockquote>\n<p>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：</p>\n<p>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,</p>\n<p>def pingpong(n): ?</p>\n</blockquote>\n<p>这里的<code>pingpong(n)</code>和<code>pingpong(n-1)</code>无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pingpong</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">itera</span>(<span class=\"params\">out,index=<span class=\"number\">1</span>,adder=<span class=\"number\">1</span></span>)</span></span><br><span class=\"line\">        if index == n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> out</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index%<span class=\"number\">7</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itera(out+adder,index+<span class=\"number\">1</span>,adder=-adder)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> itera(out+adder,index+<span class=\"number\">1</span>,adder=adder)</span><br><span class=\"line\">    out = itera(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out </span><br><span class=\"line\">            </span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。</p>\n<p>而后，我们再使用迭代对阶乘进行计算：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        a = a*i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n\n<p>由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。</p>\n<p>迭代的表示如下：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png\" alt=\"image-20210613110228758\"></p>\n<p>迭代和递归是两种最常见的循环过程，其主要不同点在于：</p>\n<p>一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。</p>\n<p>迭代：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png\" alt=\"image-20210613110437725\"></p>\n<p>递归：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png\" alt=\"image-20210613110636563\"></p>\n<p>二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。</p>\n<h4 id=\"树形递归\"><a href=\"#树形递归\" class=\"headerlink\" title=\"树形递归\"></a>树形递归</h4><p>树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。</p>\n<p>首先我们以递归的思路来考虑</p>\n<p><code>feb(n)</code>和<code>feb(n-1)</code>有什么关系？</p>\n<p>貌似没有关系，但是我们知道<code>feb(n)=feb(n-1)+feb(n-2)</code></p>\n<p>因此我们可以这样设计递归</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">feb</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n-<span class=\"number\">1</span>)+fib(n-<span class=\"number\">2</span>)</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n\n<p>这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：</p>\n<p><img src=\"https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png\" alt=\"image-20210613112437233\"></p>\n<p>树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题</p>\n<blockquote>\n<p>Q7：河内塔<br>一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。</p>\n<p><img src=\"https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png\" alt=\"image-20210613154038670\"></p>\n<p>拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：</p>\n<p>一次只能移动一个磁盘。<br>每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。<br>任何磁盘都不能放置在较小磁盘的顶部。<br>完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。</p>\n<p>题目给出了两个内置函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_move</span>(<span class=\"params\">origin, destination</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Print instructions to move a disk.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Move the top disk from rod&quot;</span>, origin, <span class=\"string\">&quot;to rod&quot;</span>, destination)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_stack</span>(<span class=\"params\">n, start, end</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Print the moves required to move n disks on the start pole to the end</span></span><br><span class=\"line\"><span class=\"string\">    pole without violating the rules of Towers of Hanoi.</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该<code>move_stack(3,1,3)</code>,而<code>move_stack(3,1,3)</code>这个过程可以分解为</p>\n<p>一.先将上面两层移动至2,即<code>move_stack(2,1,2)</code></p>\n<p>二.将底层移动到3,即<code>move_stack(1,1,3)</code></p>\n<p>三.将在2的两层移至3,即<code>move_stack(2,2,3)</code></p>\n<p>我们会发现实际上<code>move_stack(n,a,c)</code>可以分解为<code>move_stack(n-1,a,b)</code>，<code>move_stack(1,a,c)</code>,<code>move_stack(n-1,b,c)</code></p>\n<p>因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。</p>\n<p>具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move_stack</span>(<span class=\"params\">n,start,end</span>):</span></span><br><span class=\"line\">        bars = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        print_move(start,end)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        c=[bar <span class=\"keyword\">for</span> bar <span class=\"keyword\">in</span> bars <span class=\"keyword\">if</span> bar <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> [start,end] ]</span><br><span class=\"line\">        c = c[<span class=\"number\">0</span>]</span><br><span class=\"line\">        a = start</span><br><span class=\"line\">        b = end </span><br><span class=\"line\">        move_stack(n-<span class=\"number\">1</span>,a,c)</span><br><span class=\"line\">        move_stack(<span class=\"number\">1</span>,a,b)</span><br><span class=\"line\">        move_stack(n-<span class=\"number\">1</span>,c,b)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的base_case就是n==1。</p>\n<h3 id=\"高阶函数抽象\"><a href=\"#高阶函数抽象\" class=\"headerlink\" title=\"高阶函数抽象\"></a>高阶函数抽象</h3><hr>\n<h4 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h4><p>思考一下以下两个函数</p>\n<p>第一个 sum_naturals函数计算最大为n的自然数之和</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum_naturals</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + [k], k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二个sum_pi计算系列中的项的总和</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pi_sum</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + [<span class=\"number\">8</span> / ((<span class=\"number\">4</span>*k-<span class=\"number\">3</span>) * (<span class=\"number\">4</span>*k-<span class=\"number\">1</span>))], k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br></pre></td></tr></table></figure>\n\n<p>我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">xx</span> (<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + &lt;term&gt;(k), k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span>(<span class=\"params\">n,term</span>):</span></span><br><span class=\"line\">    total, k = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt;= n:</span><br><span class=\"line\">        total, k = total + term(k), k + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">natural</span>(<span class=\"params\">k</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pi</span>(<span class=\"params\">k</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">8</span> / ((<span class=\"number\">4</span>*k-<span class=\"number\">3</span>) * (<span class=\"number\">4</span>*k-<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。</p>\n<h4 id=\"函数作为一般性方法\"><a href=\"#函数作为一般性方法\" class=\"headerlink\" title=\"函数作为一般性方法\"></a>函数作为一般性方法</h4><p>刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">improve</span>(<span class=\"params\">update, close, guess=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\"><span class=\"number\">2</span>\t    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> close(guess):</span><br><span class=\"line\"><span class=\"number\">3</span>\t        guess = update(guess)</span><br><span class=\"line\"><span class=\"number\">4</span>\t    <span class=\"keyword\">return</span> guess</span><br><span class=\"line\"><span class=\"number\">5</span>\t</span><br><span class=\"line\"><span class=\"number\">6</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">golden_update</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\"><span class=\"number\">7</span>\t    <span class=\"keyword\">return</span> <span class=\"number\">1</span>/guess + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">8</span>\t</span><br><span class=\"line\"><span class=\"number\">9</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square_close_to_successor</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\"><span class=\"number\">10</span>\t    <span class=\"keyword\">return</span> approx_eq(guess * guess,</span><br><span class=\"line\"><span class=\"number\">11</span>\t                     guess + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">12</span>\t</span><br><span class=\"line\"><span class=\"number\">13</span>\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">approx_eq</span>(<span class=\"params\">x, y, tolerance=<span class=\"number\">1e-3</span></span>):</span></span><br><span class=\"line\"><span class=\"number\">14</span>\t    <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(x - y) &lt; tolerance</span><br><span class=\"line\"><span class=\"number\">15</span>\t</span><br><span class=\"line\"><span class=\"number\">16</span>\tphi = improve(golden_update,</span><br><span class=\"line\"><span class=\"number\">17</span>\t              square_close_to_successor)</span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">improve</span>(<span class=\"params\">guess=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">golden_update</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>/guess + <span class=\"number\">1</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">square_close_to_successor</span>(<span class=\"params\">guess</span>):</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> approx_eq(guess * guess,guess + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">approx_eq</span>(<span class=\"params\">x, y, tolerance=<span class=\"number\">1e-3</span></span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(x - y) &lt; tolerance</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> square_close_to_successor(guess):</span><br><span class=\"line\">        guess = golden_update(guess)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> guess</span><br><span class=\"line\"></span><br><span class=\"line\">phi = improve()</span><br></pre></td></tr></table></figure>\n\n<p>这样一来整体的函数结构就清晰多了。</p>\n<h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。</p>\n<p>一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用现有工具定义函数组合：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compose1</span>(<span class=\"params\">f, g</span>):</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">h</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> f(g(x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h</span><br></pre></td></tr></table></figure>\n\n<p>这时候返回的函数就是f(g(x))</p>\n<p>函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。</p>\n<p>柯里化的具体实现过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curi_pow</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">y</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(x,y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当调用<code>curi_pow(2)(3)</code>时，首先计算curi_pow(2),返回的函数实际上就是 <code>lambda  x: pow(2,x)</code>，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此<code>curi_pow(2)（3）</code>实际上是<code>lambda x:pow(2,x)(3)</code>也就是pow(2,3)</p>\n<p>我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">curi</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">h</span>(<span class=\"params\">y</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> f(x,y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g</span><br></pre></td></tr></table></figure>\n\n<p>具体推导过程 如下：</p>\n<p>要使得  s(x)(y) = f(x,y)，则s = lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。</p>\n<p>柯里化也可以反向进行，具体实现过程为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uncuri</span>(<span class=\"params\">g</span>):</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">h</span>(<span class=\"params\">x,y</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> g(x)(y)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> h</span><br></pre></td></tr></table></figure>\n\n<p>同理，要使得 f(x,y) = g(x)(y)，则 f = lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。</p>\n<h4 id=\"使用匿名函数构造过程\"><a href=\"#使用匿名函数构造过程\" class=\"headerlink\" title=\"使用匿名函数构造过程\"></a>使用匿名函数构造过程</h4><p>到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。</p>\n<p>lambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"keyword\">lambda</span> x:x*x</span><br><span class=\"line\">s(<span class=\"number\">2</span>) = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。</p>\n<p>一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose1=<span class=\"keyword\">lambda</span> f,g:<span class=\"keyword\">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。</p>\n<p>我们知道，使用递归来进行阶乘的计算如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n-<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>那么如果使用匿名函数来进行递归，结构又该是什么样的呢？</p>\n<p>我们先来看一个简单一点的方案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fact = <span class=\"keyword\">lambda</span> n:<span class=\"number\">1</span> <span class=\"keyword\">if</span> n==<span class=\"number\">1</span> <span class=\"keyword\">else</span> n*fact(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lambda</span> n,f:<span class=\"number\">1</span> <span class=\"keyword\">if</span> n==<span class=\"number\">1</span> <span class=\"keyword\">else</span> n*f(n-<span class=\"number\">1</span>,f) </span><br></pre></td></tr></table></figure>\n\n<p>于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact= lambda n,f:1 if n==1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。</p>\n<p>解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。</p>\n<p>fact = lambda n:(lambda g:g(n,f))(lambda n,f:1 if n==1 else n*f(n-1,f))</p>\n<p>这个结构的原理是这样的，fact(3)首先等于<code>(lambda f:f(3,f))</code>，然而由于后i面还有一个<code>(lambda n,f:1 if n==1 else n*f(n-1,f))</code>因此f函数的值被填充为匿名函数，成为f(3,f) 其中 <code>f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))</code>。</p>\n"},{"title":"CS61A-综述","date":"2021-06-12T07:04:18.000Z","cover":"/myimage/cs61/cs61a_all_cover.png","_content":"\n##  CS61A 综述\n\n简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。\n\n首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。\n\n而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。\n\n最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。\n\n本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。\n\n但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。\n\n从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。\n\n从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/CS61A-综述.md","raw":"---\ntitle: CS61A-综述\ndate: 2021-06-12 15:04:18\ntags:\n- 程序结构\n- CS61\n- CS61A\ncategories:\n- Learning Record\ncover: /myimage/cs61/cs61a_all_cover.png\n---\n\n##  CS61A 综述\n\n简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。\n\n首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。\n\n而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。\n\n最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。\n\n本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。\n\n但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。\n\n从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。\n\n从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"CS61A-综述","published":1,"updated":"2023-02-11T11:16:34.783Z","_id":"ckpwpwd070000qfrhdxjx5jnr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CS61A-综述\"><a href=\"#CS61A-综述\" class=\"headerlink\" title=\"CS61A 综述\"></a>CS61A 综述</h2><p>简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。</p>\n<p>首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。</p>\n<p>而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。</p>\n<p>最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。</p>\n<p>本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。</p>\n<p>但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。</p>\n<p>从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。</p>\n<p>从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":946,"excerpt":"","more":"<h2 id=\"CS61A-综述\"><a href=\"#CS61A-综述\" class=\"headerlink\" title=\"CS61A 综述\"></a>CS61A 综述</h2><p>简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。</p>\n<p>首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。</p>\n<p>而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。</p>\n<p>最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。</p>\n<p>本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。</p>\n<p>但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。</p>\n<p>从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。</p>\n<p>从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。</p>\n"},{"title":"CS61A-数据抽象","date":"2021-06-28T03:25:57.000Z","cover":"/myimage/cs61/cs61a_status_cover.png","_content":"\n## CS61A 数据抽象\n\n#### 目录\n\n>数据抽象导引\n>\n>* 构造器与选择器\n>* 序对的表示\n>* 抽象屏障与序对的过程性表示\n>\n>层次性数据和闭包性质\n>\n>* 序列的表示形式\n>* 可变数据与可变函数\n>* 层次性结构\n>* 迭代器与生成器\n>\n\n**带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。**\n\n### 数据抽象导引\n\n******************\n\n在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。\n\n**数据抽象就是指将数据对象组合起来，构成复合数据的形式。**\n\n这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即\n\n```python\ndef adder_without(a,b,c,d):\n    return (ad+bc)//bd\n\n如果我们要计算1/3+4/5，那么我们就得这样传入参数\n\n>>adder_without(1,3,4,5)\n17/15\n```\n\n我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。\n\n但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？\n\n答案就是构建构造函数与选择函数。\n\n#### 构造器与选择器\n\n接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：\n\n```python\ndef build(up,down)：\n    return [up,down]\n\n于是我们可以利用分子分母构建有理数a和b\n\na = build(1,3)\nb = build(4/5)\n\n```\n\n这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。\n\n```scheme\n(define (build up down) (cons up down)\n```\n\n而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：\n\n```python\ndef get_up(x):\n    return x[0]\ndef get_down(x):\n    return x[1]\n\n于是我们就可以使用以上两个函数提取数据\n\na_up = get_up(a)\nb_down = get_down(b)\n\n```\n\n利用构造器与选择器重写加法函数\n\n```python\ndef add(a,b):\n    return (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)\n\n使用构造函数\na = build(1,3)\nb = build(4,5)\n\nnew = add(a,b)\n```\n\n这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立`sub`,`mul`,`pow`等运算函数。\n\n#### 序对的表示\n\n其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：\n\n```python\na = [1,2,3,4]   List\nb = (1,2,3,4)   Tuple\nc = {'a':1,'b':2} Dict\n\nPython中万物皆对象，所以提取数据的方式非常简单\na[1]\nb[1]\nc['a']\n```\n\n在scheme语言中，序对表示为cons，但是cons只能有两个数据：\n\n```scheme\n(define x (cons 1 2)   #相当于x = [1,2],但是scheme没有python高级，实现序列需要cons函数\n  \n使用 car 和 cdr 提取数据\n(car x)\n(cdr x)\n  \n```\n\n#### 抽象屏障与序对的过程性表示\n\n抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：\n\n```  \n最高层： 使用有理数运算函数的过程\n\n第一层： 有理数运算函数 add() sub() mul() \n\n第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）\n                                             \n第三层： 作为序对的有理数 cons() car()  cdr()  /list[]  tuple[]\n```\n\n这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。\n\n例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：\n\n```python\ndef build(up,down): \n    g = gcd(up,down)\n    return [up/g,down/g]\n```\n\n这样就完成了约分有理数的过程。\n\n一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？\n\n````scheme\n(define (cons x y))\n  (define (dispatch m))\n    (cond (= m 0) x)\n    (cond (= m 1) y)\n    (else (error))\n    dispatch)\n(define (car z) (z 0))\n(define (cdr z) (z 1))\n````\n\n由此我们可以看出，序对的概念实际上也可以解释为，由`(cons x y)`返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。\n\nSICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？\n\n答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：\n\n```python\ndef zero(f):\n    return lambda x:x\n\ndef one(f):\n    return lambda x:f(x)\n\ndef two(f):\n    return lambda x:f(f(x))\n\n```\n\n使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上`one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) `),把这个结构抽象出来就得到：\n\n```python\n我们要实现 two = successor(one)\n所以 two = lambda f:lambda x:f(one(f)(x))\n令one = n 则有\n\ndef successor(n):\n    return lambda f:lambda x:f(n(f)(x))\n\n```\n\n选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：\n\n```\ndef church_to_int(n):\n    return n(lambda x:x+1)(0)\n\n这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10\n\n>>>church_to_int(one)\n1\n>>>church_to_int(three)\n3\n```\n\n同样也可以对church对象进行加法运算\n\n```python\ndef add_church(m, n):\n    \"\"\"Return the Church numeral for m + n, for Church numerals m and n.\n\n    >>> church_to_int(add_church(two, three))\n    5\n    \"\"\"\n    #church_to_int() if return 5 then five return five(f)\n    #so we have to make add_church(two,three) like five(f)\n    #five(f) return lambda x:f(f(f(f(f(x)))))  \n    return lambda f: lambda x: n(f)(x) +m(f)(x)\n\n```\n\nSICP中有church计数的scheme实现过程，大体类似。\n\n### 层次性数据和闭包性质\n\n我们可以建立元素本身也是序对/序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。\n\n#### 序列的表示形式\n\n在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：\n\n```scheme\n(cons 1 \n   (cons 2 \n       (cons 3 nil)))\n\nor\n\nlist(1,2,3)\n\ndef lists (list(1,2,3)):\n```\n\n通过上面的方式构建起`lists`这个表对象，而后使用cdr和car对表对象包含的数据进行调用\n\n```scheme\n(car lists)\n1\n(cdr lists)\n(2,3)\n(car(cdr lists))\n2\n```\n\n我们也可以构建函数返回表中的第n个项：\n\n```scheme\n(define (list-n list n))\n(if (= n 0)\n      (car list)\n      (list-n (cdr items) (- n 1))\n\n于是对lists对象使用\n    \n(list-n lists 2)\n2\n```\n\nscheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：\n\n```python\n同样的过程只需要\n\nlists = [1,2,3]\n\n调用返回第n项也只需要\n\na = lists[1]\n\n>>>a\n2\n```\n\n而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：\n\n```python\nlists1 = [1,2,3,[2,3,[1,1]]]\n```\n\n\n\n#### 可变数据与可变函数\n\n由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：\n\n```python\nsum([1,2,3],<stat>)\nadd(1,2,3)\nmin(1,2,3,key=)\nall()\nany()\nbool()\n```\n\n以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于**可变序列**，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：\n\n```python\n可变序列：\n[1,2,3].append('a')   \ndicts['a'] = 'a'\n不可变序列\n'abc'.append('a')    Error\n(1,2,4).append('a')   Error\n```\n\n具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表`list1 = [1,2,3,4]`：\n\n```python\ndef func(x):\n    list1.append(x)\n    list1.append(x)\n\n执行func(3)后list1会改变吗？\n\n<<<func(3)\n<<<list1\n[1,2,3,3,3]\n\n会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。\n```\n\n有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：\n\n```python\ndef get_money(my_money):\n     my_money -=20\n     return my_money\n\n>>>my_money = 100\n>>>my_money = get_money(20)\n>>>my_money = get_money(20)\n>>>my_money\n60\n```\n\n我们会发现这种方式很麻烦，因为要不断返回和重新赋值给`my_money`变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？\n\n有的，那就是**可变函数**。\n\n```python\ndef make_draw(balance):\n    def with_draw(acount):\n        nonlocal balance\n        if acount > balance\n            return \"error\"\n        else:\n            balance = balance - acount\n            return balance\n    return with_draw\n\n这样我们就可以实现\n\n>>>with_draw = make_draw(100)\n>>>with_draw(20)\n80\n>>>with_draw(20)\n60\n\n```\n\n这里出现了一个新的类型`nonlocal`，意思是非本地，也就是说，定义为`nonlocal`的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 `nonlocal`必须满足以下几个条件才能使用：\n\n>1.nonlocal 声明的变量必须存在于父框架\n>\n>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。\n\n我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？\n\n答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于`balance=balance-accont`这个表达式判断balance是本地变量，而后在`if account > balance`中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）\n\n有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：\n\n```python\ndef make_draw(balance):\n    b= []\n    b[0] = balance\n    def with_draw(acount):\n        nonlocal balance\n        if acount > balance\n            return \"error\"\n        else:\n            b[0] = b[0] - acount\n            return b[0]\n    return with_draw\n\n这样我们就可以实现\n\n>>>with_draw = make_draw(100)\n>>>with_draw(20)\n80\n>>>with_draw(20)\n60\n\n```\n\n这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。\n\n\n\n#### 层次性结构\n\n序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：\n\n```python\ndef tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\n\ndef label(tree\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\n\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\n\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\n\ndef print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n\n    >>> print_tree(tree(1))\n    1\n    >>> print_tree(tree(1, [tree(2)]))\n    1\n      2\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\n    >>> print_tree(numbers)\n    1\n      2\n      3\n        4\n        5\n      6\n        7\n    \"\"\"\n    print('  ' * indent + str(label(t)))\n    for b in branches(t):\n        print_tree(b, indent + 1)\n\n```\n\n以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。\n\n递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。\n\n我们来看几个关于树结构的问题\n\n```python\n问题一：替换具有指定数据的树节点\n\ndef replace_leaf(t, old, new):\n    \"\"\"Returns a new tree where every leaf value equal to old has\n    been replaced with new.\n\n    >>> yggdrasil = tree('odin',\n    ...                  [tree('balder',\n    ...                        [tree('thor'),\n    ...                         tree('freya')]),\n    ...                   tree('frigg',\n    ...                        [tree('thor')]),\n    ...                   tree('thor',\n    ...                        [tree('sif'),\n    ...                         tree('thor')]),\n    ...                   tree('thor')])\n    >>> laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes\n    >>> print_tree(replace_leaf(yggdrasil, 'thor', 'freya'))\n    odin\n      balder\n        freya\n        freya\n      frigg\n        freya\n      thor\n        sif\n        freya\n      freya\n    >>> laerad == yggdrasil # Make sure original tree is unmodified\n    True\n    \"\"\"\n    if is_leaf(t):\n        if label(t)==old:\n            return tree(new)\n        else:\n            return tree(label(t))\n    else:\n        return tree(label(t),[replace_leaf(b,old,new) for b in branches(t)])\n\n可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值\n```\n\n```python\n问题二：在每个叶节点上插入新子树\n\ndef sprout_leaves(t, vals):\n    \"\"\"Sprout new leaves containing the data in vals at each leaf in\n    the original tree t and return the resulting tree.\n\n    >>> t1 = tree(1, [tree(2), tree(3)])\n    >>> print_tree(t1)\n    1\n      2\n      3\n    >>> new1 = sprout_leaves(t1, [4, 5])\n    >>> print_tree(new1)\n    1\n      2\n        4\n        5\n      3\n        4\n        5\n\n    >>> t2 = tree(1, [tree(2, [tree(3)])])\n    >>> print_tree(t2)\n    1\n      2\n        3\n    >>> new2 = sprout_leaves(t2, [6, 1, 2])\n    >>> print_tree(new2)\n    1\n      2\n        3\n          6\n          1\n          2\n    \"\"\"\n    if is_leaf(t):\n        return tree(label(t),[tree(s) for s in vals ])\n    else:\n        '''\n        lsb = []\n        for b in branches(t):\n            lsb += sprout_leaves(b,vals)\n        return [tree(label(t),lsb)]\n        '''\n        return tree(label(t),[sprout_leaves(b,vals) for b in branches(t)])\n```\n\n下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。\n\n```python\n问题三：对应树的相加\n\ndef add_trees(t1, t2):\n    \"\"\"\n    >>> numbers = tree(1,\n    ...                [tree(2,\n    ...                      [tree(3),\n    ...                       tree(4)]),\n    ...                 tree(5,\n    ...                      [tree(6,\n    ...                            [tree(7)]),\n    ...                       tree(8)])])\n    >>> print_tree(add_trees(numbers, numbers))\n    2\n      4\n        6\n        8\n      10\n        12\n          14\n        16\n    >>> print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))\n    5\n      4\n      5\n    >>> print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))\n    4\n      6\n      4\n    >>> print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \\\n    tree(2, [tree(3, [tree(4)]), tree(5)])))\n    4\n      6\n        8\n        5\n      5\n    \"\"\"\n    if is_leaf(t1) and is_leaf(t2):\n        return(tree(label(t1)+label(t2)))\n    elif is_leaf(t1):\n        return tree((label(t1)+label(t2)),branches(t2))\n    elif is_leaf(t2):\n        return tree((label(t1)+label(t2)),branches(t1))\n    else:\n        lsp = []\n        node = label(t1)+label(t2)\n        zips = list(zip(branches(t1),branches(t2)))\n        if len(zips) == len(branches(t1)):\n            for b in zips:\n                lsp += [add_trees(b[0],b[1])]\n            lsp +=branches(t2)[len(zips):]\n            return tree(node,lsp)\n        if len(zips) == len(branches(t2)):\n            for b in zips:\n                lsp += [add_trees(b[0],b[1])]\n            lsp +=branches(t1)[len(zips):]\n            return tree(node,lsp)\n\n```\n\n这里所用到的zip函数请自行查阅python指南，解答过程如上。\n\n#### 迭代器与生成器\n\nPython和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。\n\n迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。\n\n````python\nprime = [1,2,3,4]   迭代值\niters = iter(prime)  迭代器\n````\n\n利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位\n\n```python\n>>>next(iters)\n1\n>>>next(iters)\n2\n>>>next(iters)\n3\n>>>next(iters)\n4\n>>>next(iters)\nStopIteration \n```\n\n当到达处理序列末尾后再次调用`next`方法将会引发StopIteration异常，说明序列已经迭代完毕。\n\n两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。\n\n```python\n>>> r  =  range ( 3 ,  13 ) \n>>> s  =  iter ( r )   # 第一个迭代器s\n>>> next ( s ) \n3 \n>>> next ( s ) \n4 \n>>> t  =  iter ( r )   # 第二个迭代器t \n>>> next ( t ) \n3 \n>>> next ( t ) \n4 \n>>> u  =  iter(t)  # 第二个迭代器的替代名称\n>>> next ( u ) \n5 \n>>> next ( u ) \n6\n```\n\n这里有一个利用迭代器计算斐波纳契数列的实例。\n\n````python\ndef fib_iter(n):\n    prev,curr=0,1\n    list = [prev,curr]\n    index = 2\n    while index < n:\n        prev,curr = curr,prev+curr\n        list +=[curr]\n        index ++\n    return iter(list)\n````\n\n使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。\n\n生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素\n\n生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。\n\n```python\ndef letters_generator():\n    current = 'a'\n    while current <='d':\n        yield current\n        current =chr(ord(current)+1)\n\n>>>letters = letters_generator()\n>>>next(letters)\na\n```\n\n再复杂一点可以这样使用生成器：\n\n```python\ndef natural():\n    x=0\n    while True:\n        yield x\n        x+1\n>>>ns1,ns2=natural(),natural()\n>>>[next(ns1)*next(ns2) for _ in range(5)]\n[0,1,4,9,16]\n```","source":"_posts/CS61A-数据抽象.md","raw":"---\ntitle: CS61A-数据抽象\ndate: 2021-06-28 11:25:57\ntags:\n- 程序结构\n- CS61\n- CS61A\ncategories:\n- Learning Record\ncover: /myimage/cs61/cs61a_status_cover.png\n---\n\n## CS61A 数据抽象\n\n#### 目录\n\n>数据抽象导引\n>\n>* 构造器与选择器\n>* 序对的表示\n>* 抽象屏障与序对的过程性表示\n>\n>层次性数据和闭包性质\n>\n>* 序列的表示形式\n>* 可变数据与可变函数\n>* 层次性结构\n>* 迭代器与生成器\n>\n\n**带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。**\n\n### 数据抽象导引\n\n******************\n\n在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。\n\n**数据抽象就是指将数据对象组合起来，构成复合数据的形式。**\n\n这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即\n\n```python\ndef adder_without(a,b,c,d):\n    return (ad+bc)//bd\n\n如果我们要计算1/3+4/5，那么我们就得这样传入参数\n\n>>adder_without(1,3,4,5)\n17/15\n```\n\n我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。\n\n但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？\n\n答案就是构建构造函数与选择函数。\n\n#### 构造器与选择器\n\n接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：\n\n```python\ndef build(up,down)：\n    return [up,down]\n\n于是我们可以利用分子分母构建有理数a和b\n\na = build(1,3)\nb = build(4/5)\n\n```\n\n这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。\n\n```scheme\n(define (build up down) (cons up down)\n```\n\n而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：\n\n```python\ndef get_up(x):\n    return x[0]\ndef get_down(x):\n    return x[1]\n\n于是我们就可以使用以上两个函数提取数据\n\na_up = get_up(a)\nb_down = get_down(b)\n\n```\n\n利用构造器与选择器重写加法函数\n\n```python\ndef add(a,b):\n    return (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)\n\n使用构造函数\na = build(1,3)\nb = build(4,5)\n\nnew = add(a,b)\n```\n\n这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立`sub`,`mul`,`pow`等运算函数。\n\n#### 序对的表示\n\n其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：\n\n```python\na = [1,2,3,4]   List\nb = (1,2,3,4)   Tuple\nc = {'a':1,'b':2} Dict\n\nPython中万物皆对象，所以提取数据的方式非常简单\na[1]\nb[1]\nc['a']\n```\n\n在scheme语言中，序对表示为cons，但是cons只能有两个数据：\n\n```scheme\n(define x (cons 1 2)   #相当于x = [1,2],但是scheme没有python高级，实现序列需要cons函数\n  \n使用 car 和 cdr 提取数据\n(car x)\n(cdr x)\n  \n```\n\n#### 抽象屏障与序对的过程性表示\n\n抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：\n\n```  \n最高层： 使用有理数运算函数的过程\n\n第一层： 有理数运算函数 add() sub() mul() \n\n第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）\n                                             \n第三层： 作为序对的有理数 cons() car()  cdr()  /list[]  tuple[]\n```\n\n这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。\n\n例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：\n\n```python\ndef build(up,down): \n    g = gcd(up,down)\n    return [up/g,down/g]\n```\n\n这样就完成了约分有理数的过程。\n\n一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？\n\n````scheme\n(define (cons x y))\n  (define (dispatch m))\n    (cond (= m 0) x)\n    (cond (= m 1) y)\n    (else (error))\n    dispatch)\n(define (car z) (z 0))\n(define (cdr z) (z 1))\n````\n\n由此我们可以看出，序对的概念实际上也可以解释为，由`(cons x y)`返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。\n\nSICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？\n\n答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：\n\n```python\ndef zero(f):\n    return lambda x:x\n\ndef one(f):\n    return lambda x:f(x)\n\ndef two(f):\n    return lambda x:f(f(x))\n\n```\n\n使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上`one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) `),把这个结构抽象出来就得到：\n\n```python\n我们要实现 two = successor(one)\n所以 two = lambda f:lambda x:f(one(f)(x))\n令one = n 则有\n\ndef successor(n):\n    return lambda f:lambda x:f(n(f)(x))\n\n```\n\n选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：\n\n```\ndef church_to_int(n):\n    return n(lambda x:x+1)(0)\n\n这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10\n\n>>>church_to_int(one)\n1\n>>>church_to_int(three)\n3\n```\n\n同样也可以对church对象进行加法运算\n\n```python\ndef add_church(m, n):\n    \"\"\"Return the Church numeral for m + n, for Church numerals m and n.\n\n    >>> church_to_int(add_church(two, three))\n    5\n    \"\"\"\n    #church_to_int() if return 5 then five return five(f)\n    #so we have to make add_church(two,three) like five(f)\n    #five(f) return lambda x:f(f(f(f(f(x)))))  \n    return lambda f: lambda x: n(f)(x) +m(f)(x)\n\n```\n\nSICP中有church计数的scheme实现过程，大体类似。\n\n### 层次性数据和闭包性质\n\n我们可以建立元素本身也是序对/序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。\n\n#### 序列的表示形式\n\n在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：\n\n```scheme\n(cons 1 \n   (cons 2 \n       (cons 3 nil)))\n\nor\n\nlist(1,2,3)\n\ndef lists (list(1,2,3)):\n```\n\n通过上面的方式构建起`lists`这个表对象，而后使用cdr和car对表对象包含的数据进行调用\n\n```scheme\n(car lists)\n1\n(cdr lists)\n(2,3)\n(car(cdr lists))\n2\n```\n\n我们也可以构建函数返回表中的第n个项：\n\n```scheme\n(define (list-n list n))\n(if (= n 0)\n      (car list)\n      (list-n (cdr items) (- n 1))\n\n于是对lists对象使用\n    \n(list-n lists 2)\n2\n```\n\nscheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：\n\n```python\n同样的过程只需要\n\nlists = [1,2,3]\n\n调用返回第n项也只需要\n\na = lists[1]\n\n>>>a\n2\n```\n\n而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：\n\n```python\nlists1 = [1,2,3,[2,3,[1,1]]]\n```\n\n\n\n#### 可变数据与可变函数\n\n由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：\n\n```python\nsum([1,2,3],<stat>)\nadd(1,2,3)\nmin(1,2,3,key=)\nall()\nany()\nbool()\n```\n\n以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于**可变序列**，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：\n\n```python\n可变序列：\n[1,2,3].append('a')   \ndicts['a'] = 'a'\n不可变序列\n'abc'.append('a')    Error\n(1,2,4).append('a')   Error\n```\n\n具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表`list1 = [1,2,3,4]`：\n\n```python\ndef func(x):\n    list1.append(x)\n    list1.append(x)\n\n执行func(3)后list1会改变吗？\n\n<<<func(3)\n<<<list1\n[1,2,3,3,3]\n\n会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。\n```\n\n有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：\n\n```python\ndef get_money(my_money):\n     my_money -=20\n     return my_money\n\n>>>my_money = 100\n>>>my_money = get_money(20)\n>>>my_money = get_money(20)\n>>>my_money\n60\n```\n\n我们会发现这种方式很麻烦，因为要不断返回和重新赋值给`my_money`变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？\n\n有的，那就是**可变函数**。\n\n```python\ndef make_draw(balance):\n    def with_draw(acount):\n        nonlocal balance\n        if acount > balance\n            return \"error\"\n        else:\n            balance = balance - acount\n            return balance\n    return with_draw\n\n这样我们就可以实现\n\n>>>with_draw = make_draw(100)\n>>>with_draw(20)\n80\n>>>with_draw(20)\n60\n\n```\n\n这里出现了一个新的类型`nonlocal`，意思是非本地，也就是说，定义为`nonlocal`的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 `nonlocal`必须满足以下几个条件才能使用：\n\n>1.nonlocal 声明的变量必须存在于父框架\n>\n>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。\n\n我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？\n\n答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于`balance=balance-accont`这个表达式判断balance是本地变量，而后在`if account > balance`中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）\n\n有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：\n\n```python\ndef make_draw(balance):\n    b= []\n    b[0] = balance\n    def with_draw(acount):\n        nonlocal balance\n        if acount > balance\n            return \"error\"\n        else:\n            b[0] = b[0] - acount\n            return b[0]\n    return with_draw\n\n这样我们就可以实现\n\n>>>with_draw = make_draw(100)\n>>>with_draw(20)\n80\n>>>with_draw(20)\n60\n\n```\n\n这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。\n\n\n\n#### 层次性结构\n\n序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：\n\n```python\ndef tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\n\ndef label(tree\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\n\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\n\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\n\ndef print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n\n    >>> print_tree(tree(1))\n    1\n    >>> print_tree(tree(1, [tree(2)]))\n    1\n      2\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\n    >>> print_tree(numbers)\n    1\n      2\n      3\n        4\n        5\n      6\n        7\n    \"\"\"\n    print('  ' * indent + str(label(t)))\n    for b in branches(t):\n        print_tree(b, indent + 1)\n\n```\n\n以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。\n\n递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。\n\n我们来看几个关于树结构的问题\n\n```python\n问题一：替换具有指定数据的树节点\n\ndef replace_leaf(t, old, new):\n    \"\"\"Returns a new tree where every leaf value equal to old has\n    been replaced with new.\n\n    >>> yggdrasil = tree('odin',\n    ...                  [tree('balder',\n    ...                        [tree('thor'),\n    ...                         tree('freya')]),\n    ...                   tree('frigg',\n    ...                        [tree('thor')]),\n    ...                   tree('thor',\n    ...                        [tree('sif'),\n    ...                         tree('thor')]),\n    ...                   tree('thor')])\n    >>> laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes\n    >>> print_tree(replace_leaf(yggdrasil, 'thor', 'freya'))\n    odin\n      balder\n        freya\n        freya\n      frigg\n        freya\n      thor\n        sif\n        freya\n      freya\n    >>> laerad == yggdrasil # Make sure original tree is unmodified\n    True\n    \"\"\"\n    if is_leaf(t):\n        if label(t)==old:\n            return tree(new)\n        else:\n            return tree(label(t))\n    else:\n        return tree(label(t),[replace_leaf(b,old,new) for b in branches(t)])\n\n可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值\n```\n\n```python\n问题二：在每个叶节点上插入新子树\n\ndef sprout_leaves(t, vals):\n    \"\"\"Sprout new leaves containing the data in vals at each leaf in\n    the original tree t and return the resulting tree.\n\n    >>> t1 = tree(1, [tree(2), tree(3)])\n    >>> print_tree(t1)\n    1\n      2\n      3\n    >>> new1 = sprout_leaves(t1, [4, 5])\n    >>> print_tree(new1)\n    1\n      2\n        4\n        5\n      3\n        4\n        5\n\n    >>> t2 = tree(1, [tree(2, [tree(3)])])\n    >>> print_tree(t2)\n    1\n      2\n        3\n    >>> new2 = sprout_leaves(t2, [6, 1, 2])\n    >>> print_tree(new2)\n    1\n      2\n        3\n          6\n          1\n          2\n    \"\"\"\n    if is_leaf(t):\n        return tree(label(t),[tree(s) for s in vals ])\n    else:\n        '''\n        lsb = []\n        for b in branches(t):\n            lsb += sprout_leaves(b,vals)\n        return [tree(label(t),lsb)]\n        '''\n        return tree(label(t),[sprout_leaves(b,vals) for b in branches(t)])\n```\n\n下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。\n\n```python\n问题三：对应树的相加\n\ndef add_trees(t1, t2):\n    \"\"\"\n    >>> numbers = tree(1,\n    ...                [tree(2,\n    ...                      [tree(3),\n    ...                       tree(4)]),\n    ...                 tree(5,\n    ...                      [tree(6,\n    ...                            [tree(7)]),\n    ...                       tree(8)])])\n    >>> print_tree(add_trees(numbers, numbers))\n    2\n      4\n        6\n        8\n      10\n        12\n          14\n        16\n    >>> print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))\n    5\n      4\n      5\n    >>> print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))\n    4\n      6\n      4\n    >>> print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \\\n    tree(2, [tree(3, [tree(4)]), tree(5)])))\n    4\n      6\n        8\n        5\n      5\n    \"\"\"\n    if is_leaf(t1) and is_leaf(t2):\n        return(tree(label(t1)+label(t2)))\n    elif is_leaf(t1):\n        return tree((label(t1)+label(t2)),branches(t2))\n    elif is_leaf(t2):\n        return tree((label(t1)+label(t2)),branches(t1))\n    else:\n        lsp = []\n        node = label(t1)+label(t2)\n        zips = list(zip(branches(t1),branches(t2)))\n        if len(zips) == len(branches(t1)):\n            for b in zips:\n                lsp += [add_trees(b[0],b[1])]\n            lsp +=branches(t2)[len(zips):]\n            return tree(node,lsp)\n        if len(zips) == len(branches(t2)):\n            for b in zips:\n                lsp += [add_trees(b[0],b[1])]\n            lsp +=branches(t1)[len(zips):]\n            return tree(node,lsp)\n\n```\n\n这里所用到的zip函数请自行查阅python指南，解答过程如上。\n\n#### 迭代器与生成器\n\nPython和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。\n\n迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。\n\n````python\nprime = [1,2,3,4]   迭代值\niters = iter(prime)  迭代器\n````\n\n利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位\n\n```python\n>>>next(iters)\n1\n>>>next(iters)\n2\n>>>next(iters)\n3\n>>>next(iters)\n4\n>>>next(iters)\nStopIteration \n```\n\n当到达处理序列末尾后再次调用`next`方法将会引发StopIteration异常，说明序列已经迭代完毕。\n\n两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。\n\n```python\n>>> r  =  range ( 3 ,  13 ) \n>>> s  =  iter ( r )   # 第一个迭代器s\n>>> next ( s ) \n3 \n>>> next ( s ) \n4 \n>>> t  =  iter ( r )   # 第二个迭代器t \n>>> next ( t ) \n3 \n>>> next ( t ) \n4 \n>>> u  =  iter(t)  # 第二个迭代器的替代名称\n>>> next ( u ) \n5 \n>>> next ( u ) \n6\n```\n\n这里有一个利用迭代器计算斐波纳契数列的实例。\n\n````python\ndef fib_iter(n):\n    prev,curr=0,1\n    list = [prev,curr]\n    index = 2\n    while index < n:\n        prev,curr = curr,prev+curr\n        list +=[curr]\n        index ++\n    return iter(list)\n````\n\n使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。\n\n生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素\n\n生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。\n\n```python\ndef letters_generator():\n    current = 'a'\n    while current <='d':\n        yield current\n        current =chr(ord(current)+1)\n\n>>>letters = letters_generator()\n>>>next(letters)\na\n```\n\n再复杂一点可以这样使用生成器：\n\n```python\ndef natural():\n    x=0\n    while True:\n        yield x\n        x+1\n>>>ns1,ns2=natural(),natural()\n>>>[next(ns1)*next(ns2) for _ in range(5)]\n[0,1,4,9,16]\n```","slug":"CS61A-数据抽象","published":1,"updated":"2023-02-11T11:16:22.749Z","_id":"ckqj7afay0000ydrh8uk999x0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CS61A-数据抽象\"><a href=\"#CS61A-数据抽象\" class=\"headerlink\" title=\"CS61A 数据抽象\"></a>CS61A 数据抽象</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>数据抽象导引</p>\n<ul>\n<li>构造器与选择器</li>\n<li>序对的表示</li>\n<li>抽象屏障与序对的过程性表示</li>\n</ul>\n<p>层次性数据和闭包性质</p>\n<ul>\n<li>序列的表示形式</li>\n<li>可变数据与可变函数</li>\n<li>层次性结构</li>\n<li>迭代器与生成器</li>\n</ul>\n</blockquote>\n<p><strong>带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。</strong></p>\n<h3 id=\"数据抽象导引\"><a href=\"#数据抽象导引\" class=\"headerlink\" title=\"数据抽象导引\"></a>数据抽象导引</h3><hr>\n<p>在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。</p>\n<p><strong>数据抽象就是指将数据对象组合起来，构成复合数据的形式。</strong></p>\n<p>这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">adder_without</span>(<span class=\"params\">a,b,c,d</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ad+bc)//bd</span><br><span class=\"line\"></span><br><span class=\"line\">如果我们要计算<span class=\"number\">1</span>/<span class=\"number\">3</span>+<span class=\"number\">4</span>/<span class=\"number\">5</span>，那么我们就得这样传入参数</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;adder_without(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"number\">17</span>/<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。</p>\n<p>但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？</p>\n<p>答案就是构建构造函数与选择函数。</p>\n<h4 id=\"构造器与选择器\"><a href=\"#构造器与选择器\" class=\"headerlink\" title=\"构造器与选择器\"></a>构造器与选择器</h4><p>接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span>(<span class=\"params\">up,down</span>)：</span></span><br><span class=\"line\">    return [up,down]</span><br><span class=\"line\"></span><br><span class=\"line\">于是我们可以利用分子分母构建有理数a和b</span><br><span class=\"line\"></span><br><span class=\"line\">a = build(<span class=\"number\">1</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">b = build(<span class=\"number\">4</span>/<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">build</span> up down) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> up down)</span><br></pre></td></tr></table></figure>\n\n<p>而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_up</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_down</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">于是我们就可以使用以上两个函数提取数据</span><br><span class=\"line\"></span><br><span class=\"line\">a_up = get_up(a)</span><br><span class=\"line\">b_down = get_down(b)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>利用构造器与选择器重写加法函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">a,b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)</span><br><span class=\"line\"></span><br><span class=\"line\">使用构造函数</span><br><span class=\"line\">a = build(<span class=\"number\">1</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">b = build(<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">new = add(a,b)</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立<code>sub</code>,<code>mul</code>,<code>pow</code>等运算函数。</p>\n<h4 id=\"序对的表示\"><a href=\"#序对的表示\" class=\"headerlink\" title=\"序对的表示\"></a>序对的表示</h4><p>其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]   <span class=\"type\">List</span></span><br><span class=\"line\">b = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)   <span class=\"type\">Tuple</span></span><br><span class=\"line\">c = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">2</span>&#125; <span class=\"type\">Dict</span></span><br><span class=\"line\"></span><br><span class=\"line\">Python中万物皆对象，所以提取数据的方式非常简单</span><br><span class=\"line\">a[<span class=\"number\">1</span>]</span><br><span class=\"line\">b[<span class=\"number\">1</span>]</span><br><span class=\"line\">c[<span class=\"string\">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在scheme语言中，序对表示为cons，但是cons只能有两个数据：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> x (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)   #相当于x = [<span class=\"name\">1</span>,<span class=\"number\">2</span>],但是scheme没有python高级，实现序列需要cons函数</span><br><span class=\"line\">  </span><br><span class=\"line\">使用 car 和 cdr 提取数据</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> x)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x)</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象屏障与序对的过程性表示\"><a href=\"#抽象屏障与序对的过程性表示\" class=\"headerlink\" title=\"抽象屏障与序对的过程性表示\"></a>抽象屏障与序对的过程性表示</h4><p>抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最高层： 使用有理数运算函数的过程</span><br><span class=\"line\"></span><br><span class=\"line\">第一层： 有理数运算函数 add() sub() mul() </span><br><span class=\"line\"></span><br><span class=\"line\">第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）</span><br><span class=\"line\">                                             </span><br><span class=\"line\">第三层： 作为序对的有理数 cons() car()  cdr()  &#x2F;list[]  tuple[]</span><br></pre></td></tr></table></figure>\n\n<p>这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。</p>\n<p>例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span>(<span class=\"params\">up,down</span>):</span> </span><br><span class=\"line\">    g = gcd(up,down)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [up/g,down/g]</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了约分有理数的过程。</p>\n<p>一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x y))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dispatch</span> m))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> m <span class=\"number\">0</span>) x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> m <span class=\"number\">1</span>) y)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span>))</span><br><span class=\"line\">    dispatch)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z) (<span class=\"name\">z</span> <span class=\"number\">0</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> z) (<span class=\"name\">z</span> <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>由此我们可以看出，序对的概念实际上也可以解释为，由<code>(cons x y)</code>返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。</p>\n<p>SICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？</p>\n<p>答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zero</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">one</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:f(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">two</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:f(f(x))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上<code>one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) </code>),把这个结构抽象出来就得到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们要实现 two = successor(one)</span><br><span class=\"line\">所以 two = <span class=\"keyword\">lambda</span> f:<span class=\"keyword\">lambda</span> x:f(one(f)(x))</span><br><span class=\"line\">令one = n 则有</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">successor</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> f:<span class=\"keyword\">lambda</span> x:f(n(f)(x))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def church_to_int(n):</span><br><span class=\"line\">    return n(lambda x:x+1)(0)</span><br><span class=\"line\"></span><br><span class=\"line\">这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;church_to_int(one)</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt;church_to_int(three)</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p>同样也可以对church对象进行加法运算</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_church</span>(<span class=\"params\">m, n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; church_to_int(add_church(two, three))</span></span><br><span class=\"line\"><span class=\"string\">    5</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#church_to_int() if return 5 then five return five(f)</span></span><br><span class=\"line\">    <span class=\"comment\">#so we have to make add_church(two,three) like five(f)</span></span><br><span class=\"line\">    <span class=\"comment\">#five(f) return lambda x:f(f(f(f(f(x)))))  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> f: <span class=\"keyword\">lambda</span> x: n(f)(x) +m(f)(x)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>SICP中有church计数的scheme实现过程，大体类似。</p>\n<h3 id=\"层次性数据和闭包性质\"><a href=\"#层次性数据和闭包性质\" class=\"headerlink\" title=\"层次性数据和闭包性质\"></a>层次性数据和闭包性质</h3><p>我们可以建立元素本身也是序对/序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。</p>\n<h4 id=\"序列的表示形式\"><a href=\"#序列的表示形式\" class=\"headerlink\" title=\"序列的表示形式\"></a>序列的表示形式</h4><p>在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> </span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">2</span> </span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> nil)))</span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">list(1,2,3)</span><br><span class=\"line\"></span><br><span class=\"line\">def lists (list(1,2,3)):</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的方式构建起<code>lists</code>这个表对象，而后使用cdr和car对表对象包含的数据进行调用</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> lists)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> lists)</span><br><span class=\"line\">(<span class=\"name\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span>(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> lists))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>我们也可以构建函数返回表中的第n个项：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">list-n</span> list n))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">car</span></span> list)</span><br><span class=\"line\">      (<span class=\"name\">list-n</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> items) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">于是对lists对象使用</span><br><span class=\"line\">    </span><br><span class=\"line\">(<span class=\"name\">list-n</span> lists <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>scheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同样的过程只需要</span><br><span class=\"line\"></span><br><span class=\"line\">lists = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">调用返回第n项也只需要</span><br><span class=\"line\"></span><br><span class=\"line\">a = lists[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;a</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lists1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,[<span class=\"number\">2</span>,<span class=\"number\">3</span>,[<span class=\"number\">1</span>,<span class=\"number\">1</span>]]]</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"可变数据与可变函数\"><a href=\"#可变数据与可变函数\" class=\"headerlink\" title=\"可变数据与可变函数\"></a>可变数据与可变函数</h4><p>由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sum</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],&lt;stat&gt;)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">min</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,key=)</span><br><span class=\"line\"><span class=\"built_in\">all</span>()</span><br><span class=\"line\"><span class=\"built_in\">any</span>()</span><br><span class=\"line\"><span class=\"built_in\">bool</span>()</span><br></pre></td></tr></table></figure>\n\n<p>以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于<strong>可变序列</strong>，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可变序列：</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].append(<span class=\"string\">&#x27;a&#x27;</span>)   </span><br><span class=\"line\">dicts[<span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">不可变序列</span><br><span class=\"line\"><span class=\"string\">&#x27;abc&#x27;</span>.append(<span class=\"string\">&#x27;a&#x27;</span>)    Error</span><br><span class=\"line\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>).append(<span class=\"string\">&#x27;a&#x27;</span>)   Error</span><br></pre></td></tr></table></figure>\n\n<p>具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表<code>list1 = [1,2,3,4]</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    list1.append(x)</span><br><span class=\"line\">    list1.append(x)</span><br><span class=\"line\"></span><br><span class=\"line\">执行func(<span class=\"number\">3</span>)后list1会改变吗？</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt;&lt;func(<span class=\"number\">3</span>)</span><br><span class=\"line\">&lt;&lt;&lt;list1</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。</span><br></pre></td></tr></table></figure>\n\n<p>有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_money</span>(<span class=\"params\">my_money</span>):</span></span><br><span class=\"line\">     my_money -=<span class=\"number\">20</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> my_money</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;my_money = <span class=\"number\">100</span></span><br><span class=\"line\">&gt;&gt;&gt;my_money = get_money(<span class=\"number\">20</span>)</span><br><span class=\"line\">&gt;&gt;&gt;my_money = get_money(<span class=\"number\">20</span>)</span><br><span class=\"line\">&gt;&gt;&gt;my_money</span><br><span class=\"line\"><span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>我们会发现这种方式很麻烦，因为要不断返回和重新赋值给<code>my_money</code>变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？</p>\n<p>有的，那就是<strong>可变函数</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_draw</span>(<span class=\"params\">balance</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">with_draw</span>(<span class=\"params\">acount</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> balance</span><br><span class=\"line\">        <span class=\"keyword\">if</span> acount &gt; balance</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            balance = balance - acount</span><br><span class=\"line\">            <span class=\"keyword\">return</span> balance</span><br><span class=\"line\">    <span class=\"keyword\">return</span> with_draw</span><br><span class=\"line\"></span><br><span class=\"line\">这样我们就可以实现</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;with_draw = make_draw(<span class=\"number\">100</span>)</span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">80</span></span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">60</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里出现了一个新的类型<code>nonlocal</code>，意思是非本地，也就是说，定义为<code>nonlocal</code>的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 <code>nonlocal</code>必须满足以下几个条件才能使用：</p>\n<blockquote>\n<p>1.nonlocal 声明的变量必须存在于父框架</p>\n<p>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。</p>\n</blockquote>\n<p>我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？</p>\n<p>答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于<code>balance=balance-accont</code>这个表达式判断balance是本地变量，而后在<code>if account &gt; balance</code>中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）</p>\n<p>有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_draw</span>(<span class=\"params\">balance</span>):</span></span><br><span class=\"line\">    b= []</span><br><span class=\"line\">    b[<span class=\"number\">0</span>] = balance</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">with_draw</span>(<span class=\"params\">acount</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> balance</span><br><span class=\"line\">        <span class=\"keyword\">if</span> acount &gt; balance</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            b[<span class=\"number\">0</span>] = b[<span class=\"number\">0</span>] - acount</span><br><span class=\"line\">            <span class=\"keyword\">return</span> b[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> with_draw</span><br><span class=\"line\"></span><br><span class=\"line\">这样我们就可以实现</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;with_draw = make_draw(<span class=\"number\">100</span>)</span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">80</span></span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">60</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。</p>\n<h4 id=\"层次性结构\"><a href=\"#层次性结构\" class=\"headerlink\" title=\"层次性结构\"></a>层次性结构</h4><p>序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tree</span>(<span class=\"params\">label, branches=[]</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> is_tree(branch), <span class=\"string\">&#x27;branches must be trees&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [label] + <span class=\"built_in\">list</span>(branches)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">label</span>(<span class=\"params\">tree</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">0</span>]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> branches(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">1</span>:]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> is_tree(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(<span class=\"params\">tree</span>) != <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">len</span>(<span class=\"params\">tree</span>) &lt; <span class=\"number\">1</span>:</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> is_tree(<span class=\"params\">branch</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> is_leaf(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    otherwise.</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> branches(<span class=\"params\">tree</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> print_tree(<span class=\"params\">t, indent=<span class=\"number\">0</span></span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    indented by two spaces times its depth from the root.</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1))</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; print_tree(numbers)</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      3</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">        4</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">        5</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      6</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">        7</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"built_in\">print</span>(<span class=\"params\"><span class=\"string\">&#x27;  &#x27;</span> * indent + <span class=\"built_in\">str</span>(<span class=\"params\">label(<span class=\"params\">t</span>)</span>)</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(<span class=\"params\">t</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        print_tree(<span class=\"params\">b, indent + <span class=\"number\">1</span></span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。</p>\n<p>递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。</p>\n<p>我们来看几个关于树结构的问题</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题一：替换具有指定数据的树节点</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">replace_leaf</span>(<span class=\"params\">t, old, new</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns a new tree where every leaf value equal to old has</span></span><br><span class=\"line\"><span class=\"string\">    been replaced with new.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                  [tree(&#x27;balder&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                        [tree(&#x27;thor&#x27;),</span></span><br><span class=\"line\"><span class=\"string\">    ...                         tree(&#x27;freya&#x27;)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                   tree(&#x27;frigg&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                        [tree(&#x27;thor&#x27;)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                   tree(&#x27;thor&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                        [tree(&#x27;sif&#x27;),</span></span><br><span class=\"line\"><span class=\"string\">    ...                         tree(&#x27;thor&#x27;)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                   tree(&#x27;thor&#x27;)])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))</span></span><br><span class=\"line\"><span class=\"string\">    odin</span></span><br><span class=\"line\"><span class=\"string\">      balder</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">      frigg</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">      thor</span></span><br><span class=\"line\"><span class=\"string\">        sif</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">      freya</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_leaf(t):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> label(t)==old:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(new)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(label(t))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree(label(t),[replace_leaf(b,old,new) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t)])</span><br><span class=\"line\"></span><br><span class=\"line\">可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题二：在每个叶节点上插入新子树</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sprout_leaves</span>(<span class=\"params\">t, vals</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Sprout new leaves containing the data in vals at each leaf in</span></span><br><span class=\"line\"><span class=\"string\">    the original tree t and return the resulting tree.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">      3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\">      3</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(t2)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">        3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(new2)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">        3</span></span><br><span class=\"line\"><span class=\"string\">          6</span></span><br><span class=\"line\"><span class=\"string\">          1</span></span><br><span class=\"line\"><span class=\"string\">          2</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_leaf(t):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree(label(t),[tree(s) <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> vals ])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        lsb = []</span></span><br><span class=\"line\"><span class=\"string\">        for b in branches(t):</span></span><br><span class=\"line\"><span class=\"string\">            lsb += sprout_leaves(b,vals)</span></span><br><span class=\"line\"><span class=\"string\">        return [tree(label(t),lsb)]</span></span><br><span class=\"line\"><span class=\"string\">        &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree(label(t),[sprout_leaves(b,vals) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t)])</span><br></pre></td></tr></table></figure>\n\n<p>下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题三：对应树的相加</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_trees</span>(<span class=\"params\">t1, t2</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; numbers = tree(1,</span></span><br><span class=\"line\"><span class=\"string\">    ...                [tree(2,</span></span><br><span class=\"line\"><span class=\"string\">    ...                      [tree(3),</span></span><br><span class=\"line\"><span class=\"string\">    ...                       tree(4)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                 tree(5,</span></span><br><span class=\"line\"><span class=\"string\">    ...                      [tree(6,</span></span><br><span class=\"line\"><span class=\"string\">    ...                            [tree(7)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                       tree(8)])])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(numbers, numbers))</span></span><br><span class=\"line\"><span class=\"string\">    2</span></span><br><span class=\"line\"><span class=\"string\">      4</span></span><br><span class=\"line\"><span class=\"string\">        6</span></span><br><span class=\"line\"><span class=\"string\">        8</span></span><br><span class=\"line\"><span class=\"string\">      10</span></span><br><span class=\"line\"><span class=\"string\">        12</span></span><br><span class=\"line\"><span class=\"string\">          14</span></span><br><span class=\"line\"><span class=\"string\">        16</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))</span></span><br><span class=\"line\"><span class=\"string\">    5</span></span><br><span class=\"line\"><span class=\"string\">      4</span></span><br><span class=\"line\"><span class=\"string\">      5</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))</span></span><br><span class=\"line\"><span class=\"string\">    4</span></span><br><span class=\"line\"><span class=\"string\">      6</span></span><br><span class=\"line\"><span class=\"string\">      4</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \\</span></span><br><span class=\"line\"><span class=\"string\">    tree(2, [tree(3, [tree(4)]), tree(5)])))</span></span><br><span class=\"line\"><span class=\"string\">    4</span></span><br><span class=\"line\"><span class=\"string\">      6</span></span><br><span class=\"line\"><span class=\"string\">        8</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\">      5</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_leaf(t1) <span class=\"keyword\">and</span> is_leaf(t2):</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(tree(label(t1)+label(t2)))</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> is_leaf(t1):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree((label(t1)+label(t2)),branches(t2))</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> is_leaf(t2):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree((label(t1)+label(t2)),branches(t1))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        lsp = []</span><br><span class=\"line\">        node = label(t1)+label(t2)</span><br><span class=\"line\">        zips = <span class=\"built_in\">list</span>(<span class=\"built_in\">zip</span>(branches(t1),branches(t2)))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(zips) == <span class=\"built_in\">len</span>(branches(t1)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> zips:</span><br><span class=\"line\">                lsp += [add_trees(b[<span class=\"number\">0</span>],b[<span class=\"number\">1</span>])]</span><br><span class=\"line\">            lsp +=branches(t2)[<span class=\"built_in\">len</span>(zips):]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(node,lsp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(zips) == <span class=\"built_in\">len</span>(branches(t2)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> zips:</span><br><span class=\"line\">                lsp += [add_trees(b[<span class=\"number\">0</span>],b[<span class=\"number\">1</span>])]</span><br><span class=\"line\">            lsp +=branches(t1)[<span class=\"built_in\">len</span>(zips):]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(node,lsp)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里所用到的zip函数请自行查阅python指南，解答过程如上。</p>\n<h4 id=\"迭代器与生成器\"><a href=\"#迭代器与生成器\" class=\"headerlink\" title=\"迭代器与生成器\"></a>迭代器与生成器</h4><p>Python和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。</p>\n<p>迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prime = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]   迭代值</span><br><span class=\"line\">iters = <span class=\"built_in\">iter</span>(prime)  迭代器</span><br></pre></td></tr></table></figure>\n\n<p>利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\">StopIteration </span><br></pre></td></tr></table></figure>\n\n<p>当到达处理序列末尾后再次调用<code>next</code>方法将会引发StopIteration异常，说明序列已经迭代完毕。</p>\n<p>两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r  =  <span class=\"built_in\">range</span> ( <span class=\"number\">3</span> ,  <span class=\"number\">13</span> ) </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s  =  <span class=\"built_in\">iter</span> ( r )   <span class=\"comment\"># 第一个迭代器s</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( s ) </span><br><span class=\"line\"><span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( s ) </span><br><span class=\"line\"><span class=\"number\">4</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t  =  <span class=\"built_in\">iter</span> ( r )   <span class=\"comment\"># 第二个迭代器t </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( t ) </span><br><span class=\"line\"><span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( t ) </span><br><span class=\"line\"><span class=\"number\">4</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>u  =  <span class=\"built_in\">iter</span>(t)  <span class=\"comment\"># 第二个迭代器的替代名称</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( u ) </span><br><span class=\"line\"><span class=\"number\">5</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( u ) </span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有一个利用迭代器计算斐波纳契数列的实例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib_iter</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    prev,curr=<span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = [prev,curr]</span><br><span class=\"line\">    index = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> index &lt; n:</span><br><span class=\"line\">        prev,curr = curr,prev+curr</span><br><span class=\"line\">        <span class=\"built_in\">list</span> +=[curr]</span><br><span class=\"line\">        index ++</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">iter</span>(<span class=\"built_in\">list</span>)</span><br></pre></td></tr></table></figure>\n\n<p>使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。</p>\n<p>生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素</p>\n<p>生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letters_generator</span>():</span></span><br><span class=\"line\">    current = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> current &lt;=<span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> current</span><br><span class=\"line\">        current =<span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(current)+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;letters = letters_generator()</span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(letters)</span><br><span class=\"line\">a</span><br></pre></td></tr></table></figure>\n\n<p>再复杂一点可以这样使用生成器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">natural</span>():</span></span><br><span class=\"line\">    x=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x</span><br><span class=\"line\">        x+<span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;&gt;ns1,ns2=natural(),natural()</span><br><span class=\"line\">&gt;&gt;&gt;[<span class=\"built_in\">next</span>(ns1)*<span class=\"built_in\">next</span>(ns2) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)]</span><br><span class=\"line\">[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">16</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":12350,"excerpt":"","more":"<h2 id=\"CS61A-数据抽象\"><a href=\"#CS61A-数据抽象\" class=\"headerlink\" title=\"CS61A 数据抽象\"></a>CS61A 数据抽象</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>数据抽象导引</p>\n<ul>\n<li>构造器与选择器</li>\n<li>序对的表示</li>\n<li>抽象屏障与序对的过程性表示</li>\n</ul>\n<p>层次性数据和闭包性质</p>\n<ul>\n<li>序列的表示形式</li>\n<li>可变数据与可变函数</li>\n<li>层次性结构</li>\n<li>迭代器与生成器</li>\n</ul>\n</blockquote>\n<p><strong>带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。</strong></p>\n<h3 id=\"数据抽象导引\"><a href=\"#数据抽象导引\" class=\"headerlink\" title=\"数据抽象导引\"></a>数据抽象导引</h3><hr>\n<p>在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。</p>\n<p><strong>数据抽象就是指将数据对象组合起来，构成复合数据的形式。</strong></p>\n<p>这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">adder_without</span>(<span class=\"params\">a,b,c,d</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ad+bc)//bd</span><br><span class=\"line\"></span><br><span class=\"line\">如果我们要计算<span class=\"number\">1</span>/<span class=\"number\">3</span>+<span class=\"number\">4</span>/<span class=\"number\">5</span>，那么我们就得这样传入参数</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;adder_without(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"number\">17</span>/<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。</p>\n<p>但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？</p>\n<p>答案就是构建构造函数与选择函数。</p>\n<h4 id=\"构造器与选择器\"><a href=\"#构造器与选择器\" class=\"headerlink\" title=\"构造器与选择器\"></a>构造器与选择器</h4><p>接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span>(<span class=\"params\">up,down</span>)：</span></span><br><span class=\"line\">    return [up,down]</span><br><span class=\"line\"></span><br><span class=\"line\">于是我们可以利用分子分母构建有理数a和b</span><br><span class=\"line\"></span><br><span class=\"line\">a = build(<span class=\"number\">1</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">b = build(<span class=\"number\">4</span>/<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">build</span> up down) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> up down)</span><br></pre></td></tr></table></figure>\n\n<p>而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_up</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_down</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">于是我们就可以使用以上两个函数提取数据</span><br><span class=\"line\"></span><br><span class=\"line\">a_up = get_up(a)</span><br><span class=\"line\">b_down = get_down(b)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>利用构造器与选择器重写加法函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">a,b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)</span><br><span class=\"line\"></span><br><span class=\"line\">使用构造函数</span><br><span class=\"line\">a = build(<span class=\"number\">1</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">b = build(<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">new = add(a,b)</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立<code>sub</code>,<code>mul</code>,<code>pow</code>等运算函数。</p>\n<h4 id=\"序对的表示\"><a href=\"#序对的表示\" class=\"headerlink\" title=\"序对的表示\"></a>序对的表示</h4><p>其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]   <span class=\"type\">List</span></span><br><span class=\"line\">b = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)   <span class=\"type\">Tuple</span></span><br><span class=\"line\">c = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">2</span>&#125; <span class=\"type\">Dict</span></span><br><span class=\"line\"></span><br><span class=\"line\">Python中万物皆对象，所以提取数据的方式非常简单</span><br><span class=\"line\">a[<span class=\"number\">1</span>]</span><br><span class=\"line\">b[<span class=\"number\">1</span>]</span><br><span class=\"line\">c[<span class=\"string\">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在scheme语言中，序对表示为cons，但是cons只能有两个数据：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> x (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)   #相当于x = [<span class=\"name\">1</span>,<span class=\"number\">2</span>],但是scheme没有python高级，实现序列需要cons函数</span><br><span class=\"line\">  </span><br><span class=\"line\">使用 car 和 cdr 提取数据</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> x)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x)</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象屏障与序对的过程性表示\"><a href=\"#抽象屏障与序对的过程性表示\" class=\"headerlink\" title=\"抽象屏障与序对的过程性表示\"></a>抽象屏障与序对的过程性表示</h4><p>抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最高层： 使用有理数运算函数的过程</span><br><span class=\"line\"></span><br><span class=\"line\">第一层： 有理数运算函数 add() sub() mul() </span><br><span class=\"line\"></span><br><span class=\"line\">第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）</span><br><span class=\"line\">                                             </span><br><span class=\"line\">第三层： 作为序对的有理数 cons() car()  cdr()  &#x2F;list[]  tuple[]</span><br></pre></td></tr></table></figure>\n\n<p>这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。</p>\n<p>例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span>(<span class=\"params\">up,down</span>):</span> </span><br><span class=\"line\">    g = gcd(up,down)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [up/g,down/g]</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了约分有理数的过程。</p>\n<p>一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x y))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dispatch</span> m))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> m <span class=\"number\">0</span>) x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> m <span class=\"number\">1</span>) y)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span>))</span><br><span class=\"line\">    dispatch)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z) (<span class=\"name\">z</span> <span class=\"number\">0</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> z) (<span class=\"name\">z</span> <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>由此我们可以看出，序对的概念实际上也可以解释为，由<code>(cons x y)</code>返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。</p>\n<p>SICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？</p>\n<p>答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zero</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">one</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:f(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">two</span>(<span class=\"params\">f</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:f(f(x))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上<code>one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) </code>),把这个结构抽象出来就得到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们要实现 two = successor(one)</span><br><span class=\"line\">所以 two = <span class=\"keyword\">lambda</span> f:<span class=\"keyword\">lambda</span> x:f(one(f)(x))</span><br><span class=\"line\">令one = n 则有</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">successor</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> f:<span class=\"keyword\">lambda</span> x:f(n(f)(x))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def church_to_int(n):</span><br><span class=\"line\">    return n(lambda x:x+1)(0)</span><br><span class=\"line\"></span><br><span class=\"line\">这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;church_to_int(one)</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt;church_to_int(three)</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p>同样也可以对church对象进行加法运算</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_church</span>(<span class=\"params\">m, n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; church_to_int(add_church(two, three))</span></span><br><span class=\"line\"><span class=\"string\">    5</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">#church_to_int() if return 5 then five return five(f)</span></span><br><span class=\"line\">    <span class=\"comment\">#so we have to make add_church(two,three) like five(f)</span></span><br><span class=\"line\">    <span class=\"comment\">#five(f) return lambda x:f(f(f(f(f(x)))))  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> f: <span class=\"keyword\">lambda</span> x: n(f)(x) +m(f)(x)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>SICP中有church计数的scheme实现过程，大体类似。</p>\n<h3 id=\"层次性数据和闭包性质\"><a href=\"#层次性数据和闭包性质\" class=\"headerlink\" title=\"层次性数据和闭包性质\"></a>层次性数据和闭包性质</h3><p>我们可以建立元素本身也是序对/序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。</p>\n<h4 id=\"序列的表示形式\"><a href=\"#序列的表示形式\" class=\"headerlink\" title=\"序列的表示形式\"></a>序列的表示形式</h4><p>在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> </span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">2</span> </span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> nil)))</span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">list(1,2,3)</span><br><span class=\"line\"></span><br><span class=\"line\">def lists (list(1,2,3)):</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的方式构建起<code>lists</code>这个表对象，而后使用cdr和car对表对象包含的数据进行调用</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> lists)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> lists)</span><br><span class=\"line\">(<span class=\"name\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span>(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> lists))</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>我们也可以构建函数返回表中的第n个项：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">list-n</span> list n))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">car</span></span> list)</span><br><span class=\"line\">      (<span class=\"name\">list-n</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> items) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">于是对lists对象使用</span><br><span class=\"line\">    </span><br><span class=\"line\">(<span class=\"name\">list-n</span> lists <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>scheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同样的过程只需要</span><br><span class=\"line\"></span><br><span class=\"line\">lists = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">调用返回第n项也只需要</span><br><span class=\"line\"></span><br><span class=\"line\">a = lists[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;a</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lists1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,[<span class=\"number\">2</span>,<span class=\"number\">3</span>,[<span class=\"number\">1</span>,<span class=\"number\">1</span>]]]</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"可变数据与可变函数\"><a href=\"#可变数据与可变函数\" class=\"headerlink\" title=\"可变数据与可变函数\"></a>可变数据与可变函数</h4><p>由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sum</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],&lt;stat&gt;)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">min</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,key=)</span><br><span class=\"line\"><span class=\"built_in\">all</span>()</span><br><span class=\"line\"><span class=\"built_in\">any</span>()</span><br><span class=\"line\"><span class=\"built_in\">bool</span>()</span><br></pre></td></tr></table></figure>\n\n<p>以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于<strong>可变序列</strong>，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可变序列：</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].append(<span class=\"string\">&#x27;a&#x27;</span>)   </span><br><span class=\"line\">dicts[<span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">不可变序列</span><br><span class=\"line\"><span class=\"string\">&#x27;abc&#x27;</span>.append(<span class=\"string\">&#x27;a&#x27;</span>)    Error</span><br><span class=\"line\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>).append(<span class=\"string\">&#x27;a&#x27;</span>)   Error</span><br></pre></td></tr></table></figure>\n\n<p>具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表<code>list1 = [1,2,3,4]</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    list1.append(x)</span><br><span class=\"line\">    list1.append(x)</span><br><span class=\"line\"></span><br><span class=\"line\">执行func(<span class=\"number\">3</span>)后list1会改变吗？</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&lt;&lt;func(<span class=\"number\">3</span>)</span><br><span class=\"line\">&lt;&lt;&lt;list1</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。</span><br></pre></td></tr></table></figure>\n\n<p>有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_money</span>(<span class=\"params\">my_money</span>):</span></span><br><span class=\"line\">     my_money -=<span class=\"number\">20</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> my_money</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;my_money = <span class=\"number\">100</span></span><br><span class=\"line\">&gt;&gt;&gt;my_money = get_money(<span class=\"number\">20</span>)</span><br><span class=\"line\">&gt;&gt;&gt;my_money = get_money(<span class=\"number\">20</span>)</span><br><span class=\"line\">&gt;&gt;&gt;my_money</span><br><span class=\"line\"><span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>我们会发现这种方式很麻烦，因为要不断返回和重新赋值给<code>my_money</code>变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？</p>\n<p>有的，那就是<strong>可变函数</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_draw</span>(<span class=\"params\">balance</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">with_draw</span>(<span class=\"params\">acount</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> balance</span><br><span class=\"line\">        <span class=\"keyword\">if</span> acount &gt; balance</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            balance = balance - acount</span><br><span class=\"line\">            <span class=\"keyword\">return</span> balance</span><br><span class=\"line\">    <span class=\"keyword\">return</span> with_draw</span><br><span class=\"line\"></span><br><span class=\"line\">这样我们就可以实现</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;with_draw = make_draw(<span class=\"number\">100</span>)</span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">80</span></span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">60</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里出现了一个新的类型<code>nonlocal</code>，意思是非本地，也就是说，定义为<code>nonlocal</code>的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 <code>nonlocal</code>必须满足以下几个条件才能使用：</p>\n<blockquote>\n<p>1.nonlocal 声明的变量必须存在于父框架</p>\n<p>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。</p>\n</blockquote>\n<p>我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？</p>\n<p>答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于<code>balance=balance-accont</code>这个表达式判断balance是本地变量，而后在<code>if account &gt; balance</code>中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）</p>\n<p>有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_draw</span>(<span class=\"params\">balance</span>):</span></span><br><span class=\"line\">    b= []</span><br><span class=\"line\">    b[<span class=\"number\">0</span>] = balance</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">with_draw</span>(<span class=\"params\">acount</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> balance</span><br><span class=\"line\">        <span class=\"keyword\">if</span> acount &gt; balance</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            b[<span class=\"number\">0</span>] = b[<span class=\"number\">0</span>] - acount</span><br><span class=\"line\">            <span class=\"keyword\">return</span> b[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> with_draw</span><br><span class=\"line\"></span><br><span class=\"line\">这样我们就可以实现</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;with_draw = make_draw(<span class=\"number\">100</span>)</span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">80</span></span><br><span class=\"line\">&gt;&gt;&gt;with_draw(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">60</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。</p>\n<h4 id=\"层次性结构\"><a href=\"#层次性结构\" class=\"headerlink\" title=\"层次性结构\"></a>层次性结构</h4><p>序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tree</span>(<span class=\"params\">label, branches=[]</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> is_tree(branch), <span class=\"string\">&#x27;branches must be trees&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [label] + <span class=\"built_in\">list</span>(branches)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">label</span>(<span class=\"params\">tree</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">0</span>]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> branches(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">1</span>:]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> is_tree(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(<span class=\"params\">tree</span>) != <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">len</span>(<span class=\"params\">tree</span>) &lt; <span class=\"number\">1</span>:</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> is_tree(<span class=\"params\">branch</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> is_leaf(<span class=\"params\">tree</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    otherwise.</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> branches(<span class=\"params\">tree</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">def</span> print_tree(<span class=\"params\">t, indent=<span class=\"number\">0</span></span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"string\">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    indented by two spaces times its depth from the root.</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\"></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1))</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &gt;&gt;&gt; print_tree(numbers)</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      3</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">        4</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">        5</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">      6</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">        7</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">    &quot;&quot;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"built_in\">print</span>(<span class=\"params\"><span class=\"string\">&#x27;  &#x27;</span> * indent + <span class=\"built_in\">str</span>(<span class=\"params\">label(<span class=\"params\">t</span>)</span>)</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(<span class=\"params\">t</span>):</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        print_tree(<span class=\"params\">b, indent + <span class=\"number\">1</span></span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。</p>\n<p>递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。</p>\n<p>我们来看几个关于树结构的问题</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题一：替换具有指定数据的树节点</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">replace_leaf</span>(<span class=\"params\">t, old, new</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns a new tree where every leaf value equal to old has</span></span><br><span class=\"line\"><span class=\"string\">    been replaced with new.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                  [tree(&#x27;balder&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                        [tree(&#x27;thor&#x27;),</span></span><br><span class=\"line\"><span class=\"string\">    ...                         tree(&#x27;freya&#x27;)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                   tree(&#x27;frigg&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                        [tree(&#x27;thor&#x27;)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                   tree(&#x27;thor&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    ...                        [tree(&#x27;sif&#x27;),</span></span><br><span class=\"line\"><span class=\"string\">    ...                         tree(&#x27;thor&#x27;)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                   tree(&#x27;thor&#x27;)])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))</span></span><br><span class=\"line\"><span class=\"string\">    odin</span></span><br><span class=\"line\"><span class=\"string\">      balder</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">      frigg</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">      thor</span></span><br><span class=\"line\"><span class=\"string\">        sif</span></span><br><span class=\"line\"><span class=\"string\">        freya</span></span><br><span class=\"line\"><span class=\"string\">      freya</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_leaf(t):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> label(t)==old:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(new)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(label(t))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree(label(t),[replace_leaf(b,old,new) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t)])</span><br><span class=\"line\"></span><br><span class=\"line\">可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题二：在每个叶节点上插入新子树</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sprout_leaves</span>(<span class=\"params\">t, vals</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Sprout new leaves containing the data in vals at each leaf in</span></span><br><span class=\"line\"><span class=\"string\">    the original tree t and return the resulting tree.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">      3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\">      3</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(t2)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">        3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(new2)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">        3</span></span><br><span class=\"line\"><span class=\"string\">          6</span></span><br><span class=\"line\"><span class=\"string\">          1</span></span><br><span class=\"line\"><span class=\"string\">          2</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_leaf(t):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree(label(t),[tree(s) <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> vals ])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        lsb = []</span></span><br><span class=\"line\"><span class=\"string\">        for b in branches(t):</span></span><br><span class=\"line\"><span class=\"string\">            lsb += sprout_leaves(b,vals)</span></span><br><span class=\"line\"><span class=\"string\">        return [tree(label(t),lsb)]</span></span><br><span class=\"line\"><span class=\"string\">        &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree(label(t),[sprout_leaves(b,vals) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t)])</span><br></pre></td></tr></table></figure>\n\n<p>下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题三：对应树的相加</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_trees</span>(<span class=\"params\">t1, t2</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; numbers = tree(1,</span></span><br><span class=\"line\"><span class=\"string\">    ...                [tree(2,</span></span><br><span class=\"line\"><span class=\"string\">    ...                      [tree(3),</span></span><br><span class=\"line\"><span class=\"string\">    ...                       tree(4)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                 tree(5,</span></span><br><span class=\"line\"><span class=\"string\">    ...                      [tree(6,</span></span><br><span class=\"line\"><span class=\"string\">    ...                            [tree(7)]),</span></span><br><span class=\"line\"><span class=\"string\">    ...                       tree(8)])])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(numbers, numbers))</span></span><br><span class=\"line\"><span class=\"string\">    2</span></span><br><span class=\"line\"><span class=\"string\">      4</span></span><br><span class=\"line\"><span class=\"string\">        6</span></span><br><span class=\"line\"><span class=\"string\">        8</span></span><br><span class=\"line\"><span class=\"string\">      10</span></span><br><span class=\"line\"><span class=\"string\">        12</span></span><br><span class=\"line\"><span class=\"string\">          14</span></span><br><span class=\"line\"><span class=\"string\">        16</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))</span></span><br><span class=\"line\"><span class=\"string\">    5</span></span><br><span class=\"line\"><span class=\"string\">      4</span></span><br><span class=\"line\"><span class=\"string\">      5</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))</span></span><br><span class=\"line\"><span class=\"string\">    4</span></span><br><span class=\"line\"><span class=\"string\">      6</span></span><br><span class=\"line\"><span class=\"string\">      4</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \\</span></span><br><span class=\"line\"><span class=\"string\">    tree(2, [tree(3, [tree(4)]), tree(5)])))</span></span><br><span class=\"line\"><span class=\"string\">    4</span></span><br><span class=\"line\"><span class=\"string\">      6</span></span><br><span class=\"line\"><span class=\"string\">        8</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\">      5</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> is_leaf(t1) <span class=\"keyword\">and</span> is_leaf(t2):</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(tree(label(t1)+label(t2)))</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> is_leaf(t1):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree((label(t1)+label(t2)),branches(t2))</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> is_leaf(t2):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree((label(t1)+label(t2)),branches(t1))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        lsp = []</span><br><span class=\"line\">        node = label(t1)+label(t2)</span><br><span class=\"line\">        zips = <span class=\"built_in\">list</span>(<span class=\"built_in\">zip</span>(branches(t1),branches(t2)))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(zips) == <span class=\"built_in\">len</span>(branches(t1)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> zips:</span><br><span class=\"line\">                lsp += [add_trees(b[<span class=\"number\">0</span>],b[<span class=\"number\">1</span>])]</span><br><span class=\"line\">            lsp +=branches(t2)[<span class=\"built_in\">len</span>(zips):]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(node,lsp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(zips) == <span class=\"built_in\">len</span>(branches(t2)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> zips:</span><br><span class=\"line\">                lsp += [add_trees(b[<span class=\"number\">0</span>],b[<span class=\"number\">1</span>])]</span><br><span class=\"line\">            lsp +=branches(t1)[<span class=\"built_in\">len</span>(zips):]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree(node,lsp)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里所用到的zip函数请自行查阅python指南，解答过程如上。</p>\n<h4 id=\"迭代器与生成器\"><a href=\"#迭代器与生成器\" class=\"headerlink\" title=\"迭代器与生成器\"></a>迭代器与生成器</h4><p>Python和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。</p>\n<p>迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prime = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]   迭代值</span><br><span class=\"line\">iters = <span class=\"built_in\">iter</span>(prime)  迭代器</span><br></pre></td></tr></table></figure>\n\n<p>利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(iters)</span><br><span class=\"line\">StopIteration </span><br></pre></td></tr></table></figure>\n\n<p>当到达处理序列末尾后再次调用<code>next</code>方法将会引发StopIteration异常，说明序列已经迭代完毕。</p>\n<p>两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r  =  <span class=\"built_in\">range</span> ( <span class=\"number\">3</span> ,  <span class=\"number\">13</span> ) </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s  =  <span class=\"built_in\">iter</span> ( r )   <span class=\"comment\"># 第一个迭代器s</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( s ) </span><br><span class=\"line\"><span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( s ) </span><br><span class=\"line\"><span class=\"number\">4</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t  =  <span class=\"built_in\">iter</span> ( r )   <span class=\"comment\"># 第二个迭代器t </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( t ) </span><br><span class=\"line\"><span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( t ) </span><br><span class=\"line\"><span class=\"number\">4</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>u  =  <span class=\"built_in\">iter</span>(t)  <span class=\"comment\"># 第二个迭代器的替代名称</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( u ) </span><br><span class=\"line\"><span class=\"number\">5</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span> ( u ) </span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有一个利用迭代器计算斐波纳契数列的实例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib_iter</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    prev,curr=<span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = [prev,curr]</span><br><span class=\"line\">    index = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> index &lt; n:</span><br><span class=\"line\">        prev,curr = curr,prev+curr</span><br><span class=\"line\">        <span class=\"built_in\">list</span> +=[curr]</span><br><span class=\"line\">        index ++</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">iter</span>(<span class=\"built_in\">list</span>)</span><br></pre></td></tr></table></figure>\n\n<p>使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。</p>\n<p>生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素</p>\n<p>生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">letters_generator</span>():</span></span><br><span class=\"line\">    current = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> current &lt;=<span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> current</span><br><span class=\"line\">        current =<span class=\"built_in\">chr</span>(<span class=\"built_in\">ord</span>(current)+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;letters = letters_generator()</span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">next</span>(letters)</span><br><span class=\"line\">a</span><br></pre></td></tr></table></figure>\n\n<p>再复杂一点可以这样使用生成器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">natural</span>():</span></span><br><span class=\"line\">    x=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x</span><br><span class=\"line\">        x+<span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;&gt;ns1,ns2=natural(),natural()</span><br><span class=\"line\">&gt;&gt;&gt;[<span class=\"built_in\">next</span>(ns1)*<span class=\"built_in\">next</span>(ns2) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)]</span><br><span class=\"line\">[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">16</span>]</span><br></pre></td></tr></table></figure>"},{"title":"CS61A-元语言抽象","date":"2021-08-08T07:56:30.000Z","cover":"/myimage/cs61/cs61a_language_cover.png","_content":"\n## CS61A 元语言抽象\n\n#### 目录\n\n> Scheme语言\n>\n> * 表达式\n> * 控制结构与列表\n> * 定义变量与函数\n> * 匿名过程\n>\n> Scheme语言特性\n>\n> * 宏\n> * 流\n>\n> 抽象语言的解释器\n>\n> * 解释器的实现\n> * 读取过程\n> * 评估过程\n> * 输出过程\n>\n\n在之前的章节中，我们都是基于一门语言去研究程序的抽象形式，而本 书的最后一个部分直接跳出了语言，讲解一门语言是怎么样抽象的，也就是说，这一章，是在教你如何实现一门语言，我们这里所说的语言是脚本语言，接下来，我们就要以Scheme语言为例，讲解Scheme语言是怎么样一步一步构造出来的。\n\n### Scheme语言\n\n首先我们从使用者的角度了解一下Scheme的语法。\n\n#### 表达式\n\n最基础的表达式可以是数字，布尔值或者符号，这里的符号是我们在Python语言中唯一没有遇到的类型，具体来说，Scheme中的符号也是一种值。\n\n##### 原子表达式\n\n```scheme\nscm> 1234    ; integer\n1234\nscm> 123.4   ; real number\n123.4\n```\n\n##### 布尔值\n\n```scheme\nscm> #t\n#t\nscm> #f\n#f\n```\n\n在 Scheme 中，除了特殊的布尔值#f之外的所有值都被解释为真值（与 Python 不同，Python 中有一些像0那样的假值）\n\n##### 符号\n\n其中，符号类型是我们在 Python 中唯一没有遇到的类型。一个 符号的作用很像一个Python的名字，但不完全是。具体来说，Scheme 中的符号也是一种值。在 Python 中，名称仅用作表达式；Python 表达式永远不能计算为名称。\n\n这个过程具体是怎么实现的，我们后面再讲。\n\n```scheme\nscm> quotient      ; A name bound to a built-in procedure\n#[quotient]\nscm> 'quotient     ; An expression that evaluates to a symbol\nquotient\nscm> 'hello-world!\nhello-world!\n```\n\n#### 调用表达式\n\n与 Python 一样，Scheme 调用表达式中的运算符位于所有操作数之前。与 Python 不同的是，运算符包含在括号内，并且操作数由空格而不是逗号分隔。然而，Scheme 调用表达式的计算遵循与 Python 完全相同的规则：\n\n1.评估操作符，应该评估为一个过程\n\n2.从左到右评估操作数\n\n3.操作数应用于过程\n\n以下是一些使用内置过程的示例：\n\n```scheme\nscm> (+ 1 2)\n3\nscm> (- 10 (/ 6 2))\n7\nscm> (modulo 35 4)\n3\nscm> (even? (quotient 45 2))\n#t\n```\n\n#### 控制结构与列表\n\n##### if表达式\n\n该if特殊形式使我们能够评估基于谓词两个表达式之一。它接受两个必需的参数和一个可选的第三个参数：\n\n> (if <predicate> <if-true> [if-false])\n\n第一个操作数是Scheme 中所谓的谓词表达式，该表达式的值被解释为#tor 或#f。\n\n计算if特殊形式表达式的规则如下：\n\n1.评估<predicate>。\n2.如果<predicate>评估为真值，则评估并返回该值，如果表达式<if-true>. 否则，[if-false]如果提供，则评估并返回值 。\n\n```scheme\nscm> (if (> x 3)\n         1\n         2)\n```\n\n在 Scheme 中，您不能编写elif案例。如果要使用if表达式有多个案例，则需要多个分支if表达式：\n\n```scheme\nscm> (if (< x 0)\n         'negative\n         (if (= x 0)\n             'zero\n             'positive\n         )\n )\n```\n\n##### cond表达式\n\n使用嵌套if表达式似乎不是处理多种情况的非常实用的方法。相反，我们可以使用cond特殊形式，一种类似于 Python 中的多子句 if/elif/else 条件表达式的通用条件表达式。\n\n```scheme\n(cond\n    (<p1> <e1>)\n    (<p2> <e2>)\n    ...\n    (<pn> <en>)\n    [(else <else-expression>)])\n```\n\n评价规则如下：\n\n1.对谓词<p1>, <p2>, ...,<pn>进行求值，直到达到求值为真 y 值的谓词为止。\n2.如果您到达一个计算结果为真值的谓词，请计算并返回子句中的相应表达式。\n3.如果没有一个谓词是真y并且有一个else子句，则评估并返回<else-expression>。\n\n```scheme\nscm> (cond\n        ((> x 0) 'positive)\n        ((< x 0) 'negative)\n        (else 'zero))\n```\n\n##### 列表\n\n###### cons\n\nScheme 列表与我们在 Python 中使用的链表非常相似。就像链表是由一系列Link 对象构建的一样，Scheme 列表是由一系列对构建的，这些对是由构造函数创建的cons，是一种可递归对象。\n\nScheme列表要cdr是另一个列表或nil空列表。列表在解释器中显示为值序列（类似于对象的 __str__表示Link）。\n\n```scheme\nscm> (cons 1 (cons 2 (cons 3 nil)))\n(1 2 3)\n```\n\n具体的实现方式用图像来表示就是\n\n![image-20210810094539083](https://i.loli.net/2021/08/10/Le2kpYIwaAgWN8E.png)\n\n我们可以使用car和cdr从我们的列表中检索值，现在它的工作方式类似于 PythonLink的first和rest属性。\n\n````scheme\nscm> (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a\nscm> a\n(1 2 3)\nscm> (car a)\n1\nscm> (cdr a)\n(2 3)\nscm> (car (cdr (cdr a)))\n3\n````\n\n如果您没有将 pair 或 nil 作为第二个参数传递给cons，则会出错：\n\n```scheme\nscm> (cons 1 2)\nError\n```\n\n###### List\n\n另一种创建列表的方式是利用list，该list过程接受任意数量的参数并使用这些参数的值构造一个列表\n\n```scheme\nscm> (list 1 2 3)\n(1 2 3)\nscm> (list 1 (list 2 3) 4)\n(1 (2 3) 4)\nscm> (list (cons 1 (cons 2 nil)) 3 4)\n((1 2) 3 4)\n```\n\n请注意，此表达式中的所有操作数在放入结果列表之前都会进行评估。\n\n###### Quote\n\n我们还可以使用引用形式来创建一个列表，通过引用形式创建的列表不进评估\n\n```scheme\nscm> '(1 2 3)\n(1 2 3)\nscm> '(cons 1 2)           ; Argument to quote is not evaluated\n(cons 1 2)\nscm> '(1 (2 3 4))\n(1 (2 3 4))\n```\n\n#### 定义变量与函数\n\n在Python中定义变量使用=号进行，而定义变量使用def进行，而在Scheme中定义变量和过程都使用define语法，这个在后期解释器的构造中我也会着重细讲。\n\n定义变量，我们使用语法\n\n```scheme\n(define <name> <expression>)\n```\n\n评估这个表达式的规则是\n\n1.评估<expression>.\n2.将其值绑定到<name>当前Frame中。\n3.返回<name>。\n\n定义过程，我们使用语法\n\n```scheme\n(define (<name> <param1> <param2> ...) <body> )\n```\n\n要评估此表达式：\n\n1.使用给定的参数和 来创建一个 lambda 过程<body>。\n2.将过程绑定到<name>当前帧中的 。\n3.返回<name>。\n\n以下两个表达式是等价的：\n\n```scheme\nscm> (define foo (lambda (x y) (+ x y)))\nfoo\nscm> (define (foo x y) (+ x y))\nfoo\n```\n\n#### 匿名过程\n\n所有 Scheme 过程都是 lambda 过程。要创建 lambda 过程，我们可以使用lambda特殊形式\n\n```scheme\n(lambda (<param1> <param2> ...) <body>)\n```\n\n```scheme\nscm> (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn't assign it to a name\n(lambda (x y) (+ x y))\nscm> ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line\n7\n```\n\n一个过程可以接受任意数量的参数。该<body>可以包含多个表达式。return Scheme 中没有 Python语句的等效版本。该函数将简单地返回正文中最后一个表达式的值。\n\n### Scheme语言特性\n\n#### 宏\n\n##### Define-macro\n\n宏是一个不好理解的概念，但是却是一个非常重要的概念，我们刚才已经介绍了define的用法，下面我们使用define来定义一个过程\n\n```scheme\n(define twice(f)\n  (begin f f))\n```\n\n当我们输入`（twice （print 'woof））`我们希望能输出两次woof，然而\n\n```scheme\nscm> (twice (print 'woof))\nwoof\n```\n\n这是怎么回事呢？\n\n我们一步一步来，首先我们对操作符twice进行评估，返回我们定义的twice过程，而后我们对`(print 'woof)`进行评估，打印woof，而后将返回的undefined值绑定到f，而后将操作数字应用于操作符，得到表达式`（begin undefined undefined）`对该表达式进行评估，无返回值\n\n那么我们该怎么样修改才能得到正确输出呢？\n\n我们想要最终评估的表达式是这样的，`begin （print 'woof）(print 'woof)` ，因此，我们想到一种办法\n\n```scheme\n(define (twice f)\n  (eval (list 'begin f f))\n```\n\n为了保证最终评估的表达式是`begin （print 'woof）(print 'woof)` ，我们稍微改变了一下输入的值\n\n```scheme\nscm> (twice '(print 'woof))\nwoof\nwoof\n```\n\n这样我们就通过eval list返回的列表，完成了正确输出。\n\n但是肯定有人会想，为什么要这么麻烦，在进入函数的时候用‘防止被eval，结果在出来的时候又得加个eval，那索性就直接让操作数不评估不就行了。\n\n诶，没错，这个问题，前人已经考虑到了，而且他们还设计了一种语法来解决这个问题，这种语法被叫做macro，宏。\n\n```scheme\nscm> (define-macro (twice f) (list 'begin f f))\ntwice\nscm> (twice (print 'woof))\nwoof\nwoof\n```\n\ndefine-macro允许我们定义macro，这是我们将未计算的输入表达式组合到另一个表达式中的一种方式。当我们调用宏时，操作数不会被评估，而是被视为 Scheme 数据。这意味着任何作为调用表达式或特殊形式表达式的操作数都被视为列表。\n\n在我们的例子中，我们需要一个如下所示的begin 表达式\n\n```scheme\n(begin (print 'woof) (print 'woof))\n```\n\n作为 Scheme 数据，这个表达式实际上只是一个包含三个元素的列表：begin和(print 'woof)两次，这正是(list 'begin f f)返回的内容。现在，当我们调用 时twice，这个列表被评估为一个表达式并被(print 'woof)评估两次。\n\n回顾一下，宏的调用方式与常规过程类似，但评估它们的规则不同。我们通过以下方式评估了 lambda 过程：\n\n>1.评估运算符\n>2.评估操作数\n>3.将运算符应用于操作数，评估过程的主体\n\n但是，评估对宏过程调用的规则是：\n\n>1.评估运算符\n>2.将运算符应用于未计算的操作数\n>3.评估宏在调用它的框架中返回的表达式。\n\n这种特性使得scheme语言具有很强的扩展性，可以随意设计各种不同的语法来进行运算，举个例子，如果我们想把Scheme的定义语法用Python的风格写出来，该怎么做呢？\n\n这时候我们就可以利用宏来实现。\n\n```scheme\n(define-macro (def func bindings body)\n    (list 'define (cons func bindings) body))\n```\n\n```scheme\nscm< (def f(x y) (+ x y))\nf\n```\n\n这样我们就可以使用具有Python风格的语法来定义scheme函数了。\n\n##### Quasiquote\n\n回想一下，quote特殊形式会阻止 Scheme 解释器执行表达式,如果我们试图构建具有许多嵌套列表的复杂 Scheme 表达式，这种形式似乎会派上用场。\n\n考虑我们将twice宏重写如下\n\n```scheme\n(define-macro (twice f)\n  '(begin f f))\n```\n\n这似乎会产生相同的效果，但由于quote 表单阻止了任何评估，我们创建的结果表达式实际上是`(begin f f)`，这不是我们想要的。\n\n乍一看，quasiquote（可以用反引号`或quasiquote特殊形式调用）与quote的行为完全相同。但是，使用quasiquote可以使用逗号，从引用的上下文中删除一个表达式，对其进行评估，然后将其放回原处。\n\n下面是我们如何使用 quasiquote 来重写我们之前的示例：\n\n```scheme\n(define-macro (twice f)\n  `(begin ,f ,f))\n```\n\n同样我们重写def实例：\n\n```scheme\n(define-macro (def func bindings body)\n    `(define ,(cons func bindings) ,body))\n```\n\n其执行结果不变。\n\n#### 流\n\n在Python当中，我们使用迭代器和生成器来实现惰性求值\n\n```python\ndef ints(first):\n    while True:\n        yield first\n        first += 1\n```\n\n```python\n>>> s = ints(1)\n>>> next(s)\n1\n>>> next(s)\n2\n```\n\n然而，在Scheme语言中，没有迭代器和生成器，让我们看看如果我们使用scheme列表来进行循环迭代求值会产生什么情况。\n\n```scheme\n(define (ints first)\n    (cons first (ints (+ first 1)))\n```\n\n```scheme\nscm> (ints 1)\nmaximum recursion depth exceeded\n```\n\n由于cons是一个连续求值的过程，在cons结构建立之前，需要对所有值进行逐个评估，因此我们不能用cons创建一个无限循环的列表，然而，scheme解释器引入了流，流是一个特殊的scheme列表，在进行评估时，第一个值会进行评估，而第二个值会被保留，直到我们需要进行评估时才执行，在程序编写范式中，这种模式被称作惰性求值。\n\n我们使用以下语法结构创建一个流\n\n```scheme\n(cons-stream <operand1> <operand2>)\n```\n\n我们以自然数无限循环列表为例讲解流的操作\n\n```scheme\n(define (ints first)\n    (cons-stream first\n                 (ints (+ first 1)))\n```\n\n```scheme\nscm> (ints 1)\n(1 . #[promise (not forced)])\n```\n\n可以看出，流在进行评估的时候，只会评估第一个值，而保留第二个值，而后返回一个列表。\n\n我们首先将循环列表返回的值赋给一个变量a\n\n```scheme\nscm>(define a (int 1))\n```\n\n而后我们对列表进行操作，如果我们仅使用cdr\n\n```scheme\nscm> (cdr (int 1))\n#[promise (not forced)]\n```\n\n我们发现依然没有评估，因为我们需要使用cdr-stream，才能让列表第二个值评估后返回。\n\n```scheme\nscm> (cdr-stream a)\n(2 . #[promise (not forced)])\n```\n\n这样我们就能得到第二个值评估后的结果。\n\n利用流能做些什么呢？我们举一个例子\n\n假设我们有一个自然数循环列表，我们需要得到一个对每个值都运用函数后返回值构成的循环列表，那么我们该怎么做呢？\n\n```scheme\n(define (naturals n)\n  (cons-stream n (naturals (+ n 1))))\n\n(define nat (naturals 0))\n\n(define (map-stream f s)\n  (cons-stream (f (car s)) (map-stream f (cdr-stream s))))\n\n(define evens (map-stream (lambda (x) (* x 2)) nat))\n\n```\n\n首先，我们创建一个循环列表，并将其赋给变量`nat`，而后我们创建一个`map-stream`函数，引入循环列表和一个匿名函数作为参数，再将返回的列表赋给变量`even`由于cons-stream惰性求值的性质，我们在得到第一个值后并不会继续评估，因此`even`就变成了返回两倍自然数的循环列表，是不是很有趣呢？\n\n以上统统扯淡，看文档都能会，接下来进入正题。\n\n### 抽象语言的解释器\n\n#### 解释器的实现\n\n这是一个非常庞大的项目，CS61A利用Python构建了一个Scheme的解释器，也就是说，当完成这个解释器之后，我们就可以利用自己写的解释器进行scheme文档的解释与输出了，其实所有的编程语言本质都是解释器，你必须要采用合理的解释器将计算机无法理解的语言转换成计算机可以理解的语言，这样才能实现各种功能。\n\n整个解释器分为三个步骤，Read，Eval，Print，我们着重讲解前两个步骤。\n\n单个Read部分，这一步将用户的输入解析为解释器内部的一种抽象数据类型，我们在Python中构建了Pair这个类来将用户的输入从字符串转换成类的实例对象，以便于下一步对输入的整个表达式进行操作，主要有词法分析和句法分析两个步骤。\n\nEval部分，这一步评估Scheme表达式以获得相应的值，我们知道，对于基础表达式例如 数字，布尔值，符号等来说，只需要对其进行评估后返回即可，而对于有操作符和操作数的调用表达式来说，我们要遵循调用表达式评估的顺序，忘记了？我们再来回顾一遍。\n\n>1.评估操作符，应该评估为一个过程\n>\n>2.从左到右评估操作数\n>\n>3.操作数应用于过程\n\n操作符评估后，将会返回相应的过程，如果被求值的表达式是特殊形式，比如if,cond等等，将调用相应的函数进行操作，而后对操作数进行评估，注意，如果操作数也是调用表达式，那么依然要按顺序进行评估后返回。接下来就是将评估后的操作数应用于过程了，这里的过程有两种，一是内置过程，二是我们自己创建的Lambda过程，在后面我们会详细介绍如何分别实现这两种过程的应用。\n\nPrint部分，这部分就不细讲了，就是使用str打印获得值即可。\n\n还有一个问题就是，我们需要让整个解释器循环起来，总不能每次输入一次表达式得出结果就终止了程序吧，所以我们需要一个逻辑循环函数。\n\nOK，从Read开始讲起。\n\n#### Read部分\n\n##### Pair类\n\n前面我们讲到，Read部分是将用户输入的字符串，通过词法分析和句法分析转换成某种抽象数据类型，以供后续的分析\n\n首先我们来定义一种能够接收并存储用户输入字符串的数据类型Pair\n\n```python\nclass Pair(object):\n    \"\"\"A pair has two instance attributes: first and second. Second must be a Pair or nil\n\n    >>> s = Pair(1, Pair(2, nil))\n    >>> s\n    Pair(1, Pair(2, nil))\n    >>> print(s)\n    (1 2)\n    >>> print(s.map(lambda x: x+4))\n    (5 6)\n    \"\"\"\n    def __init__(self, first, second):\n        from scheme_builtins import scheme_valid_cdrp, SchemeError\n        if not (second is nil or isinstance(second, Pair) or type(second).__name__ == 'Promise'):\n            raise SchemeError(\"cdr can only be a pair, nil, or a promise but was {}\".format(second))\n        self.first = first\n        self.second = second\n\n    def __repr__(self):\n        return 'Pair({0}, {1})'.format(repr(self.first), repr(self.second))\n\n    def __str__(self):\n        s = '(' + repl_str(self.first)\n        second = self.second\n        while isinstance(second, Pair):\n            s += ' ' + repl_str(second.first)\n            second = second.second\n        if second is not nil:\n            s += ' . ' + repl_str(second)\n        return s + ')'\n\n    def __len__(self):\n        n, second = 1, self.second\n        while isinstance(second, Pair):\n            n += 1\n            second = second.second\n        if second is not nil:\n            raise TypeError('length attempted on improper list')\n        return n\n\n    def __eq__(self, p):\n        if not isinstance(p, Pair):\n            return False\n        return self.first == p.first and self.second == p.second\n\n    def map(self, fn):\n        \"\"\"Return a Scheme list after mapping Python function FN to SELF.\"\"\"\n        mapped = fn(self.first)\n        if self.second is nil or isinstance(self.second, Pair):\n            return Pair(mapped, self.second.map(fn))\n        else:\n            raise TypeError('ill-formed list (cdr is a promise)')\n```\n\n我们可以看出，Pair的结构非常像Link，其实本质也是一种迭代对象，只不过在link的基础上增加了一些内置方法，用于对Pair对象进行各种操作。\n\n##### 词法分析\n\n当用户输入一个字符串 \n\n```scheme\nscm> (+ 1 2)\n```\n\n解释器首先要对其进行词法分析，在该项目中，我们使用tokenize_lines函数和Buffer类进行词法分析，最终返回一个Buffer对象src\n\n```scheme\nnext_line = buffer_input\n\nsrc = next_line()\n```\n\n根据函数调用的顺序，涉及的函数调用如下：\n\n```python\n\n获取字符串\ndef buffer_input(prompt='scm> '):\n    \"\"\"Return a Buffer instance containing interactive input.\"\"\"\n    return Buffer(tokenize_lines(InputReader(prompt)))\n    \n#获取输入字符串，逐个字符传入tokenize_line函数执行    \ndef tokenize_lines(input):\n    \"\"\"An iterator over lists of tokens, one for each line of the iterable\n    input sequence.\"\"\"\n    return (tokenize_line(line) for line in input)\n\n#获取tokenize_line函数执行返回结果构成的列表，并将其转为Buffer类的实例对象\nclass Buffer(object):\n    def __init__(self, source):\n        self.index = 0\n        self.lines = []\n        self.source = source\n        self.current_line = ()\n        self.current()\n\n    def remove_front(self):\n        \"\"\"Remove the next item from self and return it. If self has\n        exhausted its source, returns None.\"\"\"\n        current = self.current()\n        self.index += 1\n        return current\n\n    def current(self):\n        \"\"\"Return the current element, or None if none exists.\"\"\"\n        while not self.more_on_line:\n            self.index = 0\n            try:\n                self.current_line = next(self.source)\n                self.lines.append(self.current_line)\n            except StopIteration:\n                self.current_line = ()\n                return None\n        return self.current_line[self.index]\n\n    @property\n    def more_on_line(self):\n        return self.index < len(self.current_line)\n\n    def __str__(self):\n        \"\"\"Return recently read contents; current element marked with >>.\"\"\"\n        # Format string for right-justified line numbers\n        n = len(self.lines)\n        msg = '{0:>' + str(math.floor(math.log10(n))+1) + \"}: \"\n\n        # Up to three previous lines and current line are included in output\n        s = ''\n        for i in range(max(0, n-4), n-1):\n            s += msg.format(i+1) + ' '.join(map(str, self.lines[i])) + '\\n'\n        s += msg.format(n)\n        s += ' '.join(map(str, self.current_line[:self.index]))\n        s += ' >> '\n        s += ' '.join(map(str, self.current_line[self.index:]))\n        return s.strip()\n```\n\nBuffer实例有两个核心方法remove_front和current，这两个方法可以对Buffer对象里的值进行有序输出。\n\n```scheme\n>>> buf = Buffer(iter([['(', '+'], [15], [12, ')']]))\n>>> buf.remove_front()\n'('\n>>> buf.remove_front()\n'+'\n>>> buf.current()\n15\n>>> print(buf)\n1: ( +\n2:  >> 15\n>>> buf.remove_front()\n15\n```\n\n经过词法分析，用户输入的字符串被转换成了可有序输出的Buffer实例对象，就好像排列在内存中的数据一样，但是有一个问题就在于，对于这些存在实例对象中的数据，数据之间的相互关联并没有建立，就好像在游乐园等待入场的队列，虽然有序，但是相互之间毫无关联。\n\n因此我们要进行句法分析。\n\n##### 句法分析\n\n在该项目中，我们使用scheme_read进行句法分析，最终返回一个Pair对象expression\n\n```scheme\nexpression = scheme_read(src)\n```\n\n我们来看一下scheme_read的逻辑流程\n\n```python\ndef scheme_read(src):\n    \"\"\"Read the next expression from SRC, a Buffer of tokens.\n\n    >>> scheme_read(Buffer(tokenize_lines(['nil'])))\n    nil\n    >>> scheme_read(Buffer(tokenize_lines(['1'])))\n    1\n    >>> scheme_read(Buffer(tokenize_lines(['true'])))\n    True\n    >>> scheme_read(Buffer(tokenize_lines(['(+ 1 2)'])))\n    Pair('+', Pair(1, Pair(2, nil)))\n    \"\"\"\n    if src.current() is None:\n        raise EOFError\n    val = src.remove_front() # Get the first token\n    if val == 'nil':\n        # BEGIN PROBLEM 2\n        return nil\n        # END PROBLEM 2\n    elif val == '(':\n        # BEGIN PROBLEM 2\n        return read_tail(src)\n        # END PROBLEM 2\n    elif val in quotes:\n        # BEGIN PROBLEM 7\n        return Pair(quotes[val],Pair(scheme_read(src),nil))\n        # END PROBLEM 7\n    elif val not in DELIMITERS:\n        return val\n    else:\n        raise SyntaxError('unexpected token: {0}'.format(val))\n\ndef read_tail(src):\n    \"\"\"Return the remainder of a list in SRC, starting before an element or ).\n\n    >>> read_tail(Buffer(tokenize_lines([')'])))\n    nil\n    >>> read_tail(Buffer(tokenize_lines(['2 3)'])))\n    Pair(2, Pair(3, nil))\n    \"\"\"\n    try:\n        if src.current() is None:\n            raise SyntaxError('unexpected end of file')\n        elif src.current() == ')':\n            # BEGIN PROBLEM 2\n            src.remove_front()\n            return nil\n            # END PROBLEM 2\n        else:\n            # BEGIN PROBLEM 2\n            return Pair(scheme_read(src),read_tail(src))\n            # END PROBLEM 2\n    except EOFError:\n        raise SyntaxError('unexpected end of file')\n\nquotes = {\"'\":  'quote',\n          '`':  'quasiquote',\n          ',':  'unquote'}\n        \n```\n\n我们可以看出，对于不同的结构，scheme_read有不同的方案去构造，主要可以分为三种，一种是普通的基础表达式，比如123，nil和布尔值，一种是调用表达式，scheme_read函数规定当遇到‘（’时会自动进入read_tail函数，最终返回一个完整的Pair结构，第三种就是符号，函数会判断这个符号是Quote，Quasiquote还是unquote，并将这三个模式传入以供后期评估使用。\n\n最终输入如下\n\n```python\n>>> scheme_read(Buffer(tokenize_lines(['(+ 1 2)'])))\nPair('+', Pair(1, Pair(2, nil)))\n```\n\n可以看出，经过句法分析，我们建立了字符之间的关联性，同属于一个调用表达式的字符被整合进 了独立的一个Pair实例，就好比，让在排队的人，夫妻合并成一组，家庭或朋友合并成一组，再进行排队。\n\n经过第一部分Read，我们拥有了具有关联性的Pair对象，在接下来的Eval部分中，我们将要对这个对象进行评估。\n\n#### Eval 部分\n\n在整个评估过程中，有两个类发挥着重要作用，一个类是Frame，Frame类是一个环境框架，我们学习Python作用域的时候学习过，程序开始时候是在Global Frame下，当调用函数时候，会创建一个Frame，并且在该Frame下创建的变量和传入的参数是不能在Global Frame下被使用的，Scheme同样如此，所以我们创建了一个Frame类用于分离不同作用域。一个类是Procedure，Procedure类是过程类，他有两个子类，一个是BuiltinProcedure，即内置过程，比如我们使用的if，cons，cond都是内置过程，另一个是LambdaProcedure，即匿名过程，这是用来创建并绑定用户定义过程的。\n\n##### Frame类\n\nEFrame类实现了环境框架，在对解释器进行初始化的时候，会调用create_global_frame创建一个Frame环境框架。\n\n```python\nclass Frame(object):\n    \"\"\"An environment frame binds Scheme symbols to Scheme values.\"\"\"\n\n    def __init__(self, parent):\n        \"\"\"An empty frame with parent frame PARENT (which may be None).\"\"\"\n        self.bindings = {}\n        self.parent = parent\n\n    def __repr__(self):\n        if self.parent is None:\n            return '<Global Frame>'\n        s = sorted(['{0}: {1}'.format(k, v) for k, v in self.bindings.items()])\n        return '<{{{0}}} -> {1}>'.format(', '.join(s), repr(self.parent))\n\n    def define(self, symbol, value):\n        \"\"\"Define Scheme SYMBOL to have VALUE.\"\"\"\n        # BEGIN PROBLEM 3\n        self.bindings[symbol]=value\n        # END PROBLEM 3\n\n    def lookup(self, symbol):\n        \"\"\"Return the value bound to SYMBOL. Errors if SYMBOL is not found.\"\"\"\n        # BEGIN PROBLEM 3\n        try:\n            return self.bindings[symbol]\n        except KeyError:\n            if self.parent is not None:\n                return self.parent.lookup(symbol)\n        # END PROBLEM 3\n        raise SchemeError('unknown identifier: {0}'.format(symbol))\n\n    def make_child_frame(self, formals, vals):\n        \"\"\"Return a new local frame whose parent is SELF, in which the symbols\n        in a Scheme list of formal parameters FORMALS are bound to the Scheme\n        values in the Scheme list VALS. Raise an error if too many or too few\n        vals are given.\n\n        >>> env = create_global_frame()\n        >>> formals, expressions = read_line('(a b c)'), read_line('(1 2 3)')\n        >>> env.make_child_frame(formals, expressions)\n        <{a: 1, b: 2, c: 3} -> <Global Frame>>\n        \"\"\"\n        # BEGIN PROBLEM 11\n        match_dict = {}\n        if len(formals)!=len(vals):\n            raise SchemeError('The number of argument values does not match')\n        else:\n            for _ in range(len(formals)):\n                match_dict[formals.first] = vals.first\n                formals = formals.second\n                vals = vals.second\n        new_frame = Frame(self)\n        for key,value in match_dict.items():\n            new_frame.define(key,value)\n        return new_frame\n        # END PROBLEM 11\n\n```\n\nFrame框架类从外界引入一个父环境Frame实例，并维护一个binding列表，在初始化时候，会在初始Frame环境中调用define方法引入内置过程，在后面的过程中，如果需要引入用户过程，可以通过define引入，查找内置过程，可以通过lookup方法实现。\n\n```python\ndef create_global_frame():\n    \"\"\"Initialize and return a single-frame environment with built-in names.\"\"\"\n    env = Frame(None)\n    env.define('eval',\n               BuiltinProcedure(scheme_eval, True, 'eval'))\n    env.define('apply',\n               BuiltinProcedure(complete_apply, True, 'apply'))\n    env.define('load',\n               BuiltinProcedure(scheme_load, True, 'load'))\n    env.define('procedure?',\n               BuiltinProcedure(scheme_procedurep, False, 'procedure?'))\n    env.define('map',\n               BuiltinProcedure(scheme_map, True, 'map'))\n    env.define('filter',\n               BuiltinProcedure(scheme_filter, True, 'filter'))\n    env.define('reduce',\n               BuiltinProcedure(scheme_reduce, True, 'reduce'))\n    env.define('undefined', None)\n    add_builtins(env, BUILTINS)\n    return env\n```\n\n当子环境创建需要引入一个Frame实例时，Frame可以调用make_child_frame创建一个子Frame并返回。\n\n```python\ndef make_call_frame(self,args,env):\n        return env.make_child_frame(self.formals, args)\n```\n\n##### Procedure类\n\n```python\nclass BuiltinProcedure(Procedure):\n    \"\"\"A Scheme procedure defined as a Python function.\"\"\"\n\n    def __init__(self, fn, use_env=False, name='builtin'):\n        self.name = name\n        self.fn = fn\n        self.use_env = use_env\n\n    def __str__(self):\n        return '#[{0}]'.format(self.name)\n\n    def apply(self, args, env):\n        \"\"\"Apply SELF to ARGS in ENV, where ARGS is a Scheme list.\n\n        >>> env = create_global_frame()\n        >>> plus = env.bindings['+']\n        >>> twos = Pair(2, Pair(2, nil))\n        >>> plus.apply(twos, env)\n        4\n        \"\"\"\n        if not scheme_listp(args):\n            raise SchemeError('arguments are not in a list: {0}'.format(args))\n        # Convert a Scheme list to a Python list\n        python_args = []\n        while args is not nil:\n            python_args.append(args.first)\n            args = args.second\n        # BEGIN PROBLEM 4\n        if self.use_env:\n            python_args.append(env)\n        try:\n            return self.fn(*python_args)\n        except TypeError:\n            raise SchemeError(\"Invalid number of arguments to {0}\".format(self.name))\n        # END PROBLEM 4\n\nclass LambdaProcedure(Procedure):\n    \"\"\"A procedure defined by a lambda expression or a define form.\"\"\"\n\n    def __init__(self, formals, body, env):\n        \"\"\"A procedure with formal parameter list FORMALS (a Scheme list),\n        whose body is the Scheme list BODY, and whose parent environment\n        starts with Frame ENV.\"\"\"\n        self.formals = formals\n        self.body = body\n        self.env = env\n\n    def make_call_frame(self, args, env):\n        \"\"\"Make a frame that binds my formal parameters to ARGS, a Scheme list\n        of values, for a lexically-scoped call evaluated in environment ENV.\"\"\"\n        # BEGIN PROBLEM 12\n        new_frame = self.env.make_child_frame(self.formals,args)\n        return new_frame\n        # END PROBLEM 12\n\n    def __str__(self):\n        return str(Pair('lambda', Pair(self.formals, self.body)))\n\n    def __repr__(self):\n        return 'LambdaProcedure({0}, {1}, {2})'.format(\n            repr(self.formals), repr(self.body), repr(self.env))\n```\n\n内置过程表示为BuiltinProcedure实例，BuiltinProcedure具有两个实例属性，fn是实施内置方案程序的Python功能，use_env是一个布尔标志，指示这个内置程序是否会期望当前环境作为最后一个参数传递。例如，需要环境来实施内置eval程序。\n\n用户定义的程序表示为LambdaProcedure实例。LambdaProcedure具有三个实例属性，formals是命名程序参数的正式参数（符号）的方案列表。body是一个方案列表的表达式，程序的主体。\nenv是定义程序的Frame环境。\n\n##### 评估仅内置过程的表达式\n\n当我们评估只有内置过程的表达式的时候，我们会进行这个过程\n\n```python\nif scheme_symbolp(first) and first in SPECIAL_FORMS:\n        return SPECIAL_FORMS[first](rest, env)\n```\n\n这里的SPECIAL_FORMS就是内置过程的列表，我们通过first变量传入操作符名称，当我们发现评估的操作符是个内置过程的时候，我们就会调用这段代码找到对应调用内置过程的函数。\n\n```python\nSPECIAL_FORMS = {\n    'and': do_and_form,\n    'begin': do_begin_form,\n    'cond': do_cond_form,\n    'define': do_define_form,\n    'if': do_if_form,\n    'lambda': do_lambda_form,\n    'let': do_let_form,\n    'or': do_or_form,\n    'quote': do_quote_form,\n    'define-macro': do_define_macro,\n    'quasiquote': do_quasiquote_form,\n    'unquote': do_unquote,\n}\n```\n\n我们以评估define内置过程为例来讲解。\n\n```python\ndef do_define_form(expressions, env):\n    \"\"\"Evaluate a define form.\"\"\"\n    check_form(expressions, 2)\n    target = expressions.first\n    if scheme_symbolp(target):\n        check_form(expressions, 2, 2)\n        # BEGIN PROBLEM 6\n        value = scheme_eval(expressions.second.first,env)\n        env.define(target,value)\n        return target\n        # END PROBLEM 6\n    ...\n    else:\n        bad_target = target.first if isinstance(target, Pair) else target\n        raise SchemeError('non-symbol: {0}'.format(bad_target))\n```\n\ndo_define_form函数引入了两个参数，根据调用函数可知，传入的expression参数是调用表达式的操作数部分，因此就把操作数评估后的结果在全局环境下与设定的变量绑定了，其关键代码为\n\n```python\n env.define(target,value)\n```\n\n这就是实现一个内置过程的办法，接下来我们来看看该如何实现用户定义函数。\n\n##### 评估带有用户定义的表达式\n\n我们先来看看如何使用内置过程`define`定义一个用户过程。\n\n```python\ndef do_define_form(expressions, env):\n    \"\"\"Evaluate a define form.\"\"\"\n    check_form(expressions, 2)\n    target = expressions.first\n    if scheme_symbolp(target):\n        check_form(expressions, 2, 2)\n        # BEGIN PROBLEM 6\n        value = scheme_eval(expressions.second.first,env)\n        env.define(target,value)\n        return target\n        # END PROBLEM 6\n    elif isinstance(target, Pair) and scheme_symbolp(target.first):\n        # BEGIN PROBLEM 10\n        name = target.first\n        formal = target.second\n        body = expressions.second\n        process = LambdaProcedure(formal,body,env)\n        env.define(name,process)\n        return name\n        # END PROBLEM 10\n    else:\n        bad_target = target.first if isinstance(target, Pair) else target\n        raise SchemeError('non-symbol: {0}'.format(bad_target))\n```\n\n我们看到，这个define函数比之前仅能定义变量的函数多了elif的部分，在这个过程中，函数首先将整个定义代码段分成name函数名称，formal函数参数，和body函数主体三个部分，而后将这三个部分放入LambdaProcedure类创建一个实例，最后调用Frame的define过程将新定义的过程实例与过程名绑定，以便后期lookup函数的查找。\n\n我们来看看创建新过程的实例时候，发生了什么。\n\n```python\nclass LambdaProcedure(Procedure):\n    \"\"\"A procedure defined by a lambda expression or a define form.\"\"\"\n\n    def __init__(self, formals, body, env):\n        \"\"\"A procedure with formal parameter list FORMALS (a Scheme list),\n        whose body is the Scheme list BODY, and whose parent environment\n        starts with Frame ENV.\"\"\"\n        self.formals = formals\n        self.body = body\n        self.env = env\n\n    def make_call_frame(self, args, env):\n        \"\"\"Make a frame that binds my formal parameters to ARGS, a Scheme list\n        of values, for a lexically-scoped call evaluated in environment ENV.\"\"\"\n        # BEGIN PROBLEM 12\n        new_frame = self.env.make_child_frame(self.formals,args)\n        return new_frame\n        # END PROBLEM 12\n\n    def __str__(self):\n        return str(Pair('lambda', Pair(self.formals, self.body)))\n\n    def __repr__(self):\n        return 'LambdaProcedure({0}, {1}, {2})'.format(\n            repr(self.formals), repr(self.body), repr(self.env))\n```\n\n可以看到，lambda维护着一个方法，当调用到用户实例的时候，就会调用这个方法，打开一个新Frame进行运算。\n\n最后对调用表达式执行apply操作\n\n````python\ndef scheme_apply(procedure, args, env):\n    \"\"\"Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in\n    environment ENV.\"\"\"\n    check_procedure(procedure)\n    if isinstance(procedure, BuiltinProcedure):\n        return procedure.apply(args, env)\n    else:\n        new_env = procedure.make_call_frame(args, env)\n        return eval_all(procedure.body, new_env)\n\ndef eval_all(expressions, env):\n    \"\"\"Evaluate each expression in the Scheme list EXPRESSIONS in\n    environment ENV and return the value of the last.\"\"\"\n    # BEGIN PROBLEM 8\n    if expressions == nil:\n        return None\n    else:\n        value = expressions.map((lambda x:scheme_eval(x,env)))\n        while value is not nil:\n            now = value.first\n            value = value.second\n        return now\n````\n\n至此，整个解释器就写完了，再加上内置的自循环函数，一个可以运行Scheme程序的python解释器就大功告成了。在61A 的Scheme项目中，还有如宏和流这种复杂的过程，大家可以自行学习，不过本质还是和内置过程的评估相差不大。学习这个项目的目的不是真的要完成一个解释器，而是要让你学会和理解解释器是如何”翻译“一种语言的，这样你才能更好的去理解各种编程范式，例如函数式编程，面向对象编程.\n\n\n\n","source":"_posts/CS61A-元语言抽象.md","raw":"---\ntitle: CS61A-元语言抽象\ndate: 2021-08-08 15:56:30\ntags: \n- 程序结构\n- CS61\n- CS61A\ncategories:\n- Learning Record\ncover: /myimage/cs61/cs61a_language_cover.png\n---\n\n## CS61A 元语言抽象\n\n#### 目录\n\n> Scheme语言\n>\n> * 表达式\n> * 控制结构与列表\n> * 定义变量与函数\n> * 匿名过程\n>\n> Scheme语言特性\n>\n> * 宏\n> * 流\n>\n> 抽象语言的解释器\n>\n> * 解释器的实现\n> * 读取过程\n> * 评估过程\n> * 输出过程\n>\n\n在之前的章节中，我们都是基于一门语言去研究程序的抽象形式，而本 书的最后一个部分直接跳出了语言，讲解一门语言是怎么样抽象的，也就是说，这一章，是在教你如何实现一门语言，我们这里所说的语言是脚本语言，接下来，我们就要以Scheme语言为例，讲解Scheme语言是怎么样一步一步构造出来的。\n\n### Scheme语言\n\n首先我们从使用者的角度了解一下Scheme的语法。\n\n#### 表达式\n\n最基础的表达式可以是数字，布尔值或者符号，这里的符号是我们在Python语言中唯一没有遇到的类型，具体来说，Scheme中的符号也是一种值。\n\n##### 原子表达式\n\n```scheme\nscm> 1234    ; integer\n1234\nscm> 123.4   ; real number\n123.4\n```\n\n##### 布尔值\n\n```scheme\nscm> #t\n#t\nscm> #f\n#f\n```\n\n在 Scheme 中，除了特殊的布尔值#f之外的所有值都被解释为真值（与 Python 不同，Python 中有一些像0那样的假值）\n\n##### 符号\n\n其中，符号类型是我们在 Python 中唯一没有遇到的类型。一个 符号的作用很像一个Python的名字，但不完全是。具体来说，Scheme 中的符号也是一种值。在 Python 中，名称仅用作表达式；Python 表达式永远不能计算为名称。\n\n这个过程具体是怎么实现的，我们后面再讲。\n\n```scheme\nscm> quotient      ; A name bound to a built-in procedure\n#[quotient]\nscm> 'quotient     ; An expression that evaluates to a symbol\nquotient\nscm> 'hello-world!\nhello-world!\n```\n\n#### 调用表达式\n\n与 Python 一样，Scheme 调用表达式中的运算符位于所有操作数之前。与 Python 不同的是，运算符包含在括号内，并且操作数由空格而不是逗号分隔。然而，Scheme 调用表达式的计算遵循与 Python 完全相同的规则：\n\n1.评估操作符，应该评估为一个过程\n\n2.从左到右评估操作数\n\n3.操作数应用于过程\n\n以下是一些使用内置过程的示例：\n\n```scheme\nscm> (+ 1 2)\n3\nscm> (- 10 (/ 6 2))\n7\nscm> (modulo 35 4)\n3\nscm> (even? (quotient 45 2))\n#t\n```\n\n#### 控制结构与列表\n\n##### if表达式\n\n该if特殊形式使我们能够评估基于谓词两个表达式之一。它接受两个必需的参数和一个可选的第三个参数：\n\n> (if <predicate> <if-true> [if-false])\n\n第一个操作数是Scheme 中所谓的谓词表达式，该表达式的值被解释为#tor 或#f。\n\n计算if特殊形式表达式的规则如下：\n\n1.评估<predicate>。\n2.如果<predicate>评估为真值，则评估并返回该值，如果表达式<if-true>. 否则，[if-false]如果提供，则评估并返回值 。\n\n```scheme\nscm> (if (> x 3)\n         1\n         2)\n```\n\n在 Scheme 中，您不能编写elif案例。如果要使用if表达式有多个案例，则需要多个分支if表达式：\n\n```scheme\nscm> (if (< x 0)\n         'negative\n         (if (= x 0)\n             'zero\n             'positive\n         )\n )\n```\n\n##### cond表达式\n\n使用嵌套if表达式似乎不是处理多种情况的非常实用的方法。相反，我们可以使用cond特殊形式，一种类似于 Python 中的多子句 if/elif/else 条件表达式的通用条件表达式。\n\n```scheme\n(cond\n    (<p1> <e1>)\n    (<p2> <e2>)\n    ...\n    (<pn> <en>)\n    [(else <else-expression>)])\n```\n\n评价规则如下：\n\n1.对谓词<p1>, <p2>, ...,<pn>进行求值，直到达到求值为真 y 值的谓词为止。\n2.如果您到达一个计算结果为真值的谓词，请计算并返回子句中的相应表达式。\n3.如果没有一个谓词是真y并且有一个else子句，则评估并返回<else-expression>。\n\n```scheme\nscm> (cond\n        ((> x 0) 'positive)\n        ((< x 0) 'negative)\n        (else 'zero))\n```\n\n##### 列表\n\n###### cons\n\nScheme 列表与我们在 Python 中使用的链表非常相似。就像链表是由一系列Link 对象构建的一样，Scheme 列表是由一系列对构建的，这些对是由构造函数创建的cons，是一种可递归对象。\n\nScheme列表要cdr是另一个列表或nil空列表。列表在解释器中显示为值序列（类似于对象的 __str__表示Link）。\n\n```scheme\nscm> (cons 1 (cons 2 (cons 3 nil)))\n(1 2 3)\n```\n\n具体的实现方式用图像来表示就是\n\n![image-20210810094539083](https://i.loli.net/2021/08/10/Le2kpYIwaAgWN8E.png)\n\n我们可以使用car和cdr从我们的列表中检索值，现在它的工作方式类似于 PythonLink的first和rest属性。\n\n````scheme\nscm> (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a\nscm> a\n(1 2 3)\nscm> (car a)\n1\nscm> (cdr a)\n(2 3)\nscm> (car (cdr (cdr a)))\n3\n````\n\n如果您没有将 pair 或 nil 作为第二个参数传递给cons，则会出错：\n\n```scheme\nscm> (cons 1 2)\nError\n```\n\n###### List\n\n另一种创建列表的方式是利用list，该list过程接受任意数量的参数并使用这些参数的值构造一个列表\n\n```scheme\nscm> (list 1 2 3)\n(1 2 3)\nscm> (list 1 (list 2 3) 4)\n(1 (2 3) 4)\nscm> (list (cons 1 (cons 2 nil)) 3 4)\n((1 2) 3 4)\n```\n\n请注意，此表达式中的所有操作数在放入结果列表之前都会进行评估。\n\n###### Quote\n\n我们还可以使用引用形式来创建一个列表，通过引用形式创建的列表不进评估\n\n```scheme\nscm> '(1 2 3)\n(1 2 3)\nscm> '(cons 1 2)           ; Argument to quote is not evaluated\n(cons 1 2)\nscm> '(1 (2 3 4))\n(1 (2 3 4))\n```\n\n#### 定义变量与函数\n\n在Python中定义变量使用=号进行，而定义变量使用def进行，而在Scheme中定义变量和过程都使用define语法，这个在后期解释器的构造中我也会着重细讲。\n\n定义变量，我们使用语法\n\n```scheme\n(define <name> <expression>)\n```\n\n评估这个表达式的规则是\n\n1.评估<expression>.\n2.将其值绑定到<name>当前Frame中。\n3.返回<name>。\n\n定义过程，我们使用语法\n\n```scheme\n(define (<name> <param1> <param2> ...) <body> )\n```\n\n要评估此表达式：\n\n1.使用给定的参数和 来创建一个 lambda 过程<body>。\n2.将过程绑定到<name>当前帧中的 。\n3.返回<name>。\n\n以下两个表达式是等价的：\n\n```scheme\nscm> (define foo (lambda (x y) (+ x y)))\nfoo\nscm> (define (foo x y) (+ x y))\nfoo\n```\n\n#### 匿名过程\n\n所有 Scheme 过程都是 lambda 过程。要创建 lambda 过程，我们可以使用lambda特殊形式\n\n```scheme\n(lambda (<param1> <param2> ...) <body>)\n```\n\n```scheme\nscm> (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn't assign it to a name\n(lambda (x y) (+ x y))\nscm> ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line\n7\n```\n\n一个过程可以接受任意数量的参数。该<body>可以包含多个表达式。return Scheme 中没有 Python语句的等效版本。该函数将简单地返回正文中最后一个表达式的值。\n\n### Scheme语言特性\n\n#### 宏\n\n##### Define-macro\n\n宏是一个不好理解的概念，但是却是一个非常重要的概念，我们刚才已经介绍了define的用法，下面我们使用define来定义一个过程\n\n```scheme\n(define twice(f)\n  (begin f f))\n```\n\n当我们输入`（twice （print 'woof））`我们希望能输出两次woof，然而\n\n```scheme\nscm> (twice (print 'woof))\nwoof\n```\n\n这是怎么回事呢？\n\n我们一步一步来，首先我们对操作符twice进行评估，返回我们定义的twice过程，而后我们对`(print 'woof)`进行评估，打印woof，而后将返回的undefined值绑定到f，而后将操作数字应用于操作符，得到表达式`（begin undefined undefined）`对该表达式进行评估，无返回值\n\n那么我们该怎么样修改才能得到正确输出呢？\n\n我们想要最终评估的表达式是这样的，`begin （print 'woof）(print 'woof)` ，因此，我们想到一种办法\n\n```scheme\n(define (twice f)\n  (eval (list 'begin f f))\n```\n\n为了保证最终评估的表达式是`begin （print 'woof）(print 'woof)` ，我们稍微改变了一下输入的值\n\n```scheme\nscm> (twice '(print 'woof))\nwoof\nwoof\n```\n\n这样我们就通过eval list返回的列表，完成了正确输出。\n\n但是肯定有人会想，为什么要这么麻烦，在进入函数的时候用‘防止被eval，结果在出来的时候又得加个eval，那索性就直接让操作数不评估不就行了。\n\n诶，没错，这个问题，前人已经考虑到了，而且他们还设计了一种语法来解决这个问题，这种语法被叫做macro，宏。\n\n```scheme\nscm> (define-macro (twice f) (list 'begin f f))\ntwice\nscm> (twice (print 'woof))\nwoof\nwoof\n```\n\ndefine-macro允许我们定义macro，这是我们将未计算的输入表达式组合到另一个表达式中的一种方式。当我们调用宏时，操作数不会被评估，而是被视为 Scheme 数据。这意味着任何作为调用表达式或特殊形式表达式的操作数都被视为列表。\n\n在我们的例子中，我们需要一个如下所示的begin 表达式\n\n```scheme\n(begin (print 'woof) (print 'woof))\n```\n\n作为 Scheme 数据，这个表达式实际上只是一个包含三个元素的列表：begin和(print 'woof)两次，这正是(list 'begin f f)返回的内容。现在，当我们调用 时twice，这个列表被评估为一个表达式并被(print 'woof)评估两次。\n\n回顾一下，宏的调用方式与常规过程类似，但评估它们的规则不同。我们通过以下方式评估了 lambda 过程：\n\n>1.评估运算符\n>2.评估操作数\n>3.将运算符应用于操作数，评估过程的主体\n\n但是，评估对宏过程调用的规则是：\n\n>1.评估运算符\n>2.将运算符应用于未计算的操作数\n>3.评估宏在调用它的框架中返回的表达式。\n\n这种特性使得scheme语言具有很强的扩展性，可以随意设计各种不同的语法来进行运算，举个例子，如果我们想把Scheme的定义语法用Python的风格写出来，该怎么做呢？\n\n这时候我们就可以利用宏来实现。\n\n```scheme\n(define-macro (def func bindings body)\n    (list 'define (cons func bindings) body))\n```\n\n```scheme\nscm< (def f(x y) (+ x y))\nf\n```\n\n这样我们就可以使用具有Python风格的语法来定义scheme函数了。\n\n##### Quasiquote\n\n回想一下，quote特殊形式会阻止 Scheme 解释器执行表达式,如果我们试图构建具有许多嵌套列表的复杂 Scheme 表达式，这种形式似乎会派上用场。\n\n考虑我们将twice宏重写如下\n\n```scheme\n(define-macro (twice f)\n  '(begin f f))\n```\n\n这似乎会产生相同的效果，但由于quote 表单阻止了任何评估，我们创建的结果表达式实际上是`(begin f f)`，这不是我们想要的。\n\n乍一看，quasiquote（可以用反引号`或quasiquote特殊形式调用）与quote的行为完全相同。但是，使用quasiquote可以使用逗号，从引用的上下文中删除一个表达式，对其进行评估，然后将其放回原处。\n\n下面是我们如何使用 quasiquote 来重写我们之前的示例：\n\n```scheme\n(define-macro (twice f)\n  `(begin ,f ,f))\n```\n\n同样我们重写def实例：\n\n```scheme\n(define-macro (def func bindings body)\n    `(define ,(cons func bindings) ,body))\n```\n\n其执行结果不变。\n\n#### 流\n\n在Python当中，我们使用迭代器和生成器来实现惰性求值\n\n```python\ndef ints(first):\n    while True:\n        yield first\n        first += 1\n```\n\n```python\n>>> s = ints(1)\n>>> next(s)\n1\n>>> next(s)\n2\n```\n\n然而，在Scheme语言中，没有迭代器和生成器，让我们看看如果我们使用scheme列表来进行循环迭代求值会产生什么情况。\n\n```scheme\n(define (ints first)\n    (cons first (ints (+ first 1)))\n```\n\n```scheme\nscm> (ints 1)\nmaximum recursion depth exceeded\n```\n\n由于cons是一个连续求值的过程，在cons结构建立之前，需要对所有值进行逐个评估，因此我们不能用cons创建一个无限循环的列表，然而，scheme解释器引入了流，流是一个特殊的scheme列表，在进行评估时，第一个值会进行评估，而第二个值会被保留，直到我们需要进行评估时才执行，在程序编写范式中，这种模式被称作惰性求值。\n\n我们使用以下语法结构创建一个流\n\n```scheme\n(cons-stream <operand1> <operand2>)\n```\n\n我们以自然数无限循环列表为例讲解流的操作\n\n```scheme\n(define (ints first)\n    (cons-stream first\n                 (ints (+ first 1)))\n```\n\n```scheme\nscm> (ints 1)\n(1 . #[promise (not forced)])\n```\n\n可以看出，流在进行评估的时候，只会评估第一个值，而保留第二个值，而后返回一个列表。\n\n我们首先将循环列表返回的值赋给一个变量a\n\n```scheme\nscm>(define a (int 1))\n```\n\n而后我们对列表进行操作，如果我们仅使用cdr\n\n```scheme\nscm> (cdr (int 1))\n#[promise (not forced)]\n```\n\n我们发现依然没有评估，因为我们需要使用cdr-stream，才能让列表第二个值评估后返回。\n\n```scheme\nscm> (cdr-stream a)\n(2 . #[promise (not forced)])\n```\n\n这样我们就能得到第二个值评估后的结果。\n\n利用流能做些什么呢？我们举一个例子\n\n假设我们有一个自然数循环列表，我们需要得到一个对每个值都运用函数后返回值构成的循环列表，那么我们该怎么做呢？\n\n```scheme\n(define (naturals n)\n  (cons-stream n (naturals (+ n 1))))\n\n(define nat (naturals 0))\n\n(define (map-stream f s)\n  (cons-stream (f (car s)) (map-stream f (cdr-stream s))))\n\n(define evens (map-stream (lambda (x) (* x 2)) nat))\n\n```\n\n首先，我们创建一个循环列表，并将其赋给变量`nat`，而后我们创建一个`map-stream`函数，引入循环列表和一个匿名函数作为参数，再将返回的列表赋给变量`even`由于cons-stream惰性求值的性质，我们在得到第一个值后并不会继续评估，因此`even`就变成了返回两倍自然数的循环列表，是不是很有趣呢？\n\n以上统统扯淡，看文档都能会，接下来进入正题。\n\n### 抽象语言的解释器\n\n#### 解释器的实现\n\n这是一个非常庞大的项目，CS61A利用Python构建了一个Scheme的解释器，也就是说，当完成这个解释器之后，我们就可以利用自己写的解释器进行scheme文档的解释与输出了，其实所有的编程语言本质都是解释器，你必须要采用合理的解释器将计算机无法理解的语言转换成计算机可以理解的语言，这样才能实现各种功能。\n\n整个解释器分为三个步骤，Read，Eval，Print，我们着重讲解前两个步骤。\n\n单个Read部分，这一步将用户的输入解析为解释器内部的一种抽象数据类型，我们在Python中构建了Pair这个类来将用户的输入从字符串转换成类的实例对象，以便于下一步对输入的整个表达式进行操作，主要有词法分析和句法分析两个步骤。\n\nEval部分，这一步评估Scheme表达式以获得相应的值，我们知道，对于基础表达式例如 数字，布尔值，符号等来说，只需要对其进行评估后返回即可，而对于有操作符和操作数的调用表达式来说，我们要遵循调用表达式评估的顺序，忘记了？我们再来回顾一遍。\n\n>1.评估操作符，应该评估为一个过程\n>\n>2.从左到右评估操作数\n>\n>3.操作数应用于过程\n\n操作符评估后，将会返回相应的过程，如果被求值的表达式是特殊形式，比如if,cond等等，将调用相应的函数进行操作，而后对操作数进行评估，注意，如果操作数也是调用表达式，那么依然要按顺序进行评估后返回。接下来就是将评估后的操作数应用于过程了，这里的过程有两种，一是内置过程，二是我们自己创建的Lambda过程，在后面我们会详细介绍如何分别实现这两种过程的应用。\n\nPrint部分，这部分就不细讲了，就是使用str打印获得值即可。\n\n还有一个问题就是，我们需要让整个解释器循环起来，总不能每次输入一次表达式得出结果就终止了程序吧，所以我们需要一个逻辑循环函数。\n\nOK，从Read开始讲起。\n\n#### Read部分\n\n##### Pair类\n\n前面我们讲到，Read部分是将用户输入的字符串，通过词法分析和句法分析转换成某种抽象数据类型，以供后续的分析\n\n首先我们来定义一种能够接收并存储用户输入字符串的数据类型Pair\n\n```python\nclass Pair(object):\n    \"\"\"A pair has two instance attributes: first and second. Second must be a Pair or nil\n\n    >>> s = Pair(1, Pair(2, nil))\n    >>> s\n    Pair(1, Pair(2, nil))\n    >>> print(s)\n    (1 2)\n    >>> print(s.map(lambda x: x+4))\n    (5 6)\n    \"\"\"\n    def __init__(self, first, second):\n        from scheme_builtins import scheme_valid_cdrp, SchemeError\n        if not (second is nil or isinstance(second, Pair) or type(second).__name__ == 'Promise'):\n            raise SchemeError(\"cdr can only be a pair, nil, or a promise but was {}\".format(second))\n        self.first = first\n        self.second = second\n\n    def __repr__(self):\n        return 'Pair({0}, {1})'.format(repr(self.first), repr(self.second))\n\n    def __str__(self):\n        s = '(' + repl_str(self.first)\n        second = self.second\n        while isinstance(second, Pair):\n            s += ' ' + repl_str(second.first)\n            second = second.second\n        if second is not nil:\n            s += ' . ' + repl_str(second)\n        return s + ')'\n\n    def __len__(self):\n        n, second = 1, self.second\n        while isinstance(second, Pair):\n            n += 1\n            second = second.second\n        if second is not nil:\n            raise TypeError('length attempted on improper list')\n        return n\n\n    def __eq__(self, p):\n        if not isinstance(p, Pair):\n            return False\n        return self.first == p.first and self.second == p.second\n\n    def map(self, fn):\n        \"\"\"Return a Scheme list after mapping Python function FN to SELF.\"\"\"\n        mapped = fn(self.first)\n        if self.second is nil or isinstance(self.second, Pair):\n            return Pair(mapped, self.second.map(fn))\n        else:\n            raise TypeError('ill-formed list (cdr is a promise)')\n```\n\n我们可以看出，Pair的结构非常像Link，其实本质也是一种迭代对象，只不过在link的基础上增加了一些内置方法，用于对Pair对象进行各种操作。\n\n##### 词法分析\n\n当用户输入一个字符串 \n\n```scheme\nscm> (+ 1 2)\n```\n\n解释器首先要对其进行词法分析，在该项目中，我们使用tokenize_lines函数和Buffer类进行词法分析，最终返回一个Buffer对象src\n\n```scheme\nnext_line = buffer_input\n\nsrc = next_line()\n```\n\n根据函数调用的顺序，涉及的函数调用如下：\n\n```python\n\n获取字符串\ndef buffer_input(prompt='scm> '):\n    \"\"\"Return a Buffer instance containing interactive input.\"\"\"\n    return Buffer(tokenize_lines(InputReader(prompt)))\n    \n#获取输入字符串，逐个字符传入tokenize_line函数执行    \ndef tokenize_lines(input):\n    \"\"\"An iterator over lists of tokens, one for each line of the iterable\n    input sequence.\"\"\"\n    return (tokenize_line(line) for line in input)\n\n#获取tokenize_line函数执行返回结果构成的列表，并将其转为Buffer类的实例对象\nclass Buffer(object):\n    def __init__(self, source):\n        self.index = 0\n        self.lines = []\n        self.source = source\n        self.current_line = ()\n        self.current()\n\n    def remove_front(self):\n        \"\"\"Remove the next item from self and return it. If self has\n        exhausted its source, returns None.\"\"\"\n        current = self.current()\n        self.index += 1\n        return current\n\n    def current(self):\n        \"\"\"Return the current element, or None if none exists.\"\"\"\n        while not self.more_on_line:\n            self.index = 0\n            try:\n                self.current_line = next(self.source)\n                self.lines.append(self.current_line)\n            except StopIteration:\n                self.current_line = ()\n                return None\n        return self.current_line[self.index]\n\n    @property\n    def more_on_line(self):\n        return self.index < len(self.current_line)\n\n    def __str__(self):\n        \"\"\"Return recently read contents; current element marked with >>.\"\"\"\n        # Format string for right-justified line numbers\n        n = len(self.lines)\n        msg = '{0:>' + str(math.floor(math.log10(n))+1) + \"}: \"\n\n        # Up to three previous lines and current line are included in output\n        s = ''\n        for i in range(max(0, n-4), n-1):\n            s += msg.format(i+1) + ' '.join(map(str, self.lines[i])) + '\\n'\n        s += msg.format(n)\n        s += ' '.join(map(str, self.current_line[:self.index]))\n        s += ' >> '\n        s += ' '.join(map(str, self.current_line[self.index:]))\n        return s.strip()\n```\n\nBuffer实例有两个核心方法remove_front和current，这两个方法可以对Buffer对象里的值进行有序输出。\n\n```scheme\n>>> buf = Buffer(iter([['(', '+'], [15], [12, ')']]))\n>>> buf.remove_front()\n'('\n>>> buf.remove_front()\n'+'\n>>> buf.current()\n15\n>>> print(buf)\n1: ( +\n2:  >> 15\n>>> buf.remove_front()\n15\n```\n\n经过词法分析，用户输入的字符串被转换成了可有序输出的Buffer实例对象，就好像排列在内存中的数据一样，但是有一个问题就在于，对于这些存在实例对象中的数据，数据之间的相互关联并没有建立，就好像在游乐园等待入场的队列，虽然有序，但是相互之间毫无关联。\n\n因此我们要进行句法分析。\n\n##### 句法分析\n\n在该项目中，我们使用scheme_read进行句法分析，最终返回一个Pair对象expression\n\n```scheme\nexpression = scheme_read(src)\n```\n\n我们来看一下scheme_read的逻辑流程\n\n```python\ndef scheme_read(src):\n    \"\"\"Read the next expression from SRC, a Buffer of tokens.\n\n    >>> scheme_read(Buffer(tokenize_lines(['nil'])))\n    nil\n    >>> scheme_read(Buffer(tokenize_lines(['1'])))\n    1\n    >>> scheme_read(Buffer(tokenize_lines(['true'])))\n    True\n    >>> scheme_read(Buffer(tokenize_lines(['(+ 1 2)'])))\n    Pair('+', Pair(1, Pair(2, nil)))\n    \"\"\"\n    if src.current() is None:\n        raise EOFError\n    val = src.remove_front() # Get the first token\n    if val == 'nil':\n        # BEGIN PROBLEM 2\n        return nil\n        # END PROBLEM 2\n    elif val == '(':\n        # BEGIN PROBLEM 2\n        return read_tail(src)\n        # END PROBLEM 2\n    elif val in quotes:\n        # BEGIN PROBLEM 7\n        return Pair(quotes[val],Pair(scheme_read(src),nil))\n        # END PROBLEM 7\n    elif val not in DELIMITERS:\n        return val\n    else:\n        raise SyntaxError('unexpected token: {0}'.format(val))\n\ndef read_tail(src):\n    \"\"\"Return the remainder of a list in SRC, starting before an element or ).\n\n    >>> read_tail(Buffer(tokenize_lines([')'])))\n    nil\n    >>> read_tail(Buffer(tokenize_lines(['2 3)'])))\n    Pair(2, Pair(3, nil))\n    \"\"\"\n    try:\n        if src.current() is None:\n            raise SyntaxError('unexpected end of file')\n        elif src.current() == ')':\n            # BEGIN PROBLEM 2\n            src.remove_front()\n            return nil\n            # END PROBLEM 2\n        else:\n            # BEGIN PROBLEM 2\n            return Pair(scheme_read(src),read_tail(src))\n            # END PROBLEM 2\n    except EOFError:\n        raise SyntaxError('unexpected end of file')\n\nquotes = {\"'\":  'quote',\n          '`':  'quasiquote',\n          ',':  'unquote'}\n        \n```\n\n我们可以看出，对于不同的结构，scheme_read有不同的方案去构造，主要可以分为三种，一种是普通的基础表达式，比如123，nil和布尔值，一种是调用表达式，scheme_read函数规定当遇到‘（’时会自动进入read_tail函数，最终返回一个完整的Pair结构，第三种就是符号，函数会判断这个符号是Quote，Quasiquote还是unquote，并将这三个模式传入以供后期评估使用。\n\n最终输入如下\n\n```python\n>>> scheme_read(Buffer(tokenize_lines(['(+ 1 2)'])))\nPair('+', Pair(1, Pair(2, nil)))\n```\n\n可以看出，经过句法分析，我们建立了字符之间的关联性，同属于一个调用表达式的字符被整合进 了独立的一个Pair实例，就好比，让在排队的人，夫妻合并成一组，家庭或朋友合并成一组，再进行排队。\n\n经过第一部分Read，我们拥有了具有关联性的Pair对象，在接下来的Eval部分中，我们将要对这个对象进行评估。\n\n#### Eval 部分\n\n在整个评估过程中，有两个类发挥着重要作用，一个类是Frame，Frame类是一个环境框架，我们学习Python作用域的时候学习过，程序开始时候是在Global Frame下，当调用函数时候，会创建一个Frame，并且在该Frame下创建的变量和传入的参数是不能在Global Frame下被使用的，Scheme同样如此，所以我们创建了一个Frame类用于分离不同作用域。一个类是Procedure，Procedure类是过程类，他有两个子类，一个是BuiltinProcedure，即内置过程，比如我们使用的if，cons，cond都是内置过程，另一个是LambdaProcedure，即匿名过程，这是用来创建并绑定用户定义过程的。\n\n##### Frame类\n\nEFrame类实现了环境框架，在对解释器进行初始化的时候，会调用create_global_frame创建一个Frame环境框架。\n\n```python\nclass Frame(object):\n    \"\"\"An environment frame binds Scheme symbols to Scheme values.\"\"\"\n\n    def __init__(self, parent):\n        \"\"\"An empty frame with parent frame PARENT (which may be None).\"\"\"\n        self.bindings = {}\n        self.parent = parent\n\n    def __repr__(self):\n        if self.parent is None:\n            return '<Global Frame>'\n        s = sorted(['{0}: {1}'.format(k, v) for k, v in self.bindings.items()])\n        return '<{{{0}}} -> {1}>'.format(', '.join(s), repr(self.parent))\n\n    def define(self, symbol, value):\n        \"\"\"Define Scheme SYMBOL to have VALUE.\"\"\"\n        # BEGIN PROBLEM 3\n        self.bindings[symbol]=value\n        # END PROBLEM 3\n\n    def lookup(self, symbol):\n        \"\"\"Return the value bound to SYMBOL. Errors if SYMBOL is not found.\"\"\"\n        # BEGIN PROBLEM 3\n        try:\n            return self.bindings[symbol]\n        except KeyError:\n            if self.parent is not None:\n                return self.parent.lookup(symbol)\n        # END PROBLEM 3\n        raise SchemeError('unknown identifier: {0}'.format(symbol))\n\n    def make_child_frame(self, formals, vals):\n        \"\"\"Return a new local frame whose parent is SELF, in which the symbols\n        in a Scheme list of formal parameters FORMALS are bound to the Scheme\n        values in the Scheme list VALS. Raise an error if too many or too few\n        vals are given.\n\n        >>> env = create_global_frame()\n        >>> formals, expressions = read_line('(a b c)'), read_line('(1 2 3)')\n        >>> env.make_child_frame(formals, expressions)\n        <{a: 1, b: 2, c: 3} -> <Global Frame>>\n        \"\"\"\n        # BEGIN PROBLEM 11\n        match_dict = {}\n        if len(formals)!=len(vals):\n            raise SchemeError('The number of argument values does not match')\n        else:\n            for _ in range(len(formals)):\n                match_dict[formals.first] = vals.first\n                formals = formals.second\n                vals = vals.second\n        new_frame = Frame(self)\n        for key,value in match_dict.items():\n            new_frame.define(key,value)\n        return new_frame\n        # END PROBLEM 11\n\n```\n\nFrame框架类从外界引入一个父环境Frame实例，并维护一个binding列表，在初始化时候，会在初始Frame环境中调用define方法引入内置过程，在后面的过程中，如果需要引入用户过程，可以通过define引入，查找内置过程，可以通过lookup方法实现。\n\n```python\ndef create_global_frame():\n    \"\"\"Initialize and return a single-frame environment with built-in names.\"\"\"\n    env = Frame(None)\n    env.define('eval',\n               BuiltinProcedure(scheme_eval, True, 'eval'))\n    env.define('apply',\n               BuiltinProcedure(complete_apply, True, 'apply'))\n    env.define('load',\n               BuiltinProcedure(scheme_load, True, 'load'))\n    env.define('procedure?',\n               BuiltinProcedure(scheme_procedurep, False, 'procedure?'))\n    env.define('map',\n               BuiltinProcedure(scheme_map, True, 'map'))\n    env.define('filter',\n               BuiltinProcedure(scheme_filter, True, 'filter'))\n    env.define('reduce',\n               BuiltinProcedure(scheme_reduce, True, 'reduce'))\n    env.define('undefined', None)\n    add_builtins(env, BUILTINS)\n    return env\n```\n\n当子环境创建需要引入一个Frame实例时，Frame可以调用make_child_frame创建一个子Frame并返回。\n\n```python\ndef make_call_frame(self,args,env):\n        return env.make_child_frame(self.formals, args)\n```\n\n##### Procedure类\n\n```python\nclass BuiltinProcedure(Procedure):\n    \"\"\"A Scheme procedure defined as a Python function.\"\"\"\n\n    def __init__(self, fn, use_env=False, name='builtin'):\n        self.name = name\n        self.fn = fn\n        self.use_env = use_env\n\n    def __str__(self):\n        return '#[{0}]'.format(self.name)\n\n    def apply(self, args, env):\n        \"\"\"Apply SELF to ARGS in ENV, where ARGS is a Scheme list.\n\n        >>> env = create_global_frame()\n        >>> plus = env.bindings['+']\n        >>> twos = Pair(2, Pair(2, nil))\n        >>> plus.apply(twos, env)\n        4\n        \"\"\"\n        if not scheme_listp(args):\n            raise SchemeError('arguments are not in a list: {0}'.format(args))\n        # Convert a Scheme list to a Python list\n        python_args = []\n        while args is not nil:\n            python_args.append(args.first)\n            args = args.second\n        # BEGIN PROBLEM 4\n        if self.use_env:\n            python_args.append(env)\n        try:\n            return self.fn(*python_args)\n        except TypeError:\n            raise SchemeError(\"Invalid number of arguments to {0}\".format(self.name))\n        # END PROBLEM 4\n\nclass LambdaProcedure(Procedure):\n    \"\"\"A procedure defined by a lambda expression or a define form.\"\"\"\n\n    def __init__(self, formals, body, env):\n        \"\"\"A procedure with formal parameter list FORMALS (a Scheme list),\n        whose body is the Scheme list BODY, and whose parent environment\n        starts with Frame ENV.\"\"\"\n        self.formals = formals\n        self.body = body\n        self.env = env\n\n    def make_call_frame(self, args, env):\n        \"\"\"Make a frame that binds my formal parameters to ARGS, a Scheme list\n        of values, for a lexically-scoped call evaluated in environment ENV.\"\"\"\n        # BEGIN PROBLEM 12\n        new_frame = self.env.make_child_frame(self.formals,args)\n        return new_frame\n        # END PROBLEM 12\n\n    def __str__(self):\n        return str(Pair('lambda', Pair(self.formals, self.body)))\n\n    def __repr__(self):\n        return 'LambdaProcedure({0}, {1}, {2})'.format(\n            repr(self.formals), repr(self.body), repr(self.env))\n```\n\n内置过程表示为BuiltinProcedure实例，BuiltinProcedure具有两个实例属性，fn是实施内置方案程序的Python功能，use_env是一个布尔标志，指示这个内置程序是否会期望当前环境作为最后一个参数传递。例如，需要环境来实施内置eval程序。\n\n用户定义的程序表示为LambdaProcedure实例。LambdaProcedure具有三个实例属性，formals是命名程序参数的正式参数（符号）的方案列表。body是一个方案列表的表达式，程序的主体。\nenv是定义程序的Frame环境。\n\n##### 评估仅内置过程的表达式\n\n当我们评估只有内置过程的表达式的时候，我们会进行这个过程\n\n```python\nif scheme_symbolp(first) and first in SPECIAL_FORMS:\n        return SPECIAL_FORMS[first](rest, env)\n```\n\n这里的SPECIAL_FORMS就是内置过程的列表，我们通过first变量传入操作符名称，当我们发现评估的操作符是个内置过程的时候，我们就会调用这段代码找到对应调用内置过程的函数。\n\n```python\nSPECIAL_FORMS = {\n    'and': do_and_form,\n    'begin': do_begin_form,\n    'cond': do_cond_form,\n    'define': do_define_form,\n    'if': do_if_form,\n    'lambda': do_lambda_form,\n    'let': do_let_form,\n    'or': do_or_form,\n    'quote': do_quote_form,\n    'define-macro': do_define_macro,\n    'quasiquote': do_quasiquote_form,\n    'unquote': do_unquote,\n}\n```\n\n我们以评估define内置过程为例来讲解。\n\n```python\ndef do_define_form(expressions, env):\n    \"\"\"Evaluate a define form.\"\"\"\n    check_form(expressions, 2)\n    target = expressions.first\n    if scheme_symbolp(target):\n        check_form(expressions, 2, 2)\n        # BEGIN PROBLEM 6\n        value = scheme_eval(expressions.second.first,env)\n        env.define(target,value)\n        return target\n        # END PROBLEM 6\n    ...\n    else:\n        bad_target = target.first if isinstance(target, Pair) else target\n        raise SchemeError('non-symbol: {0}'.format(bad_target))\n```\n\ndo_define_form函数引入了两个参数，根据调用函数可知，传入的expression参数是调用表达式的操作数部分，因此就把操作数评估后的结果在全局环境下与设定的变量绑定了，其关键代码为\n\n```python\n env.define(target,value)\n```\n\n这就是实现一个内置过程的办法，接下来我们来看看该如何实现用户定义函数。\n\n##### 评估带有用户定义的表达式\n\n我们先来看看如何使用内置过程`define`定义一个用户过程。\n\n```python\ndef do_define_form(expressions, env):\n    \"\"\"Evaluate a define form.\"\"\"\n    check_form(expressions, 2)\n    target = expressions.first\n    if scheme_symbolp(target):\n        check_form(expressions, 2, 2)\n        # BEGIN PROBLEM 6\n        value = scheme_eval(expressions.second.first,env)\n        env.define(target,value)\n        return target\n        # END PROBLEM 6\n    elif isinstance(target, Pair) and scheme_symbolp(target.first):\n        # BEGIN PROBLEM 10\n        name = target.first\n        formal = target.second\n        body = expressions.second\n        process = LambdaProcedure(formal,body,env)\n        env.define(name,process)\n        return name\n        # END PROBLEM 10\n    else:\n        bad_target = target.first if isinstance(target, Pair) else target\n        raise SchemeError('non-symbol: {0}'.format(bad_target))\n```\n\n我们看到，这个define函数比之前仅能定义变量的函数多了elif的部分，在这个过程中，函数首先将整个定义代码段分成name函数名称，formal函数参数，和body函数主体三个部分，而后将这三个部分放入LambdaProcedure类创建一个实例，最后调用Frame的define过程将新定义的过程实例与过程名绑定，以便后期lookup函数的查找。\n\n我们来看看创建新过程的实例时候，发生了什么。\n\n```python\nclass LambdaProcedure(Procedure):\n    \"\"\"A procedure defined by a lambda expression or a define form.\"\"\"\n\n    def __init__(self, formals, body, env):\n        \"\"\"A procedure with formal parameter list FORMALS (a Scheme list),\n        whose body is the Scheme list BODY, and whose parent environment\n        starts with Frame ENV.\"\"\"\n        self.formals = formals\n        self.body = body\n        self.env = env\n\n    def make_call_frame(self, args, env):\n        \"\"\"Make a frame that binds my formal parameters to ARGS, a Scheme list\n        of values, for a lexically-scoped call evaluated in environment ENV.\"\"\"\n        # BEGIN PROBLEM 12\n        new_frame = self.env.make_child_frame(self.formals,args)\n        return new_frame\n        # END PROBLEM 12\n\n    def __str__(self):\n        return str(Pair('lambda', Pair(self.formals, self.body)))\n\n    def __repr__(self):\n        return 'LambdaProcedure({0}, {1}, {2})'.format(\n            repr(self.formals), repr(self.body), repr(self.env))\n```\n\n可以看到，lambda维护着一个方法，当调用到用户实例的时候，就会调用这个方法，打开一个新Frame进行运算。\n\n最后对调用表达式执行apply操作\n\n````python\ndef scheme_apply(procedure, args, env):\n    \"\"\"Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in\n    environment ENV.\"\"\"\n    check_procedure(procedure)\n    if isinstance(procedure, BuiltinProcedure):\n        return procedure.apply(args, env)\n    else:\n        new_env = procedure.make_call_frame(args, env)\n        return eval_all(procedure.body, new_env)\n\ndef eval_all(expressions, env):\n    \"\"\"Evaluate each expression in the Scheme list EXPRESSIONS in\n    environment ENV and return the value of the last.\"\"\"\n    # BEGIN PROBLEM 8\n    if expressions == nil:\n        return None\n    else:\n        value = expressions.map((lambda x:scheme_eval(x,env)))\n        while value is not nil:\n            now = value.first\n            value = value.second\n        return now\n````\n\n至此，整个解释器就写完了，再加上内置的自循环函数，一个可以运行Scheme程序的python解释器就大功告成了。在61A 的Scheme项目中，还有如宏和流这种复杂的过程，大家可以自行学习，不过本质还是和内置过程的评估相差不大。学习这个项目的目的不是真的要完成一个解释器，而是要让你学会和理解解释器是如何”翻译“一种语言的，这样你才能更好的去理解各种编程范式，例如函数式编程，面向对象编程.\n\n\n\n","slug":"CS61A-元语言抽象","published":1,"updated":"2023-02-11T11:15:16.031Z","_id":"cks4bvdpz00006prh4ivt2shg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CS61A-元语言抽象\"><a href=\"#CS61A-元语言抽象\" class=\"headerlink\" title=\"CS61A 元语言抽象\"></a>CS61A 元语言抽象</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>Scheme语言</p>\n<ul>\n<li>表达式</li>\n<li>控制结构与列表</li>\n<li>定义变量与函数</li>\n<li>匿名过程</li>\n</ul>\n<p>Scheme语言特性</p>\n<ul>\n<li>宏</li>\n<li>流</li>\n</ul>\n<p>抽象语言的解释器</p>\n<ul>\n<li>解释器的实现</li>\n<li>读取过程</li>\n<li>评估过程</li>\n<li>输出过程</li>\n</ul>\n</blockquote>\n<p>在之前的章节中，我们都是基于一门语言去研究程序的抽象形式，而本 书的最后一个部分直接跳出了语言，讲解一门语言是怎么样抽象的，也就是说，这一章，是在教你如何实现一门语言，我们这里所说的语言是脚本语言，接下来，我们就要以Scheme语言为例，讲解Scheme语言是怎么样一步一步构造出来的。</p>\n<h3 id=\"Scheme语言\"><a href=\"#Scheme语言\" class=\"headerlink\" title=\"Scheme语言\"></a>Scheme语言</h3><p>首先我们从使用者的角度了解一下Scheme的语法。</p>\n<h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><p>最基础的表达式可以是数字，布尔值或者符号，这里的符号是我们在Python语言中唯一没有遇到的类型，具体来说，Scheme中的符号也是一种值。</p>\n<h5 id=\"原子表达式\"><a href=\"#原子表达式\" class=\"headerlink\" title=\"原子表达式\"></a>原子表达式</h5><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; 1234    ; integer</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br><span class=\"line\">scm&gt; 123.4   ; real number</span><br><span class=\"line\"><span class=\"number\">123.4</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h5><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; #t</span><br><span class=\"line\">#t</span><br><span class=\"line\">scm&gt; #f</span><br><span class=\"line\">#f</span><br></pre></td></tr></table></figure>\n\n<p>在 Scheme 中，除了特殊的布尔值#f之外的所有值都被解释为真值（与 Python 不同，Python 中有一些像0那样的假值）</p>\n<h5 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"符号\"></a>符号</h5><p>其中，符号类型是我们在 Python 中唯一没有遇到的类型。一个 符号的作用很像一个Python的名字，但不完全是。具体来说，Scheme 中的符号也是一种值。在 Python 中，名称仅用作表达式；Python 表达式永远不能计算为名称。</p>\n<p>这个过程具体是怎么实现的，我们后面再讲。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; quotient      ; A name bound to a built-in procedure</span><br><span class=\"line\">#[quotient]</span><br><span class=\"line\">scm&gt; &#x27;quotient     ; An expression that evaluates to a symbol</span><br><span class=\"line\">quotient</span><br><span class=\"line\">scm&gt; &#x27;hello-world!</span><br><span class=\"line\">hello-world!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调用表达式\"><a href=\"#调用表达式\" class=\"headerlink\" title=\"调用表达式\"></a>调用表达式</h4><p>与 Python 一样，Scheme 调用表达式中的运算符位于所有操作数之前。与 Python 不同的是，运算符包含在括号内，并且操作数由空格而不是逗号分隔。然而，Scheme 调用表达式的计算遵循与 Python 完全相同的规则：</p>\n<p>1.评估操作符，应该评估为一个过程</p>\n<p>2.从左到右评估操作数</p>\n<p>3.操作数应用于过程</p>\n<p>以下是一些使用内置过程的示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (+ 1 2)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">scm&gt; (- 10 (/ 6 2))</span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\">scm&gt; (modulo 35 4)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">scm&gt; (even? (quotient 45 2))</span><br><span class=\"line\">#t</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"控制结构与列表\"><a href=\"#控制结构与列表\" class=\"headerlink\" title=\"控制结构与列表\"></a>控制结构与列表</h4><h5 id=\"if表达式\"><a href=\"#if表达式\" class=\"headerlink\" title=\"if表达式\"></a>if表达式</h5><p>该if特殊形式使我们能够评估基于谓词两个表达式之一。它接受两个必需的参数和一个可选的第三个参数：</p>\n<blockquote>\n<p>(if <predicate> <if-true> [if-false])</p>\n</blockquote>\n<p>第一个操作数是Scheme 中所谓的谓词表达式，该表达式的值被解释为#tor 或#f。</p>\n<p>计算if特殊形式表达式的规则如下：</p>\n<p>1.评估<predicate>。<br>2.如果<predicate>评估为真值，则评估并返回该值，如果表达式<if-true>. 否则，[if-false]如果提供，则评估并返回值 。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (if (&gt; x 3)</span><br><span class=\"line\">         <span class=\"number\">1</span></span><br><span class=\"line\">         2)</span><br></pre></td></tr></table></figure>\n\n<p>在 Scheme 中，您不能编写elif案例。如果要使用if表达式有多个案例，则需要多个分支if表达式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (if (&lt; x 0)</span><br><span class=\"line\">         <span class=\"symbol\">&#x27;negative</span></span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">             <span class=\"symbol\">&#x27;zero</span></span><br><span class=\"line\">             <span class=\"symbol\">&#x27;positive</span></span><br><span class=\"line\">         )</span><br><span class=\"line\"> )</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"cond表达式\"><a href=\"#cond表达式\" class=\"headerlink\" title=\"cond表达式\"></a>cond表达式</h5><p>使用嵌套if表达式似乎不是处理多种情况的非常实用的方法。相反，我们可以使用cond特殊形式，一种类似于 Python 中的多子句 if/elif/else 条件表达式的通用条件表达式。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    (<span class=\"name\">&lt;p1&gt;</span> &lt;e1&gt;)</span><br><span class=\"line\">    (<span class=\"name\">&lt;p2&gt;</span> &lt;e2&gt;)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    (<span class=\"name\">&lt;pn&gt;</span> &lt;en&gt;)</span><br><span class=\"line\">    [(<span class=\"name\"><span class=\"builtin-name\">else</span></span> &lt;else-expression&gt;)])</span><br></pre></td></tr></table></figure>\n\n<p>评价规则如下：</p>\n<p>1.对谓词<p1>, <p2>, …,<pn>进行求值，直到达到求值为真 y 值的谓词为止。<br>2.如果您到达一个计算结果为真值的谓词，请计算并返回子句中的相应表达式。<br>3.如果没有一个谓词是真y并且有一个else子句，则评估并返回<else-expression>。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cond</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> x <span class=\"number\">0</span>) <span class=\"symbol\">&#x27;positive</span>)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>) <span class=\"symbol\">&#x27;negative</span>)</span><br><span class=\"line\">        (else &#x27;zero))</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h5><h6 id=\"cons\"><a href=\"#cons\" class=\"headerlink\" title=\"cons\"></a>cons</h6><p>Scheme 列表与我们在 Python 中使用的链表非常相似。就像链表是由一系列Link 对象构建的一样，Scheme 列表是由一系列对构建的，这些对是由构造函数创建的cons，是一种可递归对象。</p>\n<p>Scheme列表要cdr是另一个列表或nil空列表。列表在解释器中显示为值序列（类似于对象的 __str__表示Link）。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cons 1 (cons 2 (cons 3 nil)))</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>具体的实现方式用图像来表示就是</p>\n<p><img src=\"https://i.loli.net/2021/08/10/Le2kpYIwaAgWN8E.png\" alt=\"image-20210810094539083\"></p>\n<p>我们可以使用car和cdr从我们的列表中检索值，现在它的工作方式类似于 PythonLink的first和rest属性。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a</span><br><span class=\"line\">scm&gt; a</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (car a)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">scm&gt; (cdr a)</span><br><span class=\"line\">(<span class=\"name\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (car (cdr (cdr a)))</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>如果您没有将 pair 或 nil 作为第二个参数传递给cons，则会出错：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cons 1 2)</span><br><span class=\"line\">Error</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h6><p>另一种创建列表的方式是利用list，该list过程接受任意数量的参数并使用这些参数的值构造一个列表</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (list 1 2 3)</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (list 1 (list 2 3) 4)</span><br><span class=\"line\">(<span class=\"name\">1</span> (<span class=\"name\">2</span> <span class=\"number\">3</span>) <span class=\"number\">4</span>)</span><br><span class=\"line\">scm&gt; (list (cons 1 (cons 2 nil)) 3 4)</span><br><span class=\"line\">((<span class=\"name\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>请注意，此表达式中的所有操作数在放入结果列表之前都会进行评估。</p>\n<h6 id=\"Quote\"><a href=\"#Quote\" class=\"headerlink\" title=\"Quote\"></a>Quote</h6><p>我们还可以使用引用形式来创建一个列表，通过引用形式创建的列表不进评估</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; &#x27;(1 2 3)</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; &#x27;(cons 1 2)           ; Argument to quote is not evaluated</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">scm&gt; &#x27;(1 (2 3 4))</span><br><span class=\"line\">(<span class=\"name\">1</span> (<span class=\"name\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义变量与函数\"><a href=\"#定义变量与函数\" class=\"headerlink\" title=\"定义变量与函数\"></a>定义变量与函数</h4><p>在Python中定义变量使用=号进行，而定义变量使用def进行，而在Scheme中定义变量和过程都使用define语法，这个在后期解释器的构造中我也会着重细讲。</p>\n<p>定义变量，我们使用语法</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> &lt;name&gt; &lt;expression&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>评估这个表达式的规则是</p>\n<p>1.评估<expression>.<br>2.将其值绑定到<name>当前Frame中。<br>3.返回<name>。</p>\n<p>定义过程，我们使用语法</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">&lt;name&gt;</span> &lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt; )</span><br></pre></td></tr></table></figure>\n\n<p>要评估此表达式：</p>\n<p>1.使用给定的参数和 来创建一个 lambda 过程<body>。<br>2.将过程绑定到<name>当前帧中的 。<br>3.返回<name>。</p>\n<p>以下两个表达式是等价的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define foo (lambda (x y) (+ x y)))</span><br><span class=\"line\">foo</span><br><span class=\"line\">scm&gt; (define (foo x y) (+ x y))</span><br><span class=\"line\">foo</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"匿名过程\"><a href=\"#匿名过程\" class=\"headerlink\" title=\"匿名过程\"></a>匿名过程</h4><p>所有 Scheme 过程都是 lambda 过程。要创建 lambda 过程，我们可以使用lambda特殊形式</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (&lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn&#x27;t assign it to a name</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y))</span><br><span class=\"line\">scm&gt; ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>一个过程可以接受任意数量的参数。该<body>可以包含多个表达式。return Scheme 中没有 Python语句的等效版本。该函数将简单地返回正文中最后一个表达式的值。</p>\n<h3 id=\"Scheme语言特性\"><a href=\"#Scheme语言特性\" class=\"headerlink\" title=\"Scheme语言特性\"></a>Scheme语言特性</h3><h4 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h4><h5 id=\"Define-macro\"><a href=\"#Define-macro\" class=\"headerlink\" title=\"Define-macro\"></a>Define-macro</h5><p>宏是一个不好理解的概念，但是却是一个非常重要的概念，我们刚才已经介绍了define的用法，下面我们使用define来定义一个过程</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> twice(<span class=\"name\">f</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> f f))</span><br></pre></td></tr></table></figure>\n\n<p>当我们输入<code>（twice （print &#39;woof））</code>我们希望能输出两次woof，然而</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (twice (print &#x27;woof))</span><br><span class=\"line\">woof</span><br></pre></td></tr></table></figure>\n\n<p>这是怎么回事呢？</p>\n<p>我们一步一步来，首先我们对操作符twice进行评估，返回我们定义的twice过程，而后我们对<code>(print &#39;woof)</code>进行评估，打印woof，而后将返回的undefined值绑定到f，而后将操作数字应用于操作符，得到表达式<code>（begin undefined undefined）</code>对该表达式进行评估，无返回值</p>\n<p>那么我们该怎么样修改才能得到正确输出呢？</p>\n<p>我们想要最终评估的表达式是这样的，<code>begin （print &#39;woof）(print &#39;woof)</code> ，因此，我们想到一种办法</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">twice</span> f)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">eval</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;begin</span> f f))</span><br></pre></td></tr></table></figure>\n\n<p>为了保证最终评估的表达式是<code>begin （print &#39;woof）(print &#39;woof)</code> ，我们稍微改变了一下输入的值</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (twice &#x27;(print &#x27;woof))</span><br><span class=\"line\">woof</span><br><span class=\"line\">woof</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就通过eval list返回的列表，完成了正确输出。</p>\n<p>但是肯定有人会想，为什么要这么麻烦，在进入函数的时候用‘防止被eval，结果在出来的时候又得加个eval，那索性就直接让操作数不评估不就行了。</p>\n<p>诶，没错，这个问题，前人已经考虑到了，而且他们还设计了一种语法来解决这个问题，这种语法被叫做macro，宏。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define-macro (twice f) (list &#x27;begin f f))</span><br><span class=\"line\">twice</span><br><span class=\"line\">scm&gt; (twice (print &#x27;woof))</span><br><span class=\"line\">woof</span><br><span class=\"line\">woof</span><br></pre></td></tr></table></figure>\n\n<p>define-macro允许我们定义macro，这是我们将未计算的输入表达式组合到另一个表达式中的一种方式。当我们调用宏时，操作数不会被评估，而是被视为 Scheme 数据。这意味着任何作为调用表达式或特殊形式表达式的操作数都被视为列表。</p>\n<p>在我们的例子中，我们需要一个如下所示的begin 表达式</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\">print</span> <span class=\"symbol\">&#x27;woof</span>) (<span class=\"name\">print</span> <span class=\"symbol\">&#x27;woof</span>))</span><br></pre></td></tr></table></figure>\n\n<p>作为 Scheme 数据，这个表达式实际上只是一个包含三个元素的列表：begin和(print ‘woof)两次，这正是(list ‘begin f f)返回的内容。现在，当我们调用 时twice，这个列表被评估为一个表达式并被(print ‘woof)评估两次。</p>\n<p>回顾一下，宏的调用方式与常规过程类似，但评估它们的规则不同。我们通过以下方式评估了 lambda 过程：</p>\n<blockquote>\n<p>1.评估运算符<br>2.评估操作数<br>3.将运算符应用于操作数，评估过程的主体</p>\n</blockquote>\n<p>但是，评估对宏过程调用的规则是：</p>\n<blockquote>\n<p>1.评估运算符<br>2.将运算符应用于未计算的操作数<br>3.评估宏在调用它的框架中返回的表达式。</p>\n</blockquote>\n<p>这种特性使得scheme语言具有很强的扩展性，可以随意设计各种不同的语法来进行运算，举个例子，如果我们想把Scheme的定义语法用Python的风格写出来，该怎么做呢？</p>\n<p>这时候我们就可以利用宏来实现。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">def</span> func bindings body)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;define</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> func bindings) body))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&lt; (def f(x y) (+ x y))</span><br><span class=\"line\">f</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以使用具有Python风格的语法来定义scheme函数了。</p>\n<h5 id=\"Quasiquote\"><a href=\"#Quasiquote\" class=\"headerlink\" title=\"Quasiquote\"></a>Quasiquote</h5><p>回想一下，quote特殊形式会阻止 Scheme 解释器执行表达式,如果我们试图构建具有许多嵌套列表的复杂 Scheme 表达式，这种形式似乎会派上用场。</p>\n<p>考虑我们将twice宏重写如下</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">twice</span> f)</span><br><span class=\"line\">  &#x27;(begin f f))</span><br></pre></td></tr></table></figure>\n\n<p>这似乎会产生相同的效果，但由于quote 表单阻止了任何评估，我们创建的结果表达式实际上是<code>(begin f f)</code>，这不是我们想要的。</p>\n<p>乍一看，quasiquote（可以用反引号`或quasiquote特殊形式调用）与quote的行为完全相同。但是，使用quasiquote可以使用逗号，从引用的上下文中删除一个表达式，对其进行评估，然后将其放回原处。</p>\n<p>下面是我们如何使用 quasiquote 来重写我们之前的示例：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">twice</span> f)</span><br><span class=\"line\">  `(begin ,f ,f))</span><br></pre></td></tr></table></figure>\n\n<p>同样我们重写def实例：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">def</span> func bindings body)</span><br><span class=\"line\">    `(define ,(cons func bindings) ,body))</span><br></pre></td></tr></table></figure>\n\n<p>其执行结果不变。</p>\n<h4 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h4><p>在Python当中，我们使用迭代器和生成器来实现惰性求值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ints</span>(<span class=\"params\">first</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> first</span><br><span class=\"line\">        first += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = ints(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(s)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(s)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>然而，在Scheme语言中，没有迭代器和生成器，让我们看看如果我们使用scheme列表来进行循环迭代求值会产生什么情况。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">ints</span> first)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> first (<span class=\"name\">ints</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> first <span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (ints 1)</span><br><span class=\"line\">maximum recursion depth exceeded</span><br></pre></td></tr></table></figure>\n\n<p>由于cons是一个连续求值的过程，在cons结构建立之前，需要对所有值进行逐个评估，因此我们不能用cons创建一个无限循环的列表，然而，scheme解释器引入了流，流是一个特殊的scheme列表，在进行评估时，第一个值会进行评估，而第二个值会被保留，直到我们需要进行评估时才执行，在程序编写范式中，这种模式被称作惰性求值。</p>\n<p>我们使用以下语法结构创建一个流</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">cons-stream</span> &lt;operand1&gt; &lt;operand2&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>我们以自然数无限循环列表为例讲解流的操作</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">ints</span> first)</span><br><span class=\"line\">    (<span class=\"name\">cons-stream</span> first</span><br><span class=\"line\">                 (<span class=\"name\">ints</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> first <span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (ints 1)</span><br><span class=\"line\">(<span class=\"name\">1</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)])</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，流在进行评估的时候，只会评估第一个值，而保留第二个值，而后返回一个列表。</p>\n<p>我们首先将循环列表返回的值赋给一个变量a</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt;(define a (int 1))</span><br></pre></td></tr></table></figure>\n\n<p>而后我们对列表进行操作，如果我们仅使用cdr</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cdr (int 1))</span><br><span class=\"line\">#[promise (not forced)]</span><br></pre></td></tr></table></figure>\n\n<p>我们发现依然没有评估，因为我们需要使用cdr-stream，才能让列表第二个值评估后返回。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cdr-stream a)</span><br><span class=\"line\">(<span class=\"name\">2</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)])</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就能得到第二个值评估后的结果。</p>\n<p>利用流能做些什么呢？我们举一个例子</p>\n<p>假设我们有一个自然数循环列表，我们需要得到一个对每个值都运用函数后返回值构成的循环列表，那么我们该怎么做呢？</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">naturals</span> n)</span><br><span class=\"line\">  (<span class=\"name\">cons-stream</span> n (<span class=\"name\">naturals</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> n <span class=\"number\">1</span>))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> nat (<span class=\"name\">naturals</span> <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">map-stream</span> f s)</span><br><span class=\"line\">  (<span class=\"name\">cons-stream</span> (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> s)) (<span class=\"name\">map-stream</span> f (<span class=\"name\">cdr-stream</span> s))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> evens (<span class=\"name\">map-stream</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x <span class=\"number\">2</span>)) nat))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>首先，我们创建一个循环列表，并将其赋给变量<code>nat</code>，而后我们创建一个<code>map-stream</code>函数，引入循环列表和一个匿名函数作为参数，再将返回的列表赋给变量<code>even</code>由于cons-stream惰性求值的性质，我们在得到第一个值后并不会继续评估，因此<code>even</code>就变成了返回两倍自然数的循环列表，是不是很有趣呢？</p>\n<p>以上统统扯淡，看文档都能会，接下来进入正题。</p>\n<h3 id=\"抽象语言的解释器\"><a href=\"#抽象语言的解释器\" class=\"headerlink\" title=\"抽象语言的解释器\"></a>抽象语言的解释器</h3><h4 id=\"解释器的实现\"><a href=\"#解释器的实现\" class=\"headerlink\" title=\"解释器的实现\"></a>解释器的实现</h4><p>这是一个非常庞大的项目，CS61A利用Python构建了一个Scheme的解释器，也就是说，当完成这个解释器之后，我们就可以利用自己写的解释器进行scheme文档的解释与输出了，其实所有的编程语言本质都是解释器，你必须要采用合理的解释器将计算机无法理解的语言转换成计算机可以理解的语言，这样才能实现各种功能。</p>\n<p>整个解释器分为三个步骤，Read，Eval，Print，我们着重讲解前两个步骤。</p>\n<p>单个Read部分，这一步将用户的输入解析为解释器内部的一种抽象数据类型，我们在Python中构建了Pair这个类来将用户的输入从字符串转换成类的实例对象，以便于下一步对输入的整个表达式进行操作，主要有词法分析和句法分析两个步骤。</p>\n<p>Eval部分，这一步评估Scheme表达式以获得相应的值，我们知道，对于基础表达式例如 数字，布尔值，符号等来说，只需要对其进行评估后返回即可，而对于有操作符和操作数的调用表达式来说，我们要遵循调用表达式评估的顺序，忘记了？我们再来回顾一遍。</p>\n<blockquote>\n<p>1.评估操作符，应该评估为一个过程</p>\n<p>2.从左到右评估操作数</p>\n<p>3.操作数应用于过程</p>\n</blockquote>\n<p>操作符评估后，将会返回相应的过程，如果被求值的表达式是特殊形式，比如if,cond等等，将调用相应的函数进行操作，而后对操作数进行评估，注意，如果操作数也是调用表达式，那么依然要按顺序进行评估后返回。接下来就是将评估后的操作数应用于过程了，这里的过程有两种，一是内置过程，二是我们自己创建的Lambda过程，在后面我们会详细介绍如何分别实现这两种过程的应用。</p>\n<p>Print部分，这部分就不细讲了，就是使用str打印获得值即可。</p>\n<p>还有一个问题就是，我们需要让整个解释器循环起来，总不能每次输入一次表达式得出结果就终止了程序吧，所以我们需要一个逻辑循环函数。</p>\n<p>OK，从Read开始讲起。</p>\n<h4 id=\"Read部分\"><a href=\"#Read部分\" class=\"headerlink\" title=\"Read部分\"></a>Read部分</h4><h5 id=\"Pair类\"><a href=\"#Pair类\" class=\"headerlink\" title=\"Pair类\"></a>Pair类</h5><p>前面我们讲到，Read部分是将用户输入的字符串，通过词法分析和句法分析转换成某种抽象数据类型，以供后续的分析</p>\n<p>首先我们来定义一种能够接收并存储用户输入字符串的数据类型Pair</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A pair has two instance attributes: first and second. Second must be a Pair or nil</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = Pair(1, Pair(2, nil))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s</span></span><br><span class=\"line\"><span class=\"string\">    Pair(1, Pair(2, nil))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print(s)</span></span><br><span class=\"line\"><span class=\"string\">    (1 2)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print(s.map(lambda x: x+4))</span></span><br><span class=\"line\"><span class=\"string\">    (5 6)</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, first, second</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> scheme_builtins <span class=\"keyword\">import</span> scheme_valid_cdrp, SchemeError</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (second <span class=\"keyword\">is</span> nil <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(second, Pair) <span class=\"keyword\">or</span> <span class=\"built_in\">type</span>(second).__name__ == <span class=\"string\">&#x27;Promise&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&quot;cdr can only be a pair, nil, or a promise but was &#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(second))</span><br><span class=\"line\">        self.first = first</span><br><span class=\"line\">        self.second = second</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Pair(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">repr</span>(self.first), <span class=\"built_in\">repr</span>(self.second))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        s = <span class=\"string\">&#x27;(&#x27;</span> + repl_str(self.first)</span><br><span class=\"line\">        second = self.second</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">isinstance</span>(second, Pair):</span><br><span class=\"line\">            s += <span class=\"string\">&#x27; &#x27;</span> + repl_str(second.first)</span><br><span class=\"line\">            second = second.second</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            s += <span class=\"string\">&#x27; . &#x27;</span> + repl_str(second)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s + <span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__len__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        n, second = <span class=\"number\">1</span>, self.second</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">isinstance</span>(second, Pair):</span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">            second = second.second</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">&#x27;length attempted on improper list&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__eq__</span>(<span class=\"params\">self, p</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(p, Pair):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.first == p.first <span class=\"keyword\">and</span> self.second == p.second</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">map</span>(<span class=\"params\">self, fn</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return a Scheme list after mapping Python function FN to SELF.&quot;&quot;&quot;</span></span><br><span class=\"line\">        mapped = fn(self.first)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.second <span class=\"keyword\">is</span> nil <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(self.second, Pair):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Pair(mapped, self.second.<span class=\"built_in\">map</span>(fn))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">&#x27;ill-formed list (cdr is a promise)&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，Pair的结构非常像Link，其实本质也是一种迭代对象，只不过在link的基础上增加了一些内置方法，用于对Pair对象进行各种操作。</p>\n<h5 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h5><p>当用户输入一个字符串 </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (+ 1 2)</span><br></pre></td></tr></table></figure>\n\n<p>解释器首先要对其进行词法分析，在该项目中，我们使用tokenize_lines函数和Buffer类进行词法分析，最终返回一个Buffer对象src</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next_line = buffer_input</span><br><span class=\"line\"></span><br><span class=\"line\">src = next_line()</span><br></pre></td></tr></table></figure>\n\n<p>根据函数调用的顺序，涉及的函数调用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">获取字符串</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buffer_input</span>(<span class=\"params\">prompt=<span class=\"string\">&#x27;scm&gt; &#x27;</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return a Buffer instance containing interactive input.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Buffer(tokenize_lines(InputReader(prompt)))</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">#获取输入字符串，逐个字符传入tokenize_line函数执行    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tokenize_lines</span>(<span class=\"params\"><span class=\"built_in\">input</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An iterator over lists of tokens, one for each line of the iterable</span></span><br><span class=\"line\"><span class=\"string\">    input sequence.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (tokenize_line(line) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">input</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#获取tokenize_line函数执行返回结果构成的列表，并将其转为Buffer类的实例对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, source</span>):</span></span><br><span class=\"line\">        self.index = <span class=\"number\">0</span></span><br><span class=\"line\">        self.lines = []</span><br><span class=\"line\">        self.source = source</span><br><span class=\"line\">        self.current_line = ()</span><br><span class=\"line\">        self.current()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_front</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Remove the next item from self and return it. If self has</span></span><br><span class=\"line\"><span class=\"string\">        exhausted its source, returns None.&quot;&quot;&quot;</span></span><br><span class=\"line\">        current = self.current()</span><br><span class=\"line\">        self.index += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> current</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">current</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return the current element, or None if none exists.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.more_on_line:</span><br><span class=\"line\">            self.index = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                self.current_line = <span class=\"built_in\">next</span>(self.source)</span><br><span class=\"line\">                self.lines.append(self.current_line)</span><br><span class=\"line\">            <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">                self.current_line = ()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.current_line[self.index]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">more_on_line</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.index &lt; <span class=\"built_in\">len</span>(self.current_line)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return recently read contents; current element marked with &gt;&gt;.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># Format string for right-justified line numbers</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(self.lines)</span><br><span class=\"line\">        msg = <span class=\"string\">&#x27;&#123;0:&gt;&#x27;</span> + <span class=\"built_in\">str</span>(math.floor(math.log10(n))+<span class=\"number\">1</span>) + <span class=\"string\">&quot;&#125;: &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Up to three previous lines and current line are included in output</span></span><br><span class=\"line\">        s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, n-<span class=\"number\">4</span>), n-<span class=\"number\">1</span>):</span><br><span class=\"line\">            s += msg.<span class=\"built_in\">format</span>(i+<span class=\"number\">1</span>) + <span class=\"string\">&#x27; &#x27;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, self.lines[i])) + <span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">        s += msg.<span class=\"built_in\">format</span>(n)</span><br><span class=\"line\">        s += <span class=\"string\">&#x27; &#x27;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, self.current_line[:self.index]))</span><br><span class=\"line\">        s += <span class=\"string\">&#x27; &gt;&gt; &#x27;</span></span><br><span class=\"line\">        s += <span class=\"string\">&#x27; &#x27;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, self.current_line[self.index:]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.strip()</span><br></pre></td></tr></table></figure>\n\n<p>Buffer实例有两个核心方法remove_front和current，这两个方法可以对Buffer对象里的值进行有序输出。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; buf = Buffer(iter([[&#x27;(&#x27;, &#x27;+&#x27;], [15], [12, &#x27;)&#x27;]]))</span><br><span class=\"line\">&gt;&gt;&gt; buf.remove_front()</span><br><span class=\"line\">&#x27;(&#x27;</span><br><span class=\"line\">&gt;&gt;&gt; buf.remove_front()</span><br><span class=\"line\"><span class=\"symbol\">&#x27;+</span>&#x27;</span><br><span class=\"line\">&gt;&gt;&gt; buf.current()</span><br><span class=\"line\"><span class=\"number\">15</span></span><br><span class=\"line\">&gt;&gt;&gt; print(buf)</span><br><span class=\"line\"><span class=\"number\">1</span>: ( +</span><br><span class=\"line\"><span class=\"number\">2</span>:  &gt;&gt; <span class=\"number\">15</span></span><br><span class=\"line\">&gt;&gt;&gt; buf.remove_front()</span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>经过词法分析，用户输入的字符串被转换成了可有序输出的Buffer实例对象，就好像排列在内存中的数据一样，但是有一个问题就在于，对于这些存在实例对象中的数据，数据之间的相互关联并没有建立，就好像在游乐园等待入场的队列，虽然有序，但是相互之间毫无关联。</p>\n<p>因此我们要进行句法分析。</p>\n<h5 id=\"句法分析\"><a href=\"#句法分析\" class=\"headerlink\" title=\"句法分析\"></a>句法分析</h5><p>在该项目中，我们使用scheme_read进行句法分析，最终返回一个Pair对象expression</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expression = scheme_read(src)</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下scheme_read的逻辑流程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scheme_read</span>(<span class=\"params\">src</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Read the next expression from SRC, a Buffer of tokens.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;nil&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    nil</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;1&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;true&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;(+ 1 2)&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    Pair(&#x27;+&#x27;, Pair(1, Pair(2, nil)))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.current() <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> EOFError</span><br><span class=\"line\">    val = src.remove_front() <span class=\"comment\"># Get the first token</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> val == <span class=\"string\">&#x27;nil&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nil</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> val == <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> read_tail(src)</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> val <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 7</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Pair(quotes[val],Pair(scheme_read(src),nil))</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 7</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> val <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> DELIMITERS:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SyntaxError(<span class=\"string\">&#x27;unexpected token: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(val))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_tail</span>(<span class=\"params\">src</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the remainder of a list in SRC, starting before an element or ).</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;)&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    nil</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;2 3)&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    Pair(2, Pair(3, nil))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> src.current() <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SyntaxError(<span class=\"string\">&#x27;unexpected end of file&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> src.current() == <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">            <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">            src.remove_front()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nil</span><br><span class=\"line\">            <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Pair(scheme_read(src),read_tail(src))</span><br><span class=\"line\">            <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> EOFError:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SyntaxError(<span class=\"string\">&#x27;unexpected end of file&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">quotes = &#123;<span class=\"string\">&quot;&#x27;&quot;</span>:  <span class=\"string\">&#x27;quote&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;`&#x27;</span>:  <span class=\"string\">&#x27;quasiquote&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;,&#x27;</span>:  <span class=\"string\">&#x27;unquote&#x27;</span>&#125;</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，对于不同的结构，scheme_read有不同的方案去构造，主要可以分为三种，一种是普通的基础表达式，比如123，nil和布尔值，一种是调用表达式，scheme_read函数规定当遇到‘（’时会自动进入read_tail函数，最终返回一个完整的Pair结构，第三种就是符号，函数会判断这个符号是Quote，Quasiquote还是unquote，并将这三个模式传入以供后期评估使用。</p>\n<p>最终输入如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scheme_read(Buffer(tokenize_lines([<span class=\"string\">&#x27;(+ 1 2)&#x27;</span>])))</span><br><span class=\"line\">Pair(<span class=\"string\">&#x27;+&#x27;</span>, Pair(<span class=\"number\">1</span>, Pair(<span class=\"number\">2</span>, nil)))</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，经过句法分析，我们建立了字符之间的关联性，同属于一个调用表达式的字符被整合进 了独立的一个Pair实例，就好比，让在排队的人，夫妻合并成一组，家庭或朋友合并成一组，再进行排队。</p>\n<p>经过第一部分Read，我们拥有了具有关联性的Pair对象，在接下来的Eval部分中，我们将要对这个对象进行评估。</p>\n<h4 id=\"Eval-部分\"><a href=\"#Eval-部分\" class=\"headerlink\" title=\"Eval 部分\"></a>Eval 部分</h4><p>在整个评估过程中，有两个类发挥着重要作用，一个类是Frame，Frame类是一个环境框架，我们学习Python作用域的时候学习过，程序开始时候是在Global Frame下，当调用函数时候，会创建一个Frame，并且在该Frame下创建的变量和传入的参数是不能在Global Frame下被使用的，Scheme同样如此，所以我们创建了一个Frame类用于分离不同作用域。一个类是Procedure，Procedure类是过程类，他有两个子类，一个是BuiltinProcedure，即内置过程，比如我们使用的if，cons，cond都是内置过程，另一个是LambdaProcedure，即匿名过程，这是用来创建并绑定用户定义过程的。</p>\n<h5 id=\"Frame类\"><a href=\"#Frame类\" class=\"headerlink\" title=\"Frame类\"></a>Frame类</h5><p>EFrame类实现了环境框架，在对解释器进行初始化的时候，会调用create_global_frame创建一个Frame环境框架。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Frame</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An environment frame binds Scheme symbols to Scheme values.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, parent</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;An empty frame with parent frame PARENT (which may be None).&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.bindings = &#123;&#125;</span><br><span class=\"line\">        self.parent = parent</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.parent <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;Global Frame&gt;&#x27;</span></span><br><span class=\"line\">        s = <span class=\"built_in\">sorted</span>([<span class=\"string\">&#x27;&#123;0&#125;: &#123;1&#125;&#x27;</span>.<span class=\"built_in\">format</span>(k, v) <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.bindings.items()])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;&#123;&#123;&#123;0&#125;&#125;&#125; -&gt; &#123;1&#125;&gt;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;, &#x27;</span>.join(s), <span class=\"built_in\">repr</span>(self.parent))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">define</span>(<span class=\"params\">self, symbol, value</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Define Scheme SYMBOL to have VALUE.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 3</span></span><br><span class=\"line\">        self.bindings[symbol]=value</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lookup</span>(<span class=\"params\">self, symbol</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return the value bound to SYMBOL. Errors if SYMBOL is not found.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 3</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.bindings[symbol]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyError:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.parent <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.parent.lookup(symbol)</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 3</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;unknown identifier: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(symbol))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_child_frame</span>(<span class=\"params\">self, formals, vals</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return a new local frame whose parent is SELF, in which the symbols</span></span><br><span class=\"line\"><span class=\"string\">        in a Scheme list of formal parameters FORMALS are bound to the Scheme</span></span><br><span class=\"line\"><span class=\"string\">        values in the Scheme list VALS. Raise an error if too many or too few</span></span><br><span class=\"line\"><span class=\"string\">        vals are given.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; env = create_global_frame()</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; formals, expressions = read_line(&#x27;(a b c)&#x27;), read_line(&#x27;(1 2 3)&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; env.make_child_frame(formals, expressions)</span></span><br><span class=\"line\"><span class=\"string\">        &lt;&#123;a: 1, b: 2, c: 3&#125; -&gt; &lt;Global Frame&gt;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 11</span></span><br><span class=\"line\">        match_dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(formals)!=<span class=\"built_in\">len</span>(vals):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;The number of argument values does not match&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(formals)):</span><br><span class=\"line\">                match_dict[formals.first] = vals.first</span><br><span class=\"line\">                formals = formals.second</span><br><span class=\"line\">                vals = vals.second</span><br><span class=\"line\">        new_frame = Frame(self)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> match_dict.items():</span><br><span class=\"line\">            new_frame.define(key,value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_frame</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 11</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Frame框架类从外界引入一个父环境Frame实例，并维护一个binding列表，在初始化时候，会在初始Frame环境中调用define方法引入内置过程，在后面的过程中，如果需要引入用户过程，可以通过define引入，查找内置过程，可以通过lookup方法实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_global_frame</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Initialize and return a single-frame environment with built-in names.&quot;&quot;&quot;</span></span><br><span class=\"line\">    env = Frame(<span class=\"literal\">None</span>)</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;eval&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_eval, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;eval&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;apply&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(complete_apply, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;apply&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;load&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_load, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;load&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;procedure?&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_procedurep, <span class=\"literal\">False</span>, <span class=\"string\">&#x27;procedure?&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;map&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_map, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;map&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;filter&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_filter, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;filter&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;reduce&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_reduce, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;reduce&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;undefined&#x27;</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    add_builtins(env, BUILTINS)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env</span><br></pre></td></tr></table></figure>\n\n<p>当子环境创建需要引入一个Frame实例时，Frame可以调用make_child_frame创建一个子Frame并返回。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_call_frame</span>(<span class=\"params\">self,args,env</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> env.make_child_frame(self.formals, args)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Procedure类\"><a href=\"#Procedure类\" class=\"headerlink\" title=\"Procedure类\"></a>Procedure类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuiltinProcedure</span>(<span class=\"params\">Procedure</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A Scheme procedure defined as a Python function.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, fn, use_env=<span class=\"literal\">False</span>, name=<span class=\"string\">&#x27;builtin&#x27;</span></span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.fn = fn</span><br><span class=\"line\">        self.use_env = use_env</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#[&#123;0&#125;]&#x27;</span>.<span class=\"built_in\">format</span>(self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span>(<span class=\"params\">self, args, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Apply SELF to ARGS in ENV, where ARGS is a Scheme list.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; env = create_global_frame()</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; plus = env.bindings[&#x27;+&#x27;]</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; twos = Pair(2, Pair(2, nil))</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; plus.apply(twos, env)</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> scheme_listp(args):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;arguments are not in a list: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(args))</span><br><span class=\"line\">        <span class=\"comment\"># Convert a Scheme list to a Python list</span></span><br><span class=\"line\">        python_args = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> args <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            python_args.append(args.first)</span><br><span class=\"line\">            args = args.second</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 4</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.use_env:</span><br><span class=\"line\">            python_args.append(env)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.fn(*python_args)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> TypeError:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&quot;Invalid number of arguments to &#123;0&#125;&quot;</span>.<span class=\"built_in\">format</span>(self.name))</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaProcedure</span>(<span class=\"params\">Procedure</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A procedure defined by a lambda expression or a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, formals, body, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;A procedure with formal parameter list FORMALS (a Scheme list),</span></span><br><span class=\"line\"><span class=\"string\">        whose body is the Scheme list BODY, and whose parent environment</span></span><br><span class=\"line\"><span class=\"string\">        starts with Frame ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.formals = formals</span><br><span class=\"line\">        self.body = body</span><br><span class=\"line\">        self.env = env</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_call_frame</span>(<span class=\"params\">self, args, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Make a frame that binds my formal parameters to ARGS, a Scheme list</span></span><br><span class=\"line\"><span class=\"string\">        of values, for a lexically-scoped call evaluated in environment ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 12</span></span><br><span class=\"line\">        new_frame = self.env.make_child_frame(self.formals,args)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_frame</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 12</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">str</span>(Pair(<span class=\"string\">&#x27;lambda&#x27;</span>, Pair(self.formals, self.body)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;LambdaProcedure(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(</span><br><span class=\"line\">            <span class=\"built_in\">repr</span>(self.formals), <span class=\"built_in\">repr</span>(self.body), <span class=\"built_in\">repr</span>(self.env))</span><br></pre></td></tr></table></figure>\n\n<p>内置过程表示为BuiltinProcedure实例，BuiltinProcedure具有两个实例属性，fn是实施内置方案程序的Python功能，use_env是一个布尔标志，指示这个内置程序是否会期望当前环境作为最后一个参数传递。例如，需要环境来实施内置eval程序。</p>\n<p>用户定义的程序表示为LambdaProcedure实例。LambdaProcedure具有三个实例属性，formals是命名程序参数的正式参数（符号）的方案列表。body是一个方案列表的表达式，程序的主体。<br>env是定义程序的Frame环境。</p>\n<h5 id=\"评估仅内置过程的表达式\"><a href=\"#评估仅内置过程的表达式\" class=\"headerlink\" title=\"评估仅内置过程的表达式\"></a>评估仅内置过程的表达式</h5><p>当我们评估只有内置过程的表达式的时候，我们会进行这个过程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> scheme_symbolp(first) <span class=\"keyword\">and</span> first <span class=\"keyword\">in</span> SPECIAL_FORMS:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SPECIAL_FORMS[first](rest, env)</span><br></pre></td></tr></table></figure>\n\n<p>这里的SPECIAL_FORMS就是内置过程的列表，我们通过first变量传入操作符名称，当我们发现评估的操作符是个内置过程的时候，我们就会调用这段代码找到对应调用内置过程的函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPECIAL_FORMS = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;and&#x27;</span>: do_and_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;begin&#x27;</span>: do_begin_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;cond&#x27;</span>: do_cond_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;define&#x27;</span>: do_define_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;if&#x27;</span>: do_if_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;lambda&#x27;</span>: do_lambda_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;let&#x27;</span>: do_let_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;or&#x27;</span>: do_or_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;quote&#x27;</span>: do_quote_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;define-macro&#x27;</span>: do_define_macro,</span><br><span class=\"line\">    <span class=\"string\">&#x27;quasiquote&#x27;</span>: do_quasiquote_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;unquote&#x27;</span>: do_unquote,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们以评估define内置过程为例来讲解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_define_form</span>(<span class=\"params\">expressions, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Evaluate a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\">    check_form(expressions, <span class=\"number\">2</span>)</span><br><span class=\"line\">    target = expressions.first</span><br><span class=\"line\">    <span class=\"keyword\">if</span> scheme_symbolp(target):</span><br><span class=\"line\">        check_form(expressions, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 6</span></span><br><span class=\"line\">        value = scheme_eval(expressions.second.first,env)</span><br><span class=\"line\">        env.define(target,value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 6</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        bad_target = target.first <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(target, Pair) <span class=\"keyword\">else</span> target</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;non-symbol: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(bad_target))</span><br></pre></td></tr></table></figure>\n\n<p>do_define_form函数引入了两个参数，根据调用函数可知，传入的expression参数是调用表达式的操作数部分，因此就把操作数评估后的结果在全局环境下与设定的变量绑定了，其关键代码为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env.define(target,value)</span><br></pre></td></tr></table></figure>\n\n<p>这就是实现一个内置过程的办法，接下来我们来看看该如何实现用户定义函数。</p>\n<h5 id=\"评估带有用户定义的表达式\"><a href=\"#评估带有用户定义的表达式\" class=\"headerlink\" title=\"评估带有用户定义的表达式\"></a>评估带有用户定义的表达式</h5><p>我们先来看看如何使用内置过程<code>define</code>定义一个用户过程。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_define_form</span>(<span class=\"params\">expressions, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Evaluate a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\">    check_form(expressions, <span class=\"number\">2</span>)</span><br><span class=\"line\">    target = expressions.first</span><br><span class=\"line\">    <span class=\"keyword\">if</span> scheme_symbolp(target):</span><br><span class=\"line\">        check_form(expressions, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 6</span></span><br><span class=\"line\">        value = scheme_eval(expressions.second.first,env)</span><br><span class=\"line\">        env.define(target,value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 6</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(target, Pair) <span class=\"keyword\">and</span> scheme_symbolp(target.first):</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 10</span></span><br><span class=\"line\">        name = target.first</span><br><span class=\"line\">        formal = target.second</span><br><span class=\"line\">        body = expressions.second</span><br><span class=\"line\">        process = LambdaProcedure(formal,body,env)</span><br><span class=\"line\">        env.define(name,process)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 10</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        bad_target = target.first <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(target, Pair) <span class=\"keyword\">else</span> target</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;non-symbol: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(bad_target))</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这个define函数比之前仅能定义变量的函数多了elif的部分，在这个过程中，函数首先将整个定义代码段分成name函数名称，formal函数参数，和body函数主体三个部分，而后将这三个部分放入LambdaProcedure类创建一个实例，最后调用Frame的define过程将新定义的过程实例与过程名绑定，以便后期lookup函数的查找。</p>\n<p>我们来看看创建新过程的实例时候，发生了什么。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaProcedure</span>(<span class=\"params\">Procedure</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A procedure defined by a lambda expression or a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, formals, body, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;A procedure with formal parameter list FORMALS (a Scheme list),</span></span><br><span class=\"line\"><span class=\"string\">        whose body is the Scheme list BODY, and whose parent environment</span></span><br><span class=\"line\"><span class=\"string\">        starts with Frame ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.formals = formals</span><br><span class=\"line\">        self.body = body</span><br><span class=\"line\">        self.env = env</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_call_frame</span>(<span class=\"params\">self, args, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Make a frame that binds my formal parameters to ARGS, a Scheme list</span></span><br><span class=\"line\"><span class=\"string\">        of values, for a lexically-scoped call evaluated in environment ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 12</span></span><br><span class=\"line\">        new_frame = self.env.make_child_frame(self.formals,args)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_frame</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 12</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">str</span>(Pair(<span class=\"string\">&#x27;lambda&#x27;</span>, Pair(self.formals, self.body)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;LambdaProcedure(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(</span><br><span class=\"line\">            <span class=\"built_in\">repr</span>(self.formals), <span class=\"built_in\">repr</span>(self.body), <span class=\"built_in\">repr</span>(self.env))</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，lambda维护着一个方法，当调用到用户实例的时候，就会调用这个方法，打开一个新Frame进行运算。</p>\n<p>最后对调用表达式执行apply操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scheme_apply</span>(<span class=\"params\">procedure, args, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in</span></span><br><span class=\"line\"><span class=\"string\">    environment ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">    check_procedure(procedure)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(procedure, BuiltinProcedure):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> procedure.apply(args, env)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        new_env = procedure.make_call_frame(args, env)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> eval_all(procedure.body, new_env)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eval_all</span>(<span class=\"params\">expressions, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Evaluate each expression in the Scheme list EXPRESSIONS in</span></span><br><span class=\"line\"><span class=\"string\">    environment ENV and return the value of the last.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># BEGIN PROBLEM 8</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> expressions == nil:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        value = expressions.<span class=\"built_in\">map</span>((<span class=\"keyword\">lambda</span> x:scheme_eval(x,env)))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> value <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            now = value.first</span><br><span class=\"line\">            value = value.second</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now</span><br></pre></td></tr></table></figure>\n\n<p>至此，整个解释器就写完了，再加上内置的自循环函数，一个可以运行Scheme程序的python解释器就大功告成了。在61A 的Scheme项目中，还有如宏和流这种复杂的过程，大家可以自行学习，不过本质还是和内置过程的评估相差不大。学习这个项目的目的不是真的要完成一个解释器，而是要让你学会和理解解释器是如何”翻译“一种语言的，这样你才能更好的去理解各种编程范式，例如函数式编程，面向对象编程.</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":23462,"excerpt":"","more":"<h2 id=\"CS61A-元语言抽象\"><a href=\"#CS61A-元语言抽象\" class=\"headerlink\" title=\"CS61A 元语言抽象\"></a>CS61A 元语言抽象</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>Scheme语言</p>\n<ul>\n<li>表达式</li>\n<li>控制结构与列表</li>\n<li>定义变量与函数</li>\n<li>匿名过程</li>\n</ul>\n<p>Scheme语言特性</p>\n<ul>\n<li>宏</li>\n<li>流</li>\n</ul>\n<p>抽象语言的解释器</p>\n<ul>\n<li>解释器的实现</li>\n<li>读取过程</li>\n<li>评估过程</li>\n<li>输出过程</li>\n</ul>\n</blockquote>\n<p>在之前的章节中，我们都是基于一门语言去研究程序的抽象形式，而本 书的最后一个部分直接跳出了语言，讲解一门语言是怎么样抽象的，也就是说，这一章，是在教你如何实现一门语言，我们这里所说的语言是脚本语言，接下来，我们就要以Scheme语言为例，讲解Scheme语言是怎么样一步一步构造出来的。</p>\n<h3 id=\"Scheme语言\"><a href=\"#Scheme语言\" class=\"headerlink\" title=\"Scheme语言\"></a>Scheme语言</h3><p>首先我们从使用者的角度了解一下Scheme的语法。</p>\n<h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><p>最基础的表达式可以是数字，布尔值或者符号，这里的符号是我们在Python语言中唯一没有遇到的类型，具体来说，Scheme中的符号也是一种值。</p>\n<h5 id=\"原子表达式\"><a href=\"#原子表达式\" class=\"headerlink\" title=\"原子表达式\"></a>原子表达式</h5><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; 1234    ; integer</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br><span class=\"line\">scm&gt; 123.4   ; real number</span><br><span class=\"line\"><span class=\"number\">123.4</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h5><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; #t</span><br><span class=\"line\">#t</span><br><span class=\"line\">scm&gt; #f</span><br><span class=\"line\">#f</span><br></pre></td></tr></table></figure>\n\n<p>在 Scheme 中，除了特殊的布尔值#f之外的所有值都被解释为真值（与 Python 不同，Python 中有一些像0那样的假值）</p>\n<h5 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"符号\"></a>符号</h5><p>其中，符号类型是我们在 Python 中唯一没有遇到的类型。一个 符号的作用很像一个Python的名字，但不完全是。具体来说，Scheme 中的符号也是一种值。在 Python 中，名称仅用作表达式；Python 表达式永远不能计算为名称。</p>\n<p>这个过程具体是怎么实现的，我们后面再讲。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; quotient      ; A name bound to a built-in procedure</span><br><span class=\"line\">#[quotient]</span><br><span class=\"line\">scm&gt; &#x27;quotient     ; An expression that evaluates to a symbol</span><br><span class=\"line\">quotient</span><br><span class=\"line\">scm&gt; &#x27;hello-world!</span><br><span class=\"line\">hello-world!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调用表达式\"><a href=\"#调用表达式\" class=\"headerlink\" title=\"调用表达式\"></a>调用表达式</h4><p>与 Python 一样，Scheme 调用表达式中的运算符位于所有操作数之前。与 Python 不同的是，运算符包含在括号内，并且操作数由空格而不是逗号分隔。然而，Scheme 调用表达式的计算遵循与 Python 完全相同的规则：</p>\n<p>1.评估操作符，应该评估为一个过程</p>\n<p>2.从左到右评估操作数</p>\n<p>3.操作数应用于过程</p>\n<p>以下是一些使用内置过程的示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (+ 1 2)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">scm&gt; (- 10 (/ 6 2))</span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\">scm&gt; (modulo 35 4)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">scm&gt; (even? (quotient 45 2))</span><br><span class=\"line\">#t</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"控制结构与列表\"><a href=\"#控制结构与列表\" class=\"headerlink\" title=\"控制结构与列表\"></a>控制结构与列表</h4><h5 id=\"if表达式\"><a href=\"#if表达式\" class=\"headerlink\" title=\"if表达式\"></a>if表达式</h5><p>该if特殊形式使我们能够评估基于谓词两个表达式之一。它接受两个必需的参数和一个可选的第三个参数：</p>\n<blockquote>\n<p>(if <predicate> <if-true> [if-false])</p>\n</blockquote>\n<p>第一个操作数是Scheme 中所谓的谓词表达式，该表达式的值被解释为#tor 或#f。</p>\n<p>计算if特殊形式表达式的规则如下：</p>\n<p>1.评估<predicate>。<br>2.如果<predicate>评估为真值，则评估并返回该值，如果表达式<if-true>. 否则，[if-false]如果提供，则评估并返回值 。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (if (&gt; x 3)</span><br><span class=\"line\">         <span class=\"number\">1</span></span><br><span class=\"line\">         2)</span><br></pre></td></tr></table></figure>\n\n<p>在 Scheme 中，您不能编写elif案例。如果要使用if表达式有多个案例，则需要多个分支if表达式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (if (&lt; x 0)</span><br><span class=\"line\">         <span class=\"symbol\">&#x27;negative</span></span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">             <span class=\"symbol\">&#x27;zero</span></span><br><span class=\"line\">             <span class=\"symbol\">&#x27;positive</span></span><br><span class=\"line\">         )</span><br><span class=\"line\"> )</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"cond表达式\"><a href=\"#cond表达式\" class=\"headerlink\" title=\"cond表达式\"></a>cond表达式</h5><p>使用嵌套if表达式似乎不是处理多种情况的非常实用的方法。相反，我们可以使用cond特殊形式，一种类似于 Python 中的多子句 if/elif/else 条件表达式的通用条件表达式。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    (<span class=\"name\">&lt;p1&gt;</span> &lt;e1&gt;)</span><br><span class=\"line\">    (<span class=\"name\">&lt;p2&gt;</span> &lt;e2&gt;)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    (<span class=\"name\">&lt;pn&gt;</span> &lt;en&gt;)</span><br><span class=\"line\">    [(<span class=\"name\"><span class=\"builtin-name\">else</span></span> &lt;else-expression&gt;)])</span><br></pre></td></tr></table></figure>\n\n<p>评价规则如下：</p>\n<p>1.对谓词<p1>, <p2>, …,<pn>进行求值，直到达到求值为真 y 值的谓词为止。<br>2.如果您到达一个计算结果为真值的谓词，请计算并返回子句中的相应表达式。<br>3.如果没有一个谓词是真y并且有一个else子句，则评估并返回<else-expression>。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cond</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> x <span class=\"number\">0</span>) <span class=\"symbol\">&#x27;positive</span>)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>) <span class=\"symbol\">&#x27;negative</span>)</span><br><span class=\"line\">        (else &#x27;zero))</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h5><h6 id=\"cons\"><a href=\"#cons\" class=\"headerlink\" title=\"cons\"></a>cons</h6><p>Scheme 列表与我们在 Python 中使用的链表非常相似。就像链表是由一系列Link 对象构建的一样，Scheme 列表是由一系列对构建的，这些对是由构造函数创建的cons，是一种可递归对象。</p>\n<p>Scheme列表要cdr是另一个列表或nil空列表。列表在解释器中显示为值序列（类似于对象的 __str__表示Link）。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cons 1 (cons 2 (cons 3 nil)))</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>具体的实现方式用图像来表示就是</p>\n<p><img src=\"https://i.loli.net/2021/08/10/Le2kpYIwaAgWN8E.png\" alt=\"image-20210810094539083\"></p>\n<p>我们可以使用car和cdr从我们的列表中检索值，现在它的工作方式类似于 PythonLink的first和rest属性。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a</span><br><span class=\"line\">scm&gt; a</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (car a)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">scm&gt; (cdr a)</span><br><span class=\"line\">(<span class=\"name\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (car (cdr (cdr a)))</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>如果您没有将 pair 或 nil 作为第二个参数传递给cons，则会出错：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cons 1 2)</span><br><span class=\"line\">Error</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h6><p>另一种创建列表的方式是利用list，该list过程接受任意数量的参数并使用这些参数的值构造一个列表</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (list 1 2 3)</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; (list 1 (list 2 3) 4)</span><br><span class=\"line\">(<span class=\"name\">1</span> (<span class=\"name\">2</span> <span class=\"number\">3</span>) <span class=\"number\">4</span>)</span><br><span class=\"line\">scm&gt; (list (cons 1 (cons 2 nil)) 3 4)</span><br><span class=\"line\">((<span class=\"name\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>请注意，此表达式中的所有操作数在放入结果列表之前都会进行评估。</p>\n<h6 id=\"Quote\"><a href=\"#Quote\" class=\"headerlink\" title=\"Quote\"></a>Quote</h6><p>我们还可以使用引用形式来创建一个列表，通过引用形式创建的列表不进评估</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; &#x27;(1 2 3)</span><br><span class=\"line\">(<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">scm&gt; &#x27;(cons 1 2)           ; Argument to quote is not evaluated</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">scm&gt; &#x27;(1 (2 3 4))</span><br><span class=\"line\">(<span class=\"name\">1</span> (<span class=\"name\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义变量与函数\"><a href=\"#定义变量与函数\" class=\"headerlink\" title=\"定义变量与函数\"></a>定义变量与函数</h4><p>在Python中定义变量使用=号进行，而定义变量使用def进行，而在Scheme中定义变量和过程都使用define语法，这个在后期解释器的构造中我也会着重细讲。</p>\n<p>定义变量，我们使用语法</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> &lt;name&gt; &lt;expression&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>评估这个表达式的规则是</p>\n<p>1.评估<expression>.<br>2.将其值绑定到<name>当前Frame中。<br>3.返回<name>。</p>\n<p>定义过程，我们使用语法</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">&lt;name&gt;</span> &lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt; )</span><br></pre></td></tr></table></figure>\n\n<p>要评估此表达式：</p>\n<p>1.使用给定的参数和 来创建一个 lambda 过程<body>。<br>2.将过程绑定到<name>当前帧中的 。<br>3.返回<name>。</p>\n<p>以下两个表达式是等价的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define foo (lambda (x y) (+ x y)))</span><br><span class=\"line\">foo</span><br><span class=\"line\">scm&gt; (define (foo x y) (+ x y))</span><br><span class=\"line\">foo</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"匿名过程\"><a href=\"#匿名过程\" class=\"headerlink\" title=\"匿名过程\"></a>匿名过程</h4><p>所有 Scheme 过程都是 lambda 过程。要创建 lambda 过程，我们可以使用lambda特殊形式</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (&lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn&#x27;t assign it to a name</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y))</span><br><span class=\"line\">scm&gt; ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>一个过程可以接受任意数量的参数。该<body>可以包含多个表达式。return Scheme 中没有 Python语句的等效版本。该函数将简单地返回正文中最后一个表达式的值。</p>\n<h3 id=\"Scheme语言特性\"><a href=\"#Scheme语言特性\" class=\"headerlink\" title=\"Scheme语言特性\"></a>Scheme语言特性</h3><h4 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h4><h5 id=\"Define-macro\"><a href=\"#Define-macro\" class=\"headerlink\" title=\"Define-macro\"></a>Define-macro</h5><p>宏是一个不好理解的概念，但是却是一个非常重要的概念，我们刚才已经介绍了define的用法，下面我们使用define来定义一个过程</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> twice(<span class=\"name\">f</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> f f))</span><br></pre></td></tr></table></figure>\n\n<p>当我们输入<code>（twice （print &#39;woof））</code>我们希望能输出两次woof，然而</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (twice (print &#x27;woof))</span><br><span class=\"line\">woof</span><br></pre></td></tr></table></figure>\n\n<p>这是怎么回事呢？</p>\n<p>我们一步一步来，首先我们对操作符twice进行评估，返回我们定义的twice过程，而后我们对<code>(print &#39;woof)</code>进行评估，打印woof，而后将返回的undefined值绑定到f，而后将操作数字应用于操作符，得到表达式<code>（begin undefined undefined）</code>对该表达式进行评估，无返回值</p>\n<p>那么我们该怎么样修改才能得到正确输出呢？</p>\n<p>我们想要最终评估的表达式是这样的，<code>begin （print &#39;woof）(print &#39;woof)</code> ，因此，我们想到一种办法</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">twice</span> f)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">eval</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;begin</span> f f))</span><br></pre></td></tr></table></figure>\n\n<p>为了保证最终评估的表达式是<code>begin （print &#39;woof）(print &#39;woof)</code> ，我们稍微改变了一下输入的值</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (twice &#x27;(print &#x27;woof))</span><br><span class=\"line\">woof</span><br><span class=\"line\">woof</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就通过eval list返回的列表，完成了正确输出。</p>\n<p>但是肯定有人会想，为什么要这么麻烦，在进入函数的时候用‘防止被eval，结果在出来的时候又得加个eval，那索性就直接让操作数不评估不就行了。</p>\n<p>诶，没错，这个问题，前人已经考虑到了，而且他们还设计了一种语法来解决这个问题，这种语法被叫做macro，宏。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (define-macro (twice f) (list &#x27;begin f f))</span><br><span class=\"line\">twice</span><br><span class=\"line\">scm&gt; (twice (print &#x27;woof))</span><br><span class=\"line\">woof</span><br><span class=\"line\">woof</span><br></pre></td></tr></table></figure>\n\n<p>define-macro允许我们定义macro，这是我们将未计算的输入表达式组合到另一个表达式中的一种方式。当我们调用宏时，操作数不会被评估，而是被视为 Scheme 数据。这意味着任何作为调用表达式或特殊形式表达式的操作数都被视为列表。</p>\n<p>在我们的例子中，我们需要一个如下所示的begin 表达式</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\">print</span> <span class=\"symbol\">&#x27;woof</span>) (<span class=\"name\">print</span> <span class=\"symbol\">&#x27;woof</span>))</span><br></pre></td></tr></table></figure>\n\n<p>作为 Scheme 数据，这个表达式实际上只是一个包含三个元素的列表：begin和(print ‘woof)两次，这正是(list ‘begin f f)返回的内容。现在，当我们调用 时twice，这个列表被评估为一个表达式并被(print ‘woof)评估两次。</p>\n<p>回顾一下，宏的调用方式与常规过程类似，但评估它们的规则不同。我们通过以下方式评估了 lambda 过程：</p>\n<blockquote>\n<p>1.评估运算符<br>2.评估操作数<br>3.将运算符应用于操作数，评估过程的主体</p>\n</blockquote>\n<p>但是，评估对宏过程调用的规则是：</p>\n<blockquote>\n<p>1.评估运算符<br>2.将运算符应用于未计算的操作数<br>3.评估宏在调用它的框架中返回的表达式。</p>\n</blockquote>\n<p>这种特性使得scheme语言具有很强的扩展性，可以随意设计各种不同的语法来进行运算，举个例子，如果我们想把Scheme的定义语法用Python的风格写出来，该怎么做呢？</p>\n<p>这时候我们就可以利用宏来实现。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">def</span> func bindings body)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">&#x27;define</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> func bindings) body))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&lt; (def f(x y) (+ x y))</span><br><span class=\"line\">f</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以使用具有Python风格的语法来定义scheme函数了。</p>\n<h5 id=\"Quasiquote\"><a href=\"#Quasiquote\" class=\"headerlink\" title=\"Quasiquote\"></a>Quasiquote</h5><p>回想一下，quote特殊形式会阻止 Scheme 解释器执行表达式,如果我们试图构建具有许多嵌套列表的复杂 Scheme 表达式，这种形式似乎会派上用场。</p>\n<p>考虑我们将twice宏重写如下</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">twice</span> f)</span><br><span class=\"line\">  &#x27;(begin f f))</span><br></pre></td></tr></table></figure>\n\n<p>这似乎会产生相同的效果，但由于quote 表单阻止了任何评估，我们创建的结果表达式实际上是<code>(begin f f)</code>，这不是我们想要的。</p>\n<p>乍一看，quasiquote（可以用反引号`或quasiquote特殊形式调用）与quote的行为完全相同。但是，使用quasiquote可以使用逗号，从引用的上下文中删除一个表达式，对其进行评估，然后将其放回原处。</p>\n<p>下面是我们如何使用 quasiquote 来重写我们之前的示例：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">twice</span> f)</span><br><span class=\"line\">  `(begin ,f ,f))</span><br></pre></td></tr></table></figure>\n\n<p>同样我们重写def实例：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">define-macro</span> (<span class=\"name\">def</span> func bindings body)</span><br><span class=\"line\">    `(define ,(cons func bindings) ,body))</span><br></pre></td></tr></table></figure>\n\n<p>其执行结果不变。</p>\n<h4 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h4><p>在Python当中，我们使用迭代器和生成器来实现惰性求值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ints</span>(<span class=\"params\">first</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> first</span><br><span class=\"line\">        first += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = ints(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(s)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(s)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>然而，在Scheme语言中，没有迭代器和生成器，让我们看看如果我们使用scheme列表来进行循环迭代求值会产生什么情况。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">ints</span> first)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> first (<span class=\"name\">ints</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> first <span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (ints 1)</span><br><span class=\"line\">maximum recursion depth exceeded</span><br></pre></td></tr></table></figure>\n\n<p>由于cons是一个连续求值的过程，在cons结构建立之前，需要对所有值进行逐个评估，因此我们不能用cons创建一个无限循环的列表，然而，scheme解释器引入了流，流是一个特殊的scheme列表，在进行评估时，第一个值会进行评估，而第二个值会被保留，直到我们需要进行评估时才执行，在程序编写范式中，这种模式被称作惰性求值。</p>\n<p>我们使用以下语法结构创建一个流</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">cons-stream</span> &lt;operand1&gt; &lt;operand2&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>我们以自然数无限循环列表为例讲解流的操作</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">ints</span> first)</span><br><span class=\"line\">    (<span class=\"name\">cons-stream</span> first</span><br><span class=\"line\">                 (<span class=\"name\">ints</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> first <span class=\"number\">1</span>)))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (ints 1)</span><br><span class=\"line\">(<span class=\"name\">1</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)])</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，流在进行评估的时候，只会评估第一个值，而保留第二个值，而后返回一个列表。</p>\n<p>我们首先将循环列表返回的值赋给一个变量a</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt;(define a (int 1))</span><br></pre></td></tr></table></figure>\n\n<p>而后我们对列表进行操作，如果我们仅使用cdr</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cdr (int 1))</span><br><span class=\"line\">#[promise (not forced)]</span><br></pre></td></tr></table></figure>\n\n<p>我们发现依然没有评估，因为我们需要使用cdr-stream，才能让列表第二个值评估后返回。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (cdr-stream a)</span><br><span class=\"line\">(<span class=\"name\">2</span> . #[<span class=\"name\">promise</span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> forced)])</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就能得到第二个值评估后的结果。</p>\n<p>利用流能做些什么呢？我们举一个例子</p>\n<p>假设我们有一个自然数循环列表，我们需要得到一个对每个值都运用函数后返回值构成的循环列表，那么我们该怎么做呢？</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">naturals</span> n)</span><br><span class=\"line\">  (<span class=\"name\">cons-stream</span> n (<span class=\"name\">naturals</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> n <span class=\"number\">1</span>))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> nat (<span class=\"name\">naturals</span> <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">map-stream</span> f s)</span><br><span class=\"line\">  (<span class=\"name\">cons-stream</span> (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> s)) (<span class=\"name\">map-stream</span> f (<span class=\"name\">cdr-stream</span> s))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> evens (<span class=\"name\">map-stream</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x <span class=\"number\">2</span>)) nat))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>首先，我们创建一个循环列表，并将其赋给变量<code>nat</code>，而后我们创建一个<code>map-stream</code>函数，引入循环列表和一个匿名函数作为参数，再将返回的列表赋给变量<code>even</code>由于cons-stream惰性求值的性质，我们在得到第一个值后并不会继续评估，因此<code>even</code>就变成了返回两倍自然数的循环列表，是不是很有趣呢？</p>\n<p>以上统统扯淡，看文档都能会，接下来进入正题。</p>\n<h3 id=\"抽象语言的解释器\"><a href=\"#抽象语言的解释器\" class=\"headerlink\" title=\"抽象语言的解释器\"></a>抽象语言的解释器</h3><h4 id=\"解释器的实现\"><a href=\"#解释器的实现\" class=\"headerlink\" title=\"解释器的实现\"></a>解释器的实现</h4><p>这是一个非常庞大的项目，CS61A利用Python构建了一个Scheme的解释器，也就是说，当完成这个解释器之后，我们就可以利用自己写的解释器进行scheme文档的解释与输出了，其实所有的编程语言本质都是解释器，你必须要采用合理的解释器将计算机无法理解的语言转换成计算机可以理解的语言，这样才能实现各种功能。</p>\n<p>整个解释器分为三个步骤，Read，Eval，Print，我们着重讲解前两个步骤。</p>\n<p>单个Read部分，这一步将用户的输入解析为解释器内部的一种抽象数据类型，我们在Python中构建了Pair这个类来将用户的输入从字符串转换成类的实例对象，以便于下一步对输入的整个表达式进行操作，主要有词法分析和句法分析两个步骤。</p>\n<p>Eval部分，这一步评估Scheme表达式以获得相应的值，我们知道，对于基础表达式例如 数字，布尔值，符号等来说，只需要对其进行评估后返回即可，而对于有操作符和操作数的调用表达式来说，我们要遵循调用表达式评估的顺序，忘记了？我们再来回顾一遍。</p>\n<blockquote>\n<p>1.评估操作符，应该评估为一个过程</p>\n<p>2.从左到右评估操作数</p>\n<p>3.操作数应用于过程</p>\n</blockquote>\n<p>操作符评估后，将会返回相应的过程，如果被求值的表达式是特殊形式，比如if,cond等等，将调用相应的函数进行操作，而后对操作数进行评估，注意，如果操作数也是调用表达式，那么依然要按顺序进行评估后返回。接下来就是将评估后的操作数应用于过程了，这里的过程有两种，一是内置过程，二是我们自己创建的Lambda过程，在后面我们会详细介绍如何分别实现这两种过程的应用。</p>\n<p>Print部分，这部分就不细讲了，就是使用str打印获得值即可。</p>\n<p>还有一个问题就是，我们需要让整个解释器循环起来，总不能每次输入一次表达式得出结果就终止了程序吧，所以我们需要一个逻辑循环函数。</p>\n<p>OK，从Read开始讲起。</p>\n<h4 id=\"Read部分\"><a href=\"#Read部分\" class=\"headerlink\" title=\"Read部分\"></a>Read部分</h4><h5 id=\"Pair类\"><a href=\"#Pair类\" class=\"headerlink\" title=\"Pair类\"></a>Pair类</h5><p>前面我们讲到，Read部分是将用户输入的字符串，通过词法分析和句法分析转换成某种抽象数据类型，以供后续的分析</p>\n<p>首先我们来定义一种能够接收并存储用户输入字符串的数据类型Pair</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A pair has two instance attributes: first and second. Second must be a Pair or nil</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = Pair(1, Pair(2, nil))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s</span></span><br><span class=\"line\"><span class=\"string\">    Pair(1, Pair(2, nil))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print(s)</span></span><br><span class=\"line\"><span class=\"string\">    (1 2)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print(s.map(lambda x: x+4))</span></span><br><span class=\"line\"><span class=\"string\">    (5 6)</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, first, second</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">from</span> scheme_builtins <span class=\"keyword\">import</span> scheme_valid_cdrp, SchemeError</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (second <span class=\"keyword\">is</span> nil <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(second, Pair) <span class=\"keyword\">or</span> <span class=\"built_in\">type</span>(second).__name__ == <span class=\"string\">&#x27;Promise&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&quot;cdr can only be a pair, nil, or a promise but was &#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(second))</span><br><span class=\"line\">        self.first = first</span><br><span class=\"line\">        self.second = second</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Pair(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">repr</span>(self.first), <span class=\"built_in\">repr</span>(self.second))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        s = <span class=\"string\">&#x27;(&#x27;</span> + repl_str(self.first)</span><br><span class=\"line\">        second = self.second</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">isinstance</span>(second, Pair):</span><br><span class=\"line\">            s += <span class=\"string\">&#x27; &#x27;</span> + repl_str(second.first)</span><br><span class=\"line\">            second = second.second</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            s += <span class=\"string\">&#x27; . &#x27;</span> + repl_str(second)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s + <span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__len__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        n, second = <span class=\"number\">1</span>, self.second</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">isinstance</span>(second, Pair):</span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">            second = second.second</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">&#x27;length attempted on improper list&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__eq__</span>(<span class=\"params\">self, p</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(p, Pair):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.first == p.first <span class=\"keyword\">and</span> self.second == p.second</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">map</span>(<span class=\"params\">self, fn</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return a Scheme list after mapping Python function FN to SELF.&quot;&quot;&quot;</span></span><br><span class=\"line\">        mapped = fn(self.first)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.second <span class=\"keyword\">is</span> nil <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(self.second, Pair):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Pair(mapped, self.second.<span class=\"built_in\">map</span>(fn))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">&#x27;ill-formed list (cdr is a promise)&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，Pair的结构非常像Link，其实本质也是一种迭代对象，只不过在link的基础上增加了一些内置方法，用于对Pair对象进行各种操作。</p>\n<h5 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h5><p>当用户输入一个字符串 </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scm&gt; (+ 1 2)</span><br></pre></td></tr></table></figure>\n\n<p>解释器首先要对其进行词法分析，在该项目中，我们使用tokenize_lines函数和Buffer类进行词法分析，最终返回一个Buffer对象src</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next_line = buffer_input</span><br><span class=\"line\"></span><br><span class=\"line\">src = next_line()</span><br></pre></td></tr></table></figure>\n\n<p>根据函数调用的顺序，涉及的函数调用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">获取字符串</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buffer_input</span>(<span class=\"params\">prompt=<span class=\"string\">&#x27;scm&gt; &#x27;</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return a Buffer instance containing interactive input.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Buffer(tokenize_lines(InputReader(prompt)))</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">#获取输入字符串，逐个字符传入tokenize_line函数执行    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tokenize_lines</span>(<span class=\"params\"><span class=\"built_in\">input</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An iterator over lists of tokens, one for each line of the iterable</span></span><br><span class=\"line\"><span class=\"string\">    input sequence.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (tokenize_line(line) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">input</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#获取tokenize_line函数执行返回结果构成的列表，并将其转为Buffer类的实例对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, source</span>):</span></span><br><span class=\"line\">        self.index = <span class=\"number\">0</span></span><br><span class=\"line\">        self.lines = []</span><br><span class=\"line\">        self.source = source</span><br><span class=\"line\">        self.current_line = ()</span><br><span class=\"line\">        self.current()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">remove_front</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Remove the next item from self and return it. If self has</span></span><br><span class=\"line\"><span class=\"string\">        exhausted its source, returns None.&quot;&quot;&quot;</span></span><br><span class=\"line\">        current = self.current()</span><br><span class=\"line\">        self.index += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> current</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">current</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return the current element, or None if none exists.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.more_on_line:</span><br><span class=\"line\">            self.index = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                self.current_line = <span class=\"built_in\">next</span>(self.source)</span><br><span class=\"line\">                self.lines.append(self.current_line)</span><br><span class=\"line\">            <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">                self.current_line = ()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.current_line[self.index]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">more_on_line</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.index &lt; <span class=\"built_in\">len</span>(self.current_line)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return recently read contents; current element marked with &gt;&gt;.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># Format string for right-justified line numbers</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(self.lines)</span><br><span class=\"line\">        msg = <span class=\"string\">&#x27;&#123;0:&gt;&#x27;</span> + <span class=\"built_in\">str</span>(math.floor(math.log10(n))+<span class=\"number\">1</span>) + <span class=\"string\">&quot;&#125;: &quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Up to three previous lines and current line are included in output</span></span><br><span class=\"line\">        s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, n-<span class=\"number\">4</span>), n-<span class=\"number\">1</span>):</span><br><span class=\"line\">            s += msg.<span class=\"built_in\">format</span>(i+<span class=\"number\">1</span>) + <span class=\"string\">&#x27; &#x27;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, self.lines[i])) + <span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">        s += msg.<span class=\"built_in\">format</span>(n)</span><br><span class=\"line\">        s += <span class=\"string\">&#x27; &#x27;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, self.current_line[:self.index]))</span><br><span class=\"line\">        s += <span class=\"string\">&#x27; &gt;&gt; &#x27;</span></span><br><span class=\"line\">        s += <span class=\"string\">&#x27; &#x27;</span>.join(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, self.current_line[self.index:]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.strip()</span><br></pre></td></tr></table></figure>\n\n<p>Buffer实例有两个核心方法remove_front和current，这两个方法可以对Buffer对象里的值进行有序输出。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; buf = Buffer(iter([[&#x27;(&#x27;, &#x27;+&#x27;], [15], [12, &#x27;)&#x27;]]))</span><br><span class=\"line\">&gt;&gt;&gt; buf.remove_front()</span><br><span class=\"line\">&#x27;(&#x27;</span><br><span class=\"line\">&gt;&gt;&gt; buf.remove_front()</span><br><span class=\"line\"><span class=\"symbol\">&#x27;+</span>&#x27;</span><br><span class=\"line\">&gt;&gt;&gt; buf.current()</span><br><span class=\"line\"><span class=\"number\">15</span></span><br><span class=\"line\">&gt;&gt;&gt; print(buf)</span><br><span class=\"line\"><span class=\"number\">1</span>: ( +</span><br><span class=\"line\"><span class=\"number\">2</span>:  &gt;&gt; <span class=\"number\">15</span></span><br><span class=\"line\">&gt;&gt;&gt; buf.remove_front()</span><br><span class=\"line\"><span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>经过词法分析，用户输入的字符串被转换成了可有序输出的Buffer实例对象，就好像排列在内存中的数据一样，但是有一个问题就在于，对于这些存在实例对象中的数据，数据之间的相互关联并没有建立，就好像在游乐园等待入场的队列，虽然有序，但是相互之间毫无关联。</p>\n<p>因此我们要进行句法分析。</p>\n<h5 id=\"句法分析\"><a href=\"#句法分析\" class=\"headerlink\" title=\"句法分析\"></a>句法分析</h5><p>在该项目中，我们使用scheme_read进行句法分析，最终返回一个Pair对象expression</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expression = scheme_read(src)</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下scheme_read的逻辑流程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scheme_read</span>(<span class=\"params\">src</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Read the next expression from SRC, a Buffer of tokens.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;nil&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    nil</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;1&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;true&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;(+ 1 2)&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    Pair(&#x27;+&#x27;, Pair(1, Pair(2, nil)))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.current() <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> EOFError</span><br><span class=\"line\">    val = src.remove_front() <span class=\"comment\"># Get the first token</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> val == <span class=\"string\">&#x27;nil&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nil</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> val == <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> read_tail(src)</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> val <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 7</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Pair(quotes[val],Pair(scheme_read(src),nil))</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 7</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> val <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> DELIMITERS:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SyntaxError(<span class=\"string\">&#x27;unexpected token: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(val))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_tail</span>(<span class=\"params\">src</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the remainder of a list in SRC, starting before an element or ).</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;)&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    nil</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;2 3)&#x27;])))</span></span><br><span class=\"line\"><span class=\"string\">    Pair(2, Pair(3, nil))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> src.current() <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SyntaxError(<span class=\"string\">&#x27;unexpected end of file&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> src.current() == <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">            <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">            src.remove_front()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nil</span><br><span class=\"line\">            <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"comment\"># BEGIN PROBLEM 2</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Pair(scheme_read(src),read_tail(src))</span><br><span class=\"line\">            <span class=\"comment\"># END PROBLEM 2</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> EOFError:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SyntaxError(<span class=\"string\">&#x27;unexpected end of file&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">quotes = &#123;<span class=\"string\">&quot;&#x27;&quot;</span>:  <span class=\"string\">&#x27;quote&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;`&#x27;</span>:  <span class=\"string\">&#x27;quasiquote&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;,&#x27;</span>:  <span class=\"string\">&#x27;unquote&#x27;</span>&#125;</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，对于不同的结构，scheme_read有不同的方案去构造，主要可以分为三种，一种是普通的基础表达式，比如123，nil和布尔值，一种是调用表达式，scheme_read函数规定当遇到‘（’时会自动进入read_tail函数，最终返回一个完整的Pair结构，第三种就是符号，函数会判断这个符号是Quote，Quasiquote还是unquote，并将这三个模式传入以供后期评估使用。</p>\n<p>最终输入如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scheme_read(Buffer(tokenize_lines([<span class=\"string\">&#x27;(+ 1 2)&#x27;</span>])))</span><br><span class=\"line\">Pair(<span class=\"string\">&#x27;+&#x27;</span>, Pair(<span class=\"number\">1</span>, Pair(<span class=\"number\">2</span>, nil)))</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，经过句法分析，我们建立了字符之间的关联性，同属于一个调用表达式的字符被整合进 了独立的一个Pair实例，就好比，让在排队的人，夫妻合并成一组，家庭或朋友合并成一组，再进行排队。</p>\n<p>经过第一部分Read，我们拥有了具有关联性的Pair对象，在接下来的Eval部分中，我们将要对这个对象进行评估。</p>\n<h4 id=\"Eval-部分\"><a href=\"#Eval-部分\" class=\"headerlink\" title=\"Eval 部分\"></a>Eval 部分</h4><p>在整个评估过程中，有两个类发挥着重要作用，一个类是Frame，Frame类是一个环境框架，我们学习Python作用域的时候学习过，程序开始时候是在Global Frame下，当调用函数时候，会创建一个Frame，并且在该Frame下创建的变量和传入的参数是不能在Global Frame下被使用的，Scheme同样如此，所以我们创建了一个Frame类用于分离不同作用域。一个类是Procedure，Procedure类是过程类，他有两个子类，一个是BuiltinProcedure，即内置过程，比如我们使用的if，cons，cond都是内置过程，另一个是LambdaProcedure，即匿名过程，这是用来创建并绑定用户定义过程的。</p>\n<h5 id=\"Frame类\"><a href=\"#Frame类\" class=\"headerlink\" title=\"Frame类\"></a>Frame类</h5><p>EFrame类实现了环境框架，在对解释器进行初始化的时候，会调用create_global_frame创建一个Frame环境框架。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Frame</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An environment frame binds Scheme symbols to Scheme values.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, parent</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;An empty frame with parent frame PARENT (which may be None).&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.bindings = &#123;&#125;</span><br><span class=\"line\">        self.parent = parent</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.parent <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;Global Frame&gt;&#x27;</span></span><br><span class=\"line\">        s = <span class=\"built_in\">sorted</span>([<span class=\"string\">&#x27;&#123;0&#125;: &#123;1&#125;&#x27;</span>.<span class=\"built_in\">format</span>(k, v) <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.bindings.items()])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;&#123;&#123;&#123;0&#125;&#125;&#125; -&gt; &#123;1&#125;&gt;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&#x27;, &#x27;</span>.join(s), <span class=\"built_in\">repr</span>(self.parent))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">define</span>(<span class=\"params\">self, symbol, value</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Define Scheme SYMBOL to have VALUE.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 3</span></span><br><span class=\"line\">        self.bindings[symbol]=value</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lookup</span>(<span class=\"params\">self, symbol</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return the value bound to SYMBOL. Errors if SYMBOL is not found.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 3</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.bindings[symbol]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyError:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.parent <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> self.parent.lookup(symbol)</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 3</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;unknown identifier: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(symbol))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_child_frame</span>(<span class=\"params\">self, formals, vals</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Return a new local frame whose parent is SELF, in which the symbols</span></span><br><span class=\"line\"><span class=\"string\">        in a Scheme list of formal parameters FORMALS are bound to the Scheme</span></span><br><span class=\"line\"><span class=\"string\">        values in the Scheme list VALS. Raise an error if too many or too few</span></span><br><span class=\"line\"><span class=\"string\">        vals are given.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; env = create_global_frame()</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; formals, expressions = read_line(&#x27;(a b c)&#x27;), read_line(&#x27;(1 2 3)&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; env.make_child_frame(formals, expressions)</span></span><br><span class=\"line\"><span class=\"string\">        &lt;&#123;a: 1, b: 2, c: 3&#125; -&gt; &lt;Global Frame&gt;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 11</span></span><br><span class=\"line\">        match_dict = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(formals)!=<span class=\"built_in\">len</span>(vals):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;The number of argument values does not match&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(formals)):</span><br><span class=\"line\">                match_dict[formals.first] = vals.first</span><br><span class=\"line\">                formals = formals.second</span><br><span class=\"line\">                vals = vals.second</span><br><span class=\"line\">        new_frame = Frame(self)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> match_dict.items():</span><br><span class=\"line\">            new_frame.define(key,value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_frame</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 11</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Frame框架类从外界引入一个父环境Frame实例，并维护一个binding列表，在初始化时候，会在初始Frame环境中调用define方法引入内置过程，在后面的过程中，如果需要引入用户过程，可以通过define引入，查找内置过程，可以通过lookup方法实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_global_frame</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Initialize and return a single-frame environment with built-in names.&quot;&quot;&quot;</span></span><br><span class=\"line\">    env = Frame(<span class=\"literal\">None</span>)</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;eval&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_eval, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;eval&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;apply&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(complete_apply, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;apply&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;load&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_load, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;load&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;procedure?&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_procedurep, <span class=\"literal\">False</span>, <span class=\"string\">&#x27;procedure?&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;map&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_map, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;map&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;filter&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_filter, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;filter&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;reduce&#x27;</span>,</span><br><span class=\"line\">               BuiltinProcedure(scheme_reduce, <span class=\"literal\">True</span>, <span class=\"string\">&#x27;reduce&#x27;</span>))</span><br><span class=\"line\">    env.define(<span class=\"string\">&#x27;undefined&#x27;</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\">    add_builtins(env, BUILTINS)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env</span><br></pre></td></tr></table></figure>\n\n<p>当子环境创建需要引入一个Frame实例时，Frame可以调用make_child_frame创建一个子Frame并返回。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_call_frame</span>(<span class=\"params\">self,args,env</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> env.make_child_frame(self.formals, args)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Procedure类\"><a href=\"#Procedure类\" class=\"headerlink\" title=\"Procedure类\"></a>Procedure类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuiltinProcedure</span>(<span class=\"params\">Procedure</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A Scheme procedure defined as a Python function.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, fn, use_env=<span class=\"literal\">False</span>, name=<span class=\"string\">&#x27;builtin&#x27;</span></span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.fn = fn</span><br><span class=\"line\">        self.use_env = use_env</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#[&#123;0&#125;]&#x27;</span>.<span class=\"built_in\">format</span>(self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply</span>(<span class=\"params\">self, args, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Apply SELF to ARGS in ENV, where ARGS is a Scheme list.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; env = create_global_frame()</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; plus = env.bindings[&#x27;+&#x27;]</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; twos = Pair(2, Pair(2, nil))</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; plus.apply(twos, env)</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> scheme_listp(args):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;arguments are not in a list: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(args))</span><br><span class=\"line\">        <span class=\"comment\"># Convert a Scheme list to a Python list</span></span><br><span class=\"line\">        python_args = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> args <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            python_args.append(args.first)</span><br><span class=\"line\">            args = args.second</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 4</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.use_env:</span><br><span class=\"line\">            python_args.append(env)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.fn(*python_args)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> TypeError:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&quot;Invalid number of arguments to &#123;0&#125;&quot;</span>.<span class=\"built_in\">format</span>(self.name))</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaProcedure</span>(<span class=\"params\">Procedure</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A procedure defined by a lambda expression or a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, formals, body, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;A procedure with formal parameter list FORMALS (a Scheme list),</span></span><br><span class=\"line\"><span class=\"string\">        whose body is the Scheme list BODY, and whose parent environment</span></span><br><span class=\"line\"><span class=\"string\">        starts with Frame ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.formals = formals</span><br><span class=\"line\">        self.body = body</span><br><span class=\"line\">        self.env = env</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_call_frame</span>(<span class=\"params\">self, args, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Make a frame that binds my formal parameters to ARGS, a Scheme list</span></span><br><span class=\"line\"><span class=\"string\">        of values, for a lexically-scoped call evaluated in environment ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 12</span></span><br><span class=\"line\">        new_frame = self.env.make_child_frame(self.formals,args)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_frame</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 12</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">str</span>(Pair(<span class=\"string\">&#x27;lambda&#x27;</span>, Pair(self.formals, self.body)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;LambdaProcedure(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(</span><br><span class=\"line\">            <span class=\"built_in\">repr</span>(self.formals), <span class=\"built_in\">repr</span>(self.body), <span class=\"built_in\">repr</span>(self.env))</span><br></pre></td></tr></table></figure>\n\n<p>内置过程表示为BuiltinProcedure实例，BuiltinProcedure具有两个实例属性，fn是实施内置方案程序的Python功能，use_env是一个布尔标志，指示这个内置程序是否会期望当前环境作为最后一个参数传递。例如，需要环境来实施内置eval程序。</p>\n<p>用户定义的程序表示为LambdaProcedure实例。LambdaProcedure具有三个实例属性，formals是命名程序参数的正式参数（符号）的方案列表。body是一个方案列表的表达式，程序的主体。<br>env是定义程序的Frame环境。</p>\n<h5 id=\"评估仅内置过程的表达式\"><a href=\"#评估仅内置过程的表达式\" class=\"headerlink\" title=\"评估仅内置过程的表达式\"></a>评估仅内置过程的表达式</h5><p>当我们评估只有内置过程的表达式的时候，我们会进行这个过程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> scheme_symbolp(first) <span class=\"keyword\">and</span> first <span class=\"keyword\">in</span> SPECIAL_FORMS:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SPECIAL_FORMS[first](rest, env)</span><br></pre></td></tr></table></figure>\n\n<p>这里的SPECIAL_FORMS就是内置过程的列表，我们通过first变量传入操作符名称，当我们发现评估的操作符是个内置过程的时候，我们就会调用这段代码找到对应调用内置过程的函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPECIAL_FORMS = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;and&#x27;</span>: do_and_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;begin&#x27;</span>: do_begin_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;cond&#x27;</span>: do_cond_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;define&#x27;</span>: do_define_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;if&#x27;</span>: do_if_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;lambda&#x27;</span>: do_lambda_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;let&#x27;</span>: do_let_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;or&#x27;</span>: do_or_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;quote&#x27;</span>: do_quote_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;define-macro&#x27;</span>: do_define_macro,</span><br><span class=\"line\">    <span class=\"string\">&#x27;quasiquote&#x27;</span>: do_quasiquote_form,</span><br><span class=\"line\">    <span class=\"string\">&#x27;unquote&#x27;</span>: do_unquote,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们以评估define内置过程为例来讲解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_define_form</span>(<span class=\"params\">expressions, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Evaluate a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\">    check_form(expressions, <span class=\"number\">2</span>)</span><br><span class=\"line\">    target = expressions.first</span><br><span class=\"line\">    <span class=\"keyword\">if</span> scheme_symbolp(target):</span><br><span class=\"line\">        check_form(expressions, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 6</span></span><br><span class=\"line\">        value = scheme_eval(expressions.second.first,env)</span><br><span class=\"line\">        env.define(target,value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 6</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        bad_target = target.first <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(target, Pair) <span class=\"keyword\">else</span> target</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;non-symbol: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(bad_target))</span><br></pre></td></tr></table></figure>\n\n<p>do_define_form函数引入了两个参数，根据调用函数可知，传入的expression参数是调用表达式的操作数部分，因此就把操作数评估后的结果在全局环境下与设定的变量绑定了，其关键代码为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env.define(target,value)</span><br></pre></td></tr></table></figure>\n\n<p>这就是实现一个内置过程的办法，接下来我们来看看该如何实现用户定义函数。</p>\n<h5 id=\"评估带有用户定义的表达式\"><a href=\"#评估带有用户定义的表达式\" class=\"headerlink\" title=\"评估带有用户定义的表达式\"></a>评估带有用户定义的表达式</h5><p>我们先来看看如何使用内置过程<code>define</code>定义一个用户过程。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_define_form</span>(<span class=\"params\">expressions, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Evaluate a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\">    check_form(expressions, <span class=\"number\">2</span>)</span><br><span class=\"line\">    target = expressions.first</span><br><span class=\"line\">    <span class=\"keyword\">if</span> scheme_symbolp(target):</span><br><span class=\"line\">        check_form(expressions, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 6</span></span><br><span class=\"line\">        value = scheme_eval(expressions.second.first,env)</span><br><span class=\"line\">        env.define(target,value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 6</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(target, Pair) <span class=\"keyword\">and</span> scheme_symbolp(target.first):</span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 10</span></span><br><span class=\"line\">        name = target.first</span><br><span class=\"line\">        formal = target.second</span><br><span class=\"line\">        body = expressions.second</span><br><span class=\"line\">        process = LambdaProcedure(formal,body,env)</span><br><span class=\"line\">        env.define(name,process)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 10</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        bad_target = target.first <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(target, Pair) <span class=\"keyword\">else</span> target</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> SchemeError(<span class=\"string\">&#x27;non-symbol: &#123;0&#125;&#x27;</span>.<span class=\"built_in\">format</span>(bad_target))</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这个define函数比之前仅能定义变量的函数多了elif的部分，在这个过程中，函数首先将整个定义代码段分成name函数名称，formal函数参数，和body函数主体三个部分，而后将这三个部分放入LambdaProcedure类创建一个实例，最后调用Frame的define过程将新定义的过程实例与过程名绑定，以便后期lookup函数的查找。</p>\n<p>我们来看看创建新过程的实例时候，发生了什么。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaProcedure</span>(<span class=\"params\">Procedure</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A procedure defined by a lambda expression or a define form.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, formals, body, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;A procedure with formal parameter list FORMALS (a Scheme list),</span></span><br><span class=\"line\"><span class=\"string\">        whose body is the Scheme list BODY, and whose parent environment</span></span><br><span class=\"line\"><span class=\"string\">        starts with Frame ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.formals = formals</span><br><span class=\"line\">        self.body = body</span><br><span class=\"line\">        self.env = env</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_call_frame</span>(<span class=\"params\">self, args, env</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Make a frame that binds my formal parameters to ARGS, a Scheme list</span></span><br><span class=\"line\"><span class=\"string\">        of values, for a lexically-scoped call evaluated in environment ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN PROBLEM 12</span></span><br><span class=\"line\">        new_frame = self.env.make_child_frame(self.formals,args)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_frame</span><br><span class=\"line\">        <span class=\"comment\"># END PROBLEM 12</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">str</span>(Pair(<span class=\"string\">&#x27;lambda&#x27;</span>, Pair(self.formals, self.body)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;LambdaProcedure(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(</span><br><span class=\"line\">            <span class=\"built_in\">repr</span>(self.formals), <span class=\"built_in\">repr</span>(self.body), <span class=\"built_in\">repr</span>(self.env))</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，lambda维护着一个方法，当调用到用户实例的时候，就会调用这个方法，打开一个新Frame进行运算。</p>\n<p>最后对调用表达式执行apply操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scheme_apply</span>(<span class=\"params\">procedure, args, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in</span></span><br><span class=\"line\"><span class=\"string\">    environment ENV.&quot;&quot;&quot;</span></span><br><span class=\"line\">    check_procedure(procedure)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(procedure, BuiltinProcedure):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> procedure.apply(args, env)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        new_env = procedure.make_call_frame(args, env)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> eval_all(procedure.body, new_env)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eval_all</span>(<span class=\"params\">expressions, env</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Evaluate each expression in the Scheme list EXPRESSIONS in</span></span><br><span class=\"line\"><span class=\"string\">    environment ENV and return the value of the last.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># BEGIN PROBLEM 8</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> expressions == nil:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        value = expressions.<span class=\"built_in\">map</span>((<span class=\"keyword\">lambda</span> x:scheme_eval(x,env)))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> value <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> nil:</span><br><span class=\"line\">            now = value.first</span><br><span class=\"line\">            value = value.second</span><br><span class=\"line\">        <span class=\"keyword\">return</span> now</span><br></pre></td></tr></table></figure>\n\n<p>至此，整个解释器就写完了，再加上内置的自循环函数，一个可以运行Scheme程序的python解释器就大功告成了。在61A 的Scheme项目中，还有如宏和流这种复杂的过程，大家可以自行学习，不过本质还是和内置过程的评估相差不大。学习这个项目的目的不是真的要完成一个解释器，而是要让你学会和理解解释器是如何”翻译“一种语言的，这样你才能更好的去理解各种编程范式，例如函数式编程，面向对象编程.</p>\n"},{"title":"CS61A-对象抽象","date":"2021-08-08T07:56:30.000Z","cover":"/myimage/cs61/cs61a_objects_cover.png","_content":"\n#### 目录\n\n>面向对象编程（OOP）\n>\n>* 对象和类\n>* 类属性与实例属性\n>* 消息传递与点表达式\n>* 类方法\n>\n>继承与方法\n>\n>* 继承与方法重写\n>* 多重继承\n>* 特殊方法\n>\n>递归对象的实现\n>\n>* 链表类\n>* 树类\n\n\n\n在课程的第一章当中我们提到了使用函数进行抽象，这种方式可以很好的对数据进行处理，然而仅仅只考虑函数式编程往往会产生很多问题，举个例子，假设一家银行仅仅使用变量和函数来对人员的账户进行管理，他们使用xx_money ,xx_name来进行人员账户的登记，利用`transfrom()`函数进行转账操作\n\n```python\nTom_money = 100\nBob_money = 200\nJef_money = 400\nDavid_money = 500\n\ndef transform(from_account,to_account,number):\n    from_account -= number\n    to_account +- number\n```\n\n突然有一天，银行的i系统在调试过程中被某个程序员整崩溃了，重新找回数据的时候变成了这样\n\n```python\n￥&×.money = 100\n%^&.money = 200\n...\n```\n\n银行傻眼了，这下怎么区分金额属于谁啊，他们只能重新寻找曾经顾客注册登记用的纸质材料，费了好大的功夫才好不容易将数据恢复了回去，经过这次事件，银行的工作人员开始思考，是不是应该换一种方式对数据进行记录，经过长时间的研究讨论，他们决定使用面向对象的编程方式重新组织和记录数据，从此以后，再也没有出现过类似的事情。\n\n面向对象OOP，究竟强大在何处？\n\n接下来我们将对OOP进行深入分析，为大家揭开这个谜底。\n\n\n\n### 面向对象编程\n\n#### 对象和类\n\n上面我们讲到，利用面向对象的思考方式，我们可以解决银行账户的问题，那么为什么呢？原因就在于，之前银行储存数据时，没有考虑到数据与数据之间的关联性，仅仅只采用了很弱的关系，统一变量名来进行关联，而利用面向对象的思考方式，是将一个账户看做一个对象，每一个变量都是其对象的对象属性。\n\n什么是对象？对象就是具有同一特征的一类元素，比如，一个人就是一个对象，每个人都有鼻子眼睛嘴巴，而且都能行走和思考，这些具有的同一特征就被称作一个类，类就好像上帝在造人的时候使用的模板。再比如一支笔，无论他是钢笔还是水笔，毛笔，都具有写字这个功能，因此同属于笔这个类，而每一支笔都是一个独立的对象。\n\n下面我们通过一个例子来具体讲解类和对象，Lab8的这个例子很好，我就直接借用了。\n\nTiffany 迟到了，需要在讲座开始前从旧金山赶到伯克利。她会乘坐 BART，但这会花费太长时间。要是有车就好了 一辆巨型卡车会是最好的。\n\n我们要为Tiffany造一辆汽车，我们首先要创建一个汽车类，用户定义的类是由class语句创建的，它由单个子句组成。class 语句定义类名称，然后包含一组语句来定义类的属性：\n\n```python\nclass car：\n```\n\n接下来我们要对这个类增加一些属性，一辆车有哪些属性呢？品牌，型号，颜色，轮子数，汽油量，那么我们要对这个类附加属性，类的构造函数是一个函数，它创建类所概述的对象的实例或单个实例。在 Python 中，构造函数方法名为init，在Car类的构造函数如下所示：\n\n```python\nclass car:\n   def __init__(self, make, model):\n    self.make = make\n    self.model = model\n    self.color = 'No color yet. You need to paint me.'\n    self.wheels = Car.num_wheels\n    self.gas = Car.gas\n```\n\n该__init__有三个参数。第一个参数self，自动绑定到新创建的Car对象。第二个和第三个参数make和model绑定到传递给构造函数的参数，这意味着当我们创建一个Car对象时，我们必须提供两个参数。\n\n于是，汽车这个类我们就构造完毕了，让我们开始造我们的车。蒂芙尼想开一辆特斯拉 Model S 去上课。所以我们可以构造一个厂家为“Tesla”，型号为“Model S”的汽车实例，Python 允许我们通过类的名称来创建类的实例，而不是显式调用。\n\n```python\n>>> tiffanys_car = Car('Tesla', 'Model S')\n```\n\n在这里，'Tesla'作为 make传入，“Model S”作为model传入， 请注意，我们没有传递参数self，因为它的值始终是正在创建的对象，一个对象是类的一个实例。在这种情况下， tiffanys_car现在绑定到一个Car对象，或者换句话说，绑定到Car类的一个实例。\n\n这样，我们就创建了一个Car类，并且通过Car类创建了一个tiffanys_car的实例对象。\n\n#### 实例属性与类属性\n\n我们继续来看我们上面创建的Car类：\n\n```python\nclass Car(object):\n    num_wheels = 4\n    gas = 30\n    headlights = 2\n    size = 'Tiny'\n\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n        self.color = 'No color yet. You need to paint me.'\n        self.wheels = Car.num_wheels\n        self.gas = Car.gas\n```\n\n我们会发现，诶，除了我们刚刚利用构造函数所创建的属性，上面怎么还多了几行？\n\n这里就涉及到实例属性和类属性两个概念了，什么是类属性？类属性就是同属于一个类的对象所共有的属性 ，比如，只要是汽车，肯定都是四个轮子，两个头灯，一个后备箱，这些是所有汽车共有的属性，所以被称作类属性。而不同的汽车有不同的型号，品牌，颜色和汽油量，因此这些属性就被称作实例属性。每创建一个实例对象，都会自动将类属性附加给该实例。\n\n#### 消息传递与点表达式\n\n上面，我们为tiffany造了一辆车，但如果有一天，tiffany说，我不想开Tesla了，我想换辆Benz开开，那该怎么办呢？我们当然可以重新利用Car类创造一个新的实例对象，但这太麻烦了，有没有什么办法可以对已有的车辆属性进行改变呢？\n\n有的，利用点符号就可以。\n\n例如，我们可以访问Car类的类属性size\n\n```python\n>>> Car.size\n'Tiny'\n```\n\n同样也可以对Car类的属性进行改变\n\n```python\n>>> Car.size = 'Big'\n'Tiny'\n```\n\n对实例属性的改变也是同样如此，在以下行中，我们访问tiffanys_car的make属性：\n\n```python\n>> tiffanys_car.make \n'Tesla'\n```\n\n而后我们将make属性修改为‘Benz’:\n\n```python\n>>> tiffanys_car.make = 'Benz'\n```\n\n这样，我们就成功改造了tiffany的车子，是不是很简单呢？\n\n#### 类方法\n\n让我们再为Car类增加一些东西\n\n```python\nclass Car(object):\n    num_wheels = 4\n    gas = 30\n    headlights = 2\n    size = 'Tiny'\n\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n        self.color = 'No color yet. You need to paint me.'\n        self.wheels = Car.num_wheels\n        self.gas = Car.gas\n\n    def paint(self, color):\n        self.color = color\n        return self.make + ' ' + self.model + ' is now ' + color\n\n    def drive(self):\n        if self.wheels < Car.num_wheels or self.gas <= 0:\n            return 'Cannot drive!'\n        self.gas -= 10\n        return self.make + ' ' + self.model + ' goes vroom!'\n\n    def pop_tire(self):\n        if self.wheels > 0:\n            self.wheels -= 1\n\n    def fill_gas(self):\n        self.gas += 20\n        return 'Gas level: ' + str(self.gas)\n```\n\n这些def叫做类的方法，他们可以调用类的属性，并且输出给外界。方法是特定于类的函数，只有类的一个实例可以使用它们，那么，我们如何在实例上调用方法？你猜对了，点符号！\n\n```python\n>>> tiffanys_car.paint('black')\n'Tesla Model S is now black'\n>>> tiffanys_car.color\n'black'\n```\n\n上面是一个调用paint方法的过程，我们仔细看一下这个方法，它需要两个参数，那么为什么我们不需要传递两个参数呢？就好像我们在init构造函数中看到的那样，一个类的所有方法都有一个self参数，python会自动将调用该方法的实例绑定到该参数，在这里，self绑定到tiffanys_car这个实例，并调用paint函数改变实例属性\n\n您还可以使用类名和点符号来调用方法；例如，\n\n```python\n>>> Car.paint(tiffanys_car, 'red')\n'Tesla Model S is now red'\n```\n\n请注意，与我们将 Tiffany 的汽车漆成黑色不同，这次我们必须传入两个参数：一个 self和一个 color。这是因为当您使用点表示法从实例调用方法时，Python 知道要自动绑定到哪个实例self。但是，当您使用类中的点表示法调用方法时，Python 不知道Car我们要绘制哪个实例 ，因此我们也要将实例作为参数传入。\n\n### 继承与方法重写\n\n61A讲继承的时候举了一个很有意思的例子，大家小时候都玩过宝可梦吧，让我们来创建一个宝可梦的类\n\n```python\nclass Pokemon:\n    basic_attack = 'tackle'\n    damage = 40\n    def __init__(self, name, trainer):\n        self.name, self.trainer = name, trainer\n        self.level, self.hp = 1, 50\n        self.paralyzed = False\n    def speak(self):\n        print(self.name + '!')\n    def attack(self, other):\n        if not self.paralyzed:\n            self.speak()\n            print(self.name, 'used', self.basic_attack, '!')\n            other.receive_damage(self.damage)\n    def receive_damage(self, damage):\n        self.hp = max(0, self.hp - damage)\n        if self.hp == 0:\n            print(self.name, 'fainted!')   \n```\n\n噢我们可以看见，一个宝可梦类有类属性damage，basic_attack，有实例属性name，level，paralyzed，还有一些类方法。\n\n现在我们再来创建一个电属性的宝可梦类\n\n```python\nclass ElectricType:\n    basic_attack = 'thunder shock'\n    damage = 40\n    prob = 0.1\n    def __init__(self, name, trainer):\n          self.name, self.trainer = name, trainer\n          self.level, self.hp = 1, 50\n          self.paralyzed = False\n    def attack(self, other):\n        self.speak()\n        print(self.name, 'used', self.basic_attack, '!')\n        other.receive_damage(self.damage)\n        if random() < self.prob and type(other) != ElectricType:\n            other.paralyzed = True\n            print(other.name, 'is paralyzed!')\n    def receive_damage(self, damage):\n        self.hp = max(0, self.hp - damage)\n        if self.hp == 0:\n            print(self.name, 'fainted!')   \n```\n\n有些人会说好麻烦，为什么不直接在原来的基础上修改，说的好，这就是继承的概念，我们会发现电属性宝可梦类和宝可梦类只有\n\n类属性部分\n\n```\n prob = 0.1\n```\n\nattack方法\n\n```python\ndef attack(self, other):\n        self.speak()\n        print(self.name, 'used', self.basic_attack, '!')\n        other.receive_damage(self.damage)\n        if random() < self.prob and type(other) != ElectricType:\n            other.paralyzed = True\n            print(other.name, 'is paralyzed!')\n```\n\n这两个模块是不同的，其他都是相同的，所以我们可以这样来写电属性宝可梦类。\n\n```python\nclass ElectricType(Pokemon):\n    basic_attack = 'thunder shock'\n    prob = 0.1\n    def attack(self, other):\n        Pokemon.attack(self, other)\n        if random() < self.prob and type(other) != ElectricType:\n            other.paralyzed = True\n            print(other.name, 'is paralyzed!')\n```\n\n这里的`class <Class Name>(<Superclass Name>):`结构就是继承，通过继承，我们可以在新创建的类中保留下原有的类属性和实例属性\n\n```python\n>>> Pica = ElectricType('pica','me')\n>>> Pica.hp\n50\n```\n\n可以看得出，新类所创建的实例拥有和被继承类相同的实例属性。\n\n我们还可以看到，attack方法被重写了，原来attack的方法被覆盖了，这种情况叫做方法重写，新类可以创建与被继承类相同名称的方法，将会覆盖原有方法.\n\n```python\n>>>Pica.attack(Yib)\n'Yib is paralyzed!'\n```\n\n这时候有人会问，那如果需要增加或删除实例属性项，是不是要重写一遍构造函数？\n\n当然，重写固然没有问题，但是还有更简便的方法。\n\n我们举一个61A Project ant的例子\n\n假设我们有一个昆虫类\n\n```python\nclass Insect(object):\n    \"\"\"An Insect, the base class of Ant and Bee, has armor and a Place.\"\"\"\n    \n    is_ant = False\n    damage = 0\n    is_watersafe = False\n    # ADD CLASS ATTRIBUTES HERE\n\n    def __init__(self, armor, place=None):\n        \"\"\"Create an Insect with an ARMOR amount and a starting PLACE.\"\"\"\n        self.armor = armor\n        self.armor = armor\n        self.place = place  \n\n    def reduce_armor(self, amount):\n        \"\"\"Reduce armor by AMOUNT, and remove the insect from its place if it\n        has no armor remaining.\n\n        >>> test_insect = Insect(5)\n        >>> test_insect.reduce_armor(2)\n        >>> test_insect.armor\n        3\n        \"\"\"\n        self.armor -= amount\n        if self.armor <= 0:\n            self.place.remove_insect(self)\n\n```\n\n接下来我们要创建一个新的Ant类，这个Ant类是Insert类的一个子类，它继承了Insert类的一些方法和属性，不同的是，我们要修改一下Ant类当中amor属性的默认值。\n\n```python\nclass Ant(Insect):\n    \"\"\"An Ant occupies a place and does work for the colony.\"\"\"\n\n    is_ant = True\n    implemented = False  # Only implemented Ant classes should be instantiated\n    food_cost = 0\n    blocks_path = True\n    is_container = False\n    is_double = False\n    # ADD CLASS ATTRIBUTES HERE\n\n    def __init__(self, armor=1):\n        \"\"\"Create an Ant with an ARMOR quantity.\"\"\"\n        Insect.__init__(self, armor)\n\n    def can_contain(self, other):\n        return False\n\n```\n\n我们使用了`Insert.__init__(self,armor=1)`来修改父类的构造函数\n\n我们再以Ant为父类，创建一个名为HungryAnt的子类\n\n```python\nclass HungryAnt(Ant):\n    \"\"\"HungryAnt will take three turns to digest a Bee in its place.\n    While digesting, the HungryAnt can't eat another Bee.\n    \"\"\"\n    name = 'Hungry'\n    food_cost = 4\n    time_to_digest = 3\n    # BEGIN Problem 6\n    implemented = True  # Change to True to view in the GUI\n    # END Problem 6\n\n    def __init__(self, armor=1):\n        # BEGIN Problem 6\n        Ant.__init__(self, armor)\n        self.digesting = 0\n        # END Problem 6\n\n    def eat_bee(self, bee):\n        # BEGIN Problem 6\n        bee.armor = 0\n        self.place.remove_insect(bee)\n        self.digesting = self.time_to_digest\n        # END Problem 6\n\n    def action(self, colony):\n        # BEGIN Problem 6\n        if self.digesting == 0:\n            if random_or_none(self.place.bees) !=None:\n                self.eat_bee(random_or_none(self.place.bees))\n            else:\n                pass\n        else:\n            self.digesting -= 1\n        # END Problem 6\n```\n\n我们看到，这里我们使用`Insert.__init__(self,armor)`继承了父类的所有实例属性，并且在这基础上又增加了一个digesting属性作为该类独有的实例属性。\n\n#### 多重继承\n\n多重继承顾名思义，就是从多个父类继承的子类，比如，作为你父母的孩子，你既继承了你父亲的身高智慧，又继承了你母亲的高鼻梁大眼睛，因此在你这个类当中，既有父亲传给你的属性，又有母亲传给你的属性。\n\nPython 支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。\n\n恩，突然一下子想不出什么特别好的例子，大家可以在CS61A的一些习题当中找一些例子来看。\n\n#### 特殊方法\n\n在 Python 中，某些特殊名称会在特殊情况下由 Python 解释器调用。例如，每当构造对象时，都会自动调用类的__init__方法。每当打印对象时会自动调用__str__方法，在交互式会话到显示值会调用repr方法。\n\n假设我们有一个类A\n\n```python\nclass A:\n    def __init__(self,name,number):\n        self.name = name\n        self.number = number\n    def __str__(self):\n        return '<' + self.name + '>'\n    def __repr__(self):\n        return self.name\n```\n\n那么我们在打印A类所构造的实例对象时，就会自动调用__str__函数打印，交互式对话输入自动调用repr\n\n```python\n>>> a = A('alien',4)\n>>> print(a)\n<alien>\n>>> a\nalien\n```\n\n我们用Link对象举个例子\n\n```python\nclass Link:\n    \"\"\"A linked list.\n\n    >>> s = Link(1)\n    >>> s.first\n    1\n    >>> s.rest is Link.empty\n    True\n    >>> s = Link(2, Link(3, Link(4)))\n    >>> s.first = 5\n    >>> s.rest.first = 6\n    >>> s.rest.rest = Link.empty\n    >>> s                                    # Displays the contents of repr(s)\n    Link(5, Link(6))\n    >>> s.rest = Link(7, Link(Link(8, Link(9))))\n    >>> s\n    Link(5, Link(7, Link(Link(8, Link(9)))))\n    >>> print(s)                             # Prints str(s)\n    <5 7 <8 9>>\n    \"\"\"\n    empty = ()\n\n    def __init__(self, first, rest=empty):\n        assert rest is Link.empty or isinstance(rest, Link)\n        self.first = first\n        self.rest = rest\n\n    def __repr__(self):\n        if self.rest is not Link.empty:\n            rest_repr = ', ' + repr(self.rest)\n        else:\n            rest_repr = ''\n        return 'Link(' + repr(self.first) + rest_repr + ')'\n\n    def __str__(self):\n        string = '<'\n        while self.rest is not Link.empty:\n            string += str(self.first) + ' '\n            self = self.rest\n        return string + str(self.first) + '>'\n```\n\n虽然我们还没有讲到链表类，但是我们可以看到，Link类也重写了str和repr方法，因此Link类实现 方法的实现如下\n\n```python\n>>>s = Link(2, Link(3, Link(4)))\n>>>s\nLink(2, Link(3, Link(4)))\n>>>print(s)\n< 2 3 4>\n```\n\n除了最基本的str和repr特殊方法之外，python也支持对其他特殊方法进行修改，我们这里以contain特殊方法为例进行介绍,contain特殊方会在对实例使用in指令时自动调用\n\n```python\ndef __contains__(self,x):\n    if self.first == x：\n        return True\n    elif self.rest is Link.empty:\n        return False\n    return x in self.rest\n```\n\n这样我们就改写了contain特殊方法\n\n```python\n>>>l=Link(1,Link(2,Link(3)))\n>>>2 in l\nTrue\n>>>4 in l\nFalse\n```\n\n下面是一些常见的特殊方法，大家可以对其进行改写试一试。\n\n![image-20210809105526287](https://i.loli.net/2021/08/09/eG2QDp4y7vlIH9a.png)\n\n\n\n### 递归对象的实现\n\n对象可以有其他对象作为属性值。当某个类的对象具有同一个类的属性值时，它就是递归对象。\n\n常见的递归对象有链表类和树类两种\n\n#### 链表类\n\n本章前面已经提前给出Link类的概念，我们再次回顾一下，链表由第一个元素和列表的其余部分组成，链表的其余部分只能是一个链表，链表是一个序列，它的长度是有限的，并且支持按索引选择元素。\n\n我们可以实现一个Link类，表示一个链表对象。每个Link实例都有两个实例属性，first和rest。\n\n````python\nclass Link:\n    empty = ()\n\n    def __init__(self, first, rest=empty):\n        assert rest is Link.empty or isinstance(rest, Link)\n        self.first = first\n        self.rest = rest\n\n    def __repr__(self):\n        if self.rest is not Link.empty:\n            rest_repr = ', ' + repr(self.rest)\n        else:\n            rest_repr = ''\n        return 'Link(' + repr(self.first) + rest_repr + ')'\n\n    def __str__(self):\n        string = '<'\n        while self.rest is not Link.empty:\n            string += str(self.first) + ' '\n            self = self.rest\n        return string + str(self.first) + '>'\n````\n\n我们可以看出，链表第一个元素没有限制，但是第二个元素只能是一个链表或空链表，由于每个链表的第二个元素都是链表，所以链表是一个递归对象\n\n让我们通过一个例子来进一步加深印象，这道题是61A的题目。\n\n> 编写一个函数store_digits，接收一个整数n并返回一个链表，其中链表的每个元素都是 的一个数字n。\n\n```python\ndef store_digits(n):\n    \"\"\"Stores the digits of a positive number n in a linked list.\n\n    >>> s = store_digits(1)\n    >>> s\n    Link(1)\n    >>> store_digits(2345)\n    Link(2, Link(3, Link(4, Link(5))))\n    >>> store_digits(876)\n    Link(8, Link(7, Link(6)))\n    \"\"\"\n    # In iteration\n    new_link = Link.empty\n    while n !=0:\n        new_link = Link(n%10,new_link)\n        n = n//10\n    return new_link\n```\n\n这道题目就利用了Link递归的特性，通过递归过程对不断加长拓展链表，最终构成一个单一数字的链表。\n\n#### 树类\n\n回想一下，树是一种递归抽象数据类型，它具有label（存储在树根中的值）和branches（根正下方的树列表）两种不同类型的值，在数据抽象一章中，我们曾经使用将树视为列表的构造函数和选择器函数实现过树。\n\n```python\n# Tree ADT\ndef tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\n\ndef label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\n\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\n\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\n\ndef print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n\n    >>> print_tree(tree(1))\n    1\n    >>> print_tree(tree(1, [tree(2)]))\n    1\n      2\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\n    >>> print_tree(numbers)\n    1\n      2\n      3\n        4\n        5\n      6\n        7\n    \"\"\"\n    print('  ' * indent + str(label(t)))\n    for b in branches(t):\n        print_tree(b, indent + 1)\n\ndef copy_tree(t):\n    \"\"\"Returns a copy of t. Only for testing purposes.\n\n    >>> t = tree(5)\n    >>> copy = copy_tree(t)\n    >>> t = tree(6)\n    >>> print_tree(copy)\n    5\n    \"\"\"\n    return tree(label(t), [copy_tree(b) for b in branches(t)])\n```\n\n但是我们会发现使用这种方式创建的树是不可更改的，因为我们无法为调用表达式赋值，为了能够实现对树的修改，我们将构造器的功能用树类实现，而将选择器的功能用访问实例属性的点表达式实现\n\n```python\nclass Tree:\n    \"\"\"\n    >>> t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])\n    >>> t.label\n    3\n    >>> t.branches[0].label\n    2\n    >>> t.branches[1].is_leaf()\n    True\n    \"\"\"\n    def __init__(self, label, branches=[]):\n        for b in branches:\n            assert isinstance(b, Tree)\n        self.label = label\n        self.branches = list(branches)\n\n    def is_leaf(self):\n        return not self.branches\n```\n\n这样一来，我们就可以方便的创建树对象和修改树对象的label和branches属性，而不需要通过调用函数来获得树对象的各项属性，同时我们还可以在树类中任意增加各种方法，同样也只需要对实例进行方法调用即可。\n\n此外，使用构造选择函数和列表实现的树ADT与使用类与对象实现的树ADT还有如下的区别\n\n![image-20210809154119551](https://i.loli.net/2021/08/09/q6QKxZFmIGuWihL.png)\n\n总的来说，利用类实现的树ADT具有可变的特点，因此使用起来要比函数式的ADT更加便捷。\n\n\n\n\n\n\n\n\n\n","source":"_posts/CS61A-对象抽象.md","raw":"---\ntitle: CS61A-对象抽象\ndate: 2021-08-08 15:56:30\ntags:\n- 程序结构\n- CS61\n- CS61A\ncategories:\n- Learning Record\ncover: /myimage/cs61/cs61a_objects_cover.png\n---\n\n#### 目录\n\n>面向对象编程（OOP）\n>\n>* 对象和类\n>* 类属性与实例属性\n>* 消息传递与点表达式\n>* 类方法\n>\n>继承与方法\n>\n>* 继承与方法重写\n>* 多重继承\n>* 特殊方法\n>\n>递归对象的实现\n>\n>* 链表类\n>* 树类\n\n\n\n在课程的第一章当中我们提到了使用函数进行抽象，这种方式可以很好的对数据进行处理，然而仅仅只考虑函数式编程往往会产生很多问题，举个例子，假设一家银行仅仅使用变量和函数来对人员的账户进行管理，他们使用xx_money ,xx_name来进行人员账户的登记，利用`transfrom()`函数进行转账操作\n\n```python\nTom_money = 100\nBob_money = 200\nJef_money = 400\nDavid_money = 500\n\ndef transform(from_account,to_account,number):\n    from_account -= number\n    to_account +- number\n```\n\n突然有一天，银行的i系统在调试过程中被某个程序员整崩溃了，重新找回数据的时候变成了这样\n\n```python\n￥&×.money = 100\n%^&.money = 200\n...\n```\n\n银行傻眼了，这下怎么区分金额属于谁啊，他们只能重新寻找曾经顾客注册登记用的纸质材料，费了好大的功夫才好不容易将数据恢复了回去，经过这次事件，银行的工作人员开始思考，是不是应该换一种方式对数据进行记录，经过长时间的研究讨论，他们决定使用面向对象的编程方式重新组织和记录数据，从此以后，再也没有出现过类似的事情。\n\n面向对象OOP，究竟强大在何处？\n\n接下来我们将对OOP进行深入分析，为大家揭开这个谜底。\n\n\n\n### 面向对象编程\n\n#### 对象和类\n\n上面我们讲到，利用面向对象的思考方式，我们可以解决银行账户的问题，那么为什么呢？原因就在于，之前银行储存数据时，没有考虑到数据与数据之间的关联性，仅仅只采用了很弱的关系，统一变量名来进行关联，而利用面向对象的思考方式，是将一个账户看做一个对象，每一个变量都是其对象的对象属性。\n\n什么是对象？对象就是具有同一特征的一类元素，比如，一个人就是一个对象，每个人都有鼻子眼睛嘴巴，而且都能行走和思考，这些具有的同一特征就被称作一个类，类就好像上帝在造人的时候使用的模板。再比如一支笔，无论他是钢笔还是水笔，毛笔，都具有写字这个功能，因此同属于笔这个类，而每一支笔都是一个独立的对象。\n\n下面我们通过一个例子来具体讲解类和对象，Lab8的这个例子很好，我就直接借用了。\n\nTiffany 迟到了，需要在讲座开始前从旧金山赶到伯克利。她会乘坐 BART，但这会花费太长时间。要是有车就好了 一辆巨型卡车会是最好的。\n\n我们要为Tiffany造一辆汽车，我们首先要创建一个汽车类，用户定义的类是由class语句创建的，它由单个子句组成。class 语句定义类名称，然后包含一组语句来定义类的属性：\n\n```python\nclass car：\n```\n\n接下来我们要对这个类增加一些属性，一辆车有哪些属性呢？品牌，型号，颜色，轮子数，汽油量，那么我们要对这个类附加属性，类的构造函数是一个函数，它创建类所概述的对象的实例或单个实例。在 Python 中，构造函数方法名为init，在Car类的构造函数如下所示：\n\n```python\nclass car:\n   def __init__(self, make, model):\n    self.make = make\n    self.model = model\n    self.color = 'No color yet. You need to paint me.'\n    self.wheels = Car.num_wheels\n    self.gas = Car.gas\n```\n\n该__init__有三个参数。第一个参数self，自动绑定到新创建的Car对象。第二个和第三个参数make和model绑定到传递给构造函数的参数，这意味着当我们创建一个Car对象时，我们必须提供两个参数。\n\n于是，汽车这个类我们就构造完毕了，让我们开始造我们的车。蒂芙尼想开一辆特斯拉 Model S 去上课。所以我们可以构造一个厂家为“Tesla”，型号为“Model S”的汽车实例，Python 允许我们通过类的名称来创建类的实例，而不是显式调用。\n\n```python\n>>> tiffanys_car = Car('Tesla', 'Model S')\n```\n\n在这里，'Tesla'作为 make传入，“Model S”作为model传入， 请注意，我们没有传递参数self，因为它的值始终是正在创建的对象，一个对象是类的一个实例。在这种情况下， tiffanys_car现在绑定到一个Car对象，或者换句话说，绑定到Car类的一个实例。\n\n这样，我们就创建了一个Car类，并且通过Car类创建了一个tiffanys_car的实例对象。\n\n#### 实例属性与类属性\n\n我们继续来看我们上面创建的Car类：\n\n```python\nclass Car(object):\n    num_wheels = 4\n    gas = 30\n    headlights = 2\n    size = 'Tiny'\n\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n        self.color = 'No color yet. You need to paint me.'\n        self.wheels = Car.num_wheels\n        self.gas = Car.gas\n```\n\n我们会发现，诶，除了我们刚刚利用构造函数所创建的属性，上面怎么还多了几行？\n\n这里就涉及到实例属性和类属性两个概念了，什么是类属性？类属性就是同属于一个类的对象所共有的属性 ，比如，只要是汽车，肯定都是四个轮子，两个头灯，一个后备箱，这些是所有汽车共有的属性，所以被称作类属性。而不同的汽车有不同的型号，品牌，颜色和汽油量，因此这些属性就被称作实例属性。每创建一个实例对象，都会自动将类属性附加给该实例。\n\n#### 消息传递与点表达式\n\n上面，我们为tiffany造了一辆车，但如果有一天，tiffany说，我不想开Tesla了，我想换辆Benz开开，那该怎么办呢？我们当然可以重新利用Car类创造一个新的实例对象，但这太麻烦了，有没有什么办法可以对已有的车辆属性进行改变呢？\n\n有的，利用点符号就可以。\n\n例如，我们可以访问Car类的类属性size\n\n```python\n>>> Car.size\n'Tiny'\n```\n\n同样也可以对Car类的属性进行改变\n\n```python\n>>> Car.size = 'Big'\n'Tiny'\n```\n\n对实例属性的改变也是同样如此，在以下行中，我们访问tiffanys_car的make属性：\n\n```python\n>> tiffanys_car.make \n'Tesla'\n```\n\n而后我们将make属性修改为‘Benz’:\n\n```python\n>>> tiffanys_car.make = 'Benz'\n```\n\n这样，我们就成功改造了tiffany的车子，是不是很简单呢？\n\n#### 类方法\n\n让我们再为Car类增加一些东西\n\n```python\nclass Car(object):\n    num_wheels = 4\n    gas = 30\n    headlights = 2\n    size = 'Tiny'\n\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n        self.color = 'No color yet. You need to paint me.'\n        self.wheels = Car.num_wheels\n        self.gas = Car.gas\n\n    def paint(self, color):\n        self.color = color\n        return self.make + ' ' + self.model + ' is now ' + color\n\n    def drive(self):\n        if self.wheels < Car.num_wheels or self.gas <= 0:\n            return 'Cannot drive!'\n        self.gas -= 10\n        return self.make + ' ' + self.model + ' goes vroom!'\n\n    def pop_tire(self):\n        if self.wheels > 0:\n            self.wheels -= 1\n\n    def fill_gas(self):\n        self.gas += 20\n        return 'Gas level: ' + str(self.gas)\n```\n\n这些def叫做类的方法，他们可以调用类的属性，并且输出给外界。方法是特定于类的函数，只有类的一个实例可以使用它们，那么，我们如何在实例上调用方法？你猜对了，点符号！\n\n```python\n>>> tiffanys_car.paint('black')\n'Tesla Model S is now black'\n>>> tiffanys_car.color\n'black'\n```\n\n上面是一个调用paint方法的过程，我们仔细看一下这个方法，它需要两个参数，那么为什么我们不需要传递两个参数呢？就好像我们在init构造函数中看到的那样，一个类的所有方法都有一个self参数，python会自动将调用该方法的实例绑定到该参数，在这里，self绑定到tiffanys_car这个实例，并调用paint函数改变实例属性\n\n您还可以使用类名和点符号来调用方法；例如，\n\n```python\n>>> Car.paint(tiffanys_car, 'red')\n'Tesla Model S is now red'\n```\n\n请注意，与我们将 Tiffany 的汽车漆成黑色不同，这次我们必须传入两个参数：一个 self和一个 color。这是因为当您使用点表示法从实例调用方法时，Python 知道要自动绑定到哪个实例self。但是，当您使用类中的点表示法调用方法时，Python 不知道Car我们要绘制哪个实例 ，因此我们也要将实例作为参数传入。\n\n### 继承与方法重写\n\n61A讲继承的时候举了一个很有意思的例子，大家小时候都玩过宝可梦吧，让我们来创建一个宝可梦的类\n\n```python\nclass Pokemon:\n    basic_attack = 'tackle'\n    damage = 40\n    def __init__(self, name, trainer):\n        self.name, self.trainer = name, trainer\n        self.level, self.hp = 1, 50\n        self.paralyzed = False\n    def speak(self):\n        print(self.name + '!')\n    def attack(self, other):\n        if not self.paralyzed:\n            self.speak()\n            print(self.name, 'used', self.basic_attack, '!')\n            other.receive_damage(self.damage)\n    def receive_damage(self, damage):\n        self.hp = max(0, self.hp - damage)\n        if self.hp == 0:\n            print(self.name, 'fainted!')   \n```\n\n噢我们可以看见，一个宝可梦类有类属性damage，basic_attack，有实例属性name，level，paralyzed，还有一些类方法。\n\n现在我们再来创建一个电属性的宝可梦类\n\n```python\nclass ElectricType:\n    basic_attack = 'thunder shock'\n    damage = 40\n    prob = 0.1\n    def __init__(self, name, trainer):\n          self.name, self.trainer = name, trainer\n          self.level, self.hp = 1, 50\n          self.paralyzed = False\n    def attack(self, other):\n        self.speak()\n        print(self.name, 'used', self.basic_attack, '!')\n        other.receive_damage(self.damage)\n        if random() < self.prob and type(other) != ElectricType:\n            other.paralyzed = True\n            print(other.name, 'is paralyzed!')\n    def receive_damage(self, damage):\n        self.hp = max(0, self.hp - damage)\n        if self.hp == 0:\n            print(self.name, 'fainted!')   \n```\n\n有些人会说好麻烦，为什么不直接在原来的基础上修改，说的好，这就是继承的概念，我们会发现电属性宝可梦类和宝可梦类只有\n\n类属性部分\n\n```\n prob = 0.1\n```\n\nattack方法\n\n```python\ndef attack(self, other):\n        self.speak()\n        print(self.name, 'used', self.basic_attack, '!')\n        other.receive_damage(self.damage)\n        if random() < self.prob and type(other) != ElectricType:\n            other.paralyzed = True\n            print(other.name, 'is paralyzed!')\n```\n\n这两个模块是不同的，其他都是相同的，所以我们可以这样来写电属性宝可梦类。\n\n```python\nclass ElectricType(Pokemon):\n    basic_attack = 'thunder shock'\n    prob = 0.1\n    def attack(self, other):\n        Pokemon.attack(self, other)\n        if random() < self.prob and type(other) != ElectricType:\n            other.paralyzed = True\n            print(other.name, 'is paralyzed!')\n```\n\n这里的`class <Class Name>(<Superclass Name>):`结构就是继承，通过继承，我们可以在新创建的类中保留下原有的类属性和实例属性\n\n```python\n>>> Pica = ElectricType('pica','me')\n>>> Pica.hp\n50\n```\n\n可以看得出，新类所创建的实例拥有和被继承类相同的实例属性。\n\n我们还可以看到，attack方法被重写了，原来attack的方法被覆盖了，这种情况叫做方法重写，新类可以创建与被继承类相同名称的方法，将会覆盖原有方法.\n\n```python\n>>>Pica.attack(Yib)\n'Yib is paralyzed!'\n```\n\n这时候有人会问，那如果需要增加或删除实例属性项，是不是要重写一遍构造函数？\n\n当然，重写固然没有问题，但是还有更简便的方法。\n\n我们举一个61A Project ant的例子\n\n假设我们有一个昆虫类\n\n```python\nclass Insect(object):\n    \"\"\"An Insect, the base class of Ant and Bee, has armor and a Place.\"\"\"\n    \n    is_ant = False\n    damage = 0\n    is_watersafe = False\n    # ADD CLASS ATTRIBUTES HERE\n\n    def __init__(self, armor, place=None):\n        \"\"\"Create an Insect with an ARMOR amount and a starting PLACE.\"\"\"\n        self.armor = armor\n        self.armor = armor\n        self.place = place  \n\n    def reduce_armor(self, amount):\n        \"\"\"Reduce armor by AMOUNT, and remove the insect from its place if it\n        has no armor remaining.\n\n        >>> test_insect = Insect(5)\n        >>> test_insect.reduce_armor(2)\n        >>> test_insect.armor\n        3\n        \"\"\"\n        self.armor -= amount\n        if self.armor <= 0:\n            self.place.remove_insect(self)\n\n```\n\n接下来我们要创建一个新的Ant类，这个Ant类是Insert类的一个子类，它继承了Insert类的一些方法和属性，不同的是，我们要修改一下Ant类当中amor属性的默认值。\n\n```python\nclass Ant(Insect):\n    \"\"\"An Ant occupies a place and does work for the colony.\"\"\"\n\n    is_ant = True\n    implemented = False  # Only implemented Ant classes should be instantiated\n    food_cost = 0\n    blocks_path = True\n    is_container = False\n    is_double = False\n    # ADD CLASS ATTRIBUTES HERE\n\n    def __init__(self, armor=1):\n        \"\"\"Create an Ant with an ARMOR quantity.\"\"\"\n        Insect.__init__(self, armor)\n\n    def can_contain(self, other):\n        return False\n\n```\n\n我们使用了`Insert.__init__(self,armor=1)`来修改父类的构造函数\n\n我们再以Ant为父类，创建一个名为HungryAnt的子类\n\n```python\nclass HungryAnt(Ant):\n    \"\"\"HungryAnt will take three turns to digest a Bee in its place.\n    While digesting, the HungryAnt can't eat another Bee.\n    \"\"\"\n    name = 'Hungry'\n    food_cost = 4\n    time_to_digest = 3\n    # BEGIN Problem 6\n    implemented = True  # Change to True to view in the GUI\n    # END Problem 6\n\n    def __init__(self, armor=1):\n        # BEGIN Problem 6\n        Ant.__init__(self, armor)\n        self.digesting = 0\n        # END Problem 6\n\n    def eat_bee(self, bee):\n        # BEGIN Problem 6\n        bee.armor = 0\n        self.place.remove_insect(bee)\n        self.digesting = self.time_to_digest\n        # END Problem 6\n\n    def action(self, colony):\n        # BEGIN Problem 6\n        if self.digesting == 0:\n            if random_or_none(self.place.bees) !=None:\n                self.eat_bee(random_or_none(self.place.bees))\n            else:\n                pass\n        else:\n            self.digesting -= 1\n        # END Problem 6\n```\n\n我们看到，这里我们使用`Insert.__init__(self,armor)`继承了父类的所有实例属性，并且在这基础上又增加了一个digesting属性作为该类独有的实例属性。\n\n#### 多重继承\n\n多重继承顾名思义，就是从多个父类继承的子类，比如，作为你父母的孩子，你既继承了你父亲的身高智慧，又继承了你母亲的高鼻梁大眼睛，因此在你这个类当中，既有父亲传给你的属性，又有母亲传给你的属性。\n\nPython 支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。\n\n恩，突然一下子想不出什么特别好的例子，大家可以在CS61A的一些习题当中找一些例子来看。\n\n#### 特殊方法\n\n在 Python 中，某些特殊名称会在特殊情况下由 Python 解释器调用。例如，每当构造对象时，都会自动调用类的__init__方法。每当打印对象时会自动调用__str__方法，在交互式会话到显示值会调用repr方法。\n\n假设我们有一个类A\n\n```python\nclass A:\n    def __init__(self,name,number):\n        self.name = name\n        self.number = number\n    def __str__(self):\n        return '<' + self.name + '>'\n    def __repr__(self):\n        return self.name\n```\n\n那么我们在打印A类所构造的实例对象时，就会自动调用__str__函数打印，交互式对话输入自动调用repr\n\n```python\n>>> a = A('alien',4)\n>>> print(a)\n<alien>\n>>> a\nalien\n```\n\n我们用Link对象举个例子\n\n```python\nclass Link:\n    \"\"\"A linked list.\n\n    >>> s = Link(1)\n    >>> s.first\n    1\n    >>> s.rest is Link.empty\n    True\n    >>> s = Link(2, Link(3, Link(4)))\n    >>> s.first = 5\n    >>> s.rest.first = 6\n    >>> s.rest.rest = Link.empty\n    >>> s                                    # Displays the contents of repr(s)\n    Link(5, Link(6))\n    >>> s.rest = Link(7, Link(Link(8, Link(9))))\n    >>> s\n    Link(5, Link(7, Link(Link(8, Link(9)))))\n    >>> print(s)                             # Prints str(s)\n    <5 7 <8 9>>\n    \"\"\"\n    empty = ()\n\n    def __init__(self, first, rest=empty):\n        assert rest is Link.empty or isinstance(rest, Link)\n        self.first = first\n        self.rest = rest\n\n    def __repr__(self):\n        if self.rest is not Link.empty:\n            rest_repr = ', ' + repr(self.rest)\n        else:\n            rest_repr = ''\n        return 'Link(' + repr(self.first) + rest_repr + ')'\n\n    def __str__(self):\n        string = '<'\n        while self.rest is not Link.empty:\n            string += str(self.first) + ' '\n            self = self.rest\n        return string + str(self.first) + '>'\n```\n\n虽然我们还没有讲到链表类，但是我们可以看到，Link类也重写了str和repr方法，因此Link类实现 方法的实现如下\n\n```python\n>>>s = Link(2, Link(3, Link(4)))\n>>>s\nLink(2, Link(3, Link(4)))\n>>>print(s)\n< 2 3 4>\n```\n\n除了最基本的str和repr特殊方法之外，python也支持对其他特殊方法进行修改，我们这里以contain特殊方法为例进行介绍,contain特殊方会在对实例使用in指令时自动调用\n\n```python\ndef __contains__(self,x):\n    if self.first == x：\n        return True\n    elif self.rest is Link.empty:\n        return False\n    return x in self.rest\n```\n\n这样我们就改写了contain特殊方法\n\n```python\n>>>l=Link(1,Link(2,Link(3)))\n>>>2 in l\nTrue\n>>>4 in l\nFalse\n```\n\n下面是一些常见的特殊方法，大家可以对其进行改写试一试。\n\n![image-20210809105526287](https://i.loli.net/2021/08/09/eG2QDp4y7vlIH9a.png)\n\n\n\n### 递归对象的实现\n\n对象可以有其他对象作为属性值。当某个类的对象具有同一个类的属性值时，它就是递归对象。\n\n常见的递归对象有链表类和树类两种\n\n#### 链表类\n\n本章前面已经提前给出Link类的概念，我们再次回顾一下，链表由第一个元素和列表的其余部分组成，链表的其余部分只能是一个链表，链表是一个序列，它的长度是有限的，并且支持按索引选择元素。\n\n我们可以实现一个Link类，表示一个链表对象。每个Link实例都有两个实例属性，first和rest。\n\n````python\nclass Link:\n    empty = ()\n\n    def __init__(self, first, rest=empty):\n        assert rest is Link.empty or isinstance(rest, Link)\n        self.first = first\n        self.rest = rest\n\n    def __repr__(self):\n        if self.rest is not Link.empty:\n            rest_repr = ', ' + repr(self.rest)\n        else:\n            rest_repr = ''\n        return 'Link(' + repr(self.first) + rest_repr + ')'\n\n    def __str__(self):\n        string = '<'\n        while self.rest is not Link.empty:\n            string += str(self.first) + ' '\n            self = self.rest\n        return string + str(self.first) + '>'\n````\n\n我们可以看出，链表第一个元素没有限制，但是第二个元素只能是一个链表或空链表，由于每个链表的第二个元素都是链表，所以链表是一个递归对象\n\n让我们通过一个例子来进一步加深印象，这道题是61A的题目。\n\n> 编写一个函数store_digits，接收一个整数n并返回一个链表，其中链表的每个元素都是 的一个数字n。\n\n```python\ndef store_digits(n):\n    \"\"\"Stores the digits of a positive number n in a linked list.\n\n    >>> s = store_digits(1)\n    >>> s\n    Link(1)\n    >>> store_digits(2345)\n    Link(2, Link(3, Link(4, Link(5))))\n    >>> store_digits(876)\n    Link(8, Link(7, Link(6)))\n    \"\"\"\n    # In iteration\n    new_link = Link.empty\n    while n !=0:\n        new_link = Link(n%10,new_link)\n        n = n//10\n    return new_link\n```\n\n这道题目就利用了Link递归的特性，通过递归过程对不断加长拓展链表，最终构成一个单一数字的链表。\n\n#### 树类\n\n回想一下，树是一种递归抽象数据类型，它具有label（存储在树根中的值）和branches（根正下方的树列表）两种不同类型的值，在数据抽象一章中，我们曾经使用将树视为列表的构造函数和选择器函数实现过树。\n\n```python\n# Tree ADT\ndef tree(label, branches=[]):\n    \"\"\"Construct a tree with the given label value and a list of branches.\"\"\"\n    for branch in branches:\n        assert is_tree(branch), 'branches must be trees'\n    return [label] + list(branches)\n\ndef label(tree):\n    \"\"\"Return the label value of a tree.\"\"\"\n    return tree[0]\n\ndef branches(tree):\n    \"\"\"Return the list of branches of the given tree.\"\"\"\n    return tree[1:]\n\ndef is_tree(tree):\n    \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\"\n    if type(tree) != list or len(tree) < 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree):\n    \"\"\"Returns True if the given tree's list of branches is empty, and False\n    otherwise.\n    \"\"\"\n    return not branches(tree)\n\ndef print_tree(t, indent=0):\n    \"\"\"Print a representation of this tree in which each node is\n    indented by two spaces times its depth from the root.\n\n    >>> print_tree(tree(1))\n    1\n    >>> print_tree(tree(1, [tree(2)]))\n    1\n      2\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\n    >>> print_tree(numbers)\n    1\n      2\n      3\n        4\n        5\n      6\n        7\n    \"\"\"\n    print('  ' * indent + str(label(t)))\n    for b in branches(t):\n        print_tree(b, indent + 1)\n\ndef copy_tree(t):\n    \"\"\"Returns a copy of t. Only for testing purposes.\n\n    >>> t = tree(5)\n    >>> copy = copy_tree(t)\n    >>> t = tree(6)\n    >>> print_tree(copy)\n    5\n    \"\"\"\n    return tree(label(t), [copy_tree(b) for b in branches(t)])\n```\n\n但是我们会发现使用这种方式创建的树是不可更改的，因为我们无法为调用表达式赋值，为了能够实现对树的修改，我们将构造器的功能用树类实现，而将选择器的功能用访问实例属性的点表达式实现\n\n```python\nclass Tree:\n    \"\"\"\n    >>> t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])\n    >>> t.label\n    3\n    >>> t.branches[0].label\n    2\n    >>> t.branches[1].is_leaf()\n    True\n    \"\"\"\n    def __init__(self, label, branches=[]):\n        for b in branches:\n            assert isinstance(b, Tree)\n        self.label = label\n        self.branches = list(branches)\n\n    def is_leaf(self):\n        return not self.branches\n```\n\n这样一来，我们就可以方便的创建树对象和修改树对象的label和branches属性，而不需要通过调用函数来获得树对象的各项属性，同时我们还可以在树类中任意增加各种方法，同样也只需要对实例进行方法调用即可。\n\n此外，使用构造选择函数和列表实现的树ADT与使用类与对象实现的树ADT还有如下的区别\n\n![image-20210809154119551](https://i.loli.net/2021/08/09/q6QKxZFmIGuWihL.png)\n\n总的来说，利用类实现的树ADT具有可变的特点，因此使用起来要比函数式的ADT更加便捷。\n\n\n\n\n\n\n\n\n\n","slug":"CS61A-对象抽象","published":1,"updated":"2023-02-11T11:15:54.827Z","_id":"cks4bvdqb00046prhaiheadmu","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>面向对象编程（OOP）</p>\n<ul>\n<li>对象和类</li>\n<li>类属性与实例属性</li>\n<li>消息传递与点表达式</li>\n<li>类方法</li>\n</ul>\n<p>继承与方法</p>\n<ul>\n<li>继承与方法重写</li>\n<li>多重继承</li>\n<li>特殊方法</li>\n</ul>\n<p>递归对象的实现</p>\n<ul>\n<li>链表类</li>\n<li>树类</li>\n</ul>\n</blockquote>\n<p>在课程的第一章当中我们提到了使用函数进行抽象，这种方式可以很好的对数据进行处理，然而仅仅只考虑函数式编程往往会产生很多问题，举个例子，假设一家银行仅仅使用变量和函数来对人员的账户进行管理，他们使用xx_money ,xx_name来进行人员账户的登记，利用<code>transfrom()</code>函数进行转账操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tom_money = <span class=\"number\">100</span></span><br><span class=\"line\">Bob_money = <span class=\"number\">200</span></span><br><span class=\"line\">Jef_money = <span class=\"number\">400</span></span><br><span class=\"line\">David_money = <span class=\"number\">500</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span>(<span class=\"params\">from_account,to_account,number</span>):</span></span><br><span class=\"line\">    from_account -= number</span><br><span class=\"line\">    to_account +- number</span><br></pre></td></tr></table></figure>\n\n<p>突然有一天，银行的i系统在调试过程中被某个程序员整崩溃了，重新找回数据的时候变成了这样</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">￥&amp;×.money = <span class=\"number\">100</span></span><br><span class=\"line\">%^&amp;.money = <span class=\"number\">200</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>银行傻眼了，这下怎么区分金额属于谁啊，他们只能重新寻找曾经顾客注册登记用的纸质材料，费了好大的功夫才好不容易将数据恢复了回去，经过这次事件，银行的工作人员开始思考，是不是应该换一种方式对数据进行记录，经过长时间的研究讨论，他们决定使用面向对象的编程方式重新组织和记录数据，从此以后，再也没有出现过类似的事情。</p>\n<p>面向对象OOP，究竟强大在何处？</p>\n<p>接下来我们将对OOP进行深入分析，为大家揭开这个谜底。</p>\n<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3><h4 id=\"对象和类\"><a href=\"#对象和类\" class=\"headerlink\" title=\"对象和类\"></a>对象和类</h4><p>上面我们讲到，利用面向对象的思考方式，我们可以解决银行账户的问题，那么为什么呢？原因就在于，之前银行储存数据时，没有考虑到数据与数据之间的关联性，仅仅只采用了很弱的关系，统一变量名来进行关联，而利用面向对象的思考方式，是将一个账户看做一个对象，每一个变量都是其对象的对象属性。</p>\n<p>什么是对象？对象就是具有同一特征的一类元素，比如，一个人就是一个对象，每个人都有鼻子眼睛嘴巴，而且都能行走和思考，这些具有的同一特征就被称作一个类，类就好像上帝在造人的时候使用的模板。再比如一支笔，无论他是钢笔还是水笔，毛笔，都具有写字这个功能，因此同属于笔这个类，而每一支笔都是一个独立的对象。</p>\n<p>下面我们通过一个例子来具体讲解类和对象，Lab8的这个例子很好，我就直接借用了。</p>\n<p>Tiffany 迟到了，需要在讲座开始前从旧金山赶到伯克利。她会乘坐 BART，但这会花费太长时间。要是有车就好了 一辆巨型卡车会是最好的。</p>\n<p>我们要为Tiffany造一辆汽车，我们首先要创建一个汽车类，用户定义的类是由class语句创建的，它由单个子句组成。class 语句定义类名称，然后包含一组语句来定义类的属性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">car</span>：</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们要对这个类增加一些属性，一辆车有哪些属性呢？品牌，型号，颜色，轮子数，汽油量，那么我们要对这个类附加属性，类的构造函数是一个函数，它创建类所概述的对象的实例或单个实例。在 Python 中，构造函数方法名为init，在Car类的构造函数如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">car</span>:</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, make, model</span>):</span></span><br><span class=\"line\">    self.make = make</span><br><span class=\"line\">    self.model = model</span><br><span class=\"line\">    self.color = <span class=\"string\">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class=\"line\">    self.wheels = Car.num_wheels</span><br><span class=\"line\">    self.gas = Car.gas</span><br></pre></td></tr></table></figure>\n\n<p>该__init__有三个参数。第一个参数self，自动绑定到新创建的Car对象。第二个和第三个参数make和model绑定到传递给构造函数的参数，这意味着当我们创建一个Car对象时，我们必须提供两个参数。</p>\n<p>于是，汽车这个类我们就构造完毕了，让我们开始造我们的车。蒂芙尼想开一辆特斯拉 Model S 去上课。所以我们可以构造一个厂家为“Tesla”，型号为“Model S”的汽车实例，Python 允许我们通过类的名称来创建类的实例，而不是显式调用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car = Car(<span class=\"string\">&#x27;Tesla&#x27;</span>, <span class=\"string\">&#x27;Model S&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在这里，’Tesla’作为 make传入，“Model S”作为model传入， 请注意，我们没有传递参数self，因为它的值始终是正在创建的对象，一个对象是类的一个实例。在这种情况下， tiffanys_car现在绑定到一个Car对象，或者换句话说，绑定到Car类的一个实例。</p>\n<p>这样，我们就创建了一个Car类，并且通过Car类创建了一个tiffanys_car的实例对象。</p>\n<h4 id=\"实例属性与类属性\"><a href=\"#实例属性与类属性\" class=\"headerlink\" title=\"实例属性与类属性\"></a>实例属性与类属性</h4><p>我们继续来看我们上面创建的Car类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    num_wheels = <span class=\"number\">4</span></span><br><span class=\"line\">    gas = <span class=\"number\">30</span></span><br><span class=\"line\">    headlights = <span class=\"number\">2</span></span><br><span class=\"line\">    size = <span class=\"string\">&#x27;Tiny&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, make, model</span>):</span></span><br><span class=\"line\">        self.make = make</span><br><span class=\"line\">        self.model = model</span><br><span class=\"line\">        self.color = <span class=\"string\">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class=\"line\">        self.wheels = Car.num_wheels</span><br><span class=\"line\">        self.gas = Car.gas</span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，诶，除了我们刚刚利用构造函数所创建的属性，上面怎么还多了几行？</p>\n<p>这里就涉及到实例属性和类属性两个概念了，什么是类属性？类属性就是同属于一个类的对象所共有的属性 ，比如，只要是汽车，肯定都是四个轮子，两个头灯，一个后备箱，这些是所有汽车共有的属性，所以被称作类属性。而不同的汽车有不同的型号，品牌，颜色和汽油量，因此这些属性就被称作实例属性。每创建一个实例对象，都会自动将类属性附加给该实例。</p>\n<h4 id=\"消息传递与点表达式\"><a href=\"#消息传递与点表达式\" class=\"headerlink\" title=\"消息传递与点表达式\"></a>消息传递与点表达式</h4><p>上面，我们为tiffany造了一辆车，但如果有一天，tiffany说，我不想开Tesla了，我想换辆Benz开开，那该怎么办呢？我们当然可以重新利用Car类创造一个新的实例对象，但这太麻烦了，有没有什么办法可以对已有的车辆属性进行改变呢？</p>\n<p>有的，利用点符号就可以。</p>\n<p>例如，我们可以访问Car类的类属性size</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Car.size</span><br><span class=\"line\"><span class=\"string\">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>同样也可以对Car类的属性进行改变</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Car.size = <span class=\"string\">&#x27;Big&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>对实例属性的改变也是同样如此，在以下行中，我们访问tiffanys_car的make属性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt; tiffanys_car.make </span><br><span class=\"line\"><span class=\"string\">&#x27;Tesla&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>而后我们将make属性修改为‘Benz’:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car.make = <span class=\"string\">&#x27;Benz&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就成功改造了tiffany的车子，是不是很简单呢？</p>\n<h4 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h4><p>让我们再为Car类增加一些东西</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    num_wheels = <span class=\"number\">4</span></span><br><span class=\"line\">    gas = <span class=\"number\">30</span></span><br><span class=\"line\">    headlights = <span class=\"number\">2</span></span><br><span class=\"line\">    size = <span class=\"string\">&#x27;Tiny&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, make, model</span>):</span></span><br><span class=\"line\">        self.make = make</span><br><span class=\"line\">        self.model = model</span><br><span class=\"line\">        self.color = <span class=\"string\">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class=\"line\">        self.wheels = Car.num_wheels</span><br><span class=\"line\">        self.gas = Car.gas</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">paint</span>(<span class=\"params\">self, color</span>):</span></span><br><span class=\"line\">        self.color = color</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.make + <span class=\"string\">&#x27; &#x27;</span> + self.model + <span class=\"string\">&#x27; is now &#x27;</span> + color</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">drive</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.wheels &lt; Car.num_wheels <span class=\"keyword\">or</span> self.gas &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Cannot drive!&#x27;</span></span><br><span class=\"line\">        self.gas -= <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.make + <span class=\"string\">&#x27; &#x27;</span> + self.model + <span class=\"string\">&#x27; goes vroom!&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop_tire</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.wheels &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.wheels -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fill_gas</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.gas += <span class=\"number\">20</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Gas level: &#x27;</span> + <span class=\"built_in\">str</span>(self.gas)</span><br></pre></td></tr></table></figure>\n\n<p>这些def叫做类的方法，他们可以调用类的属性，并且输出给外界。方法是特定于类的函数，只有类的一个实例可以使用它们，那么，我们如何在实例上调用方法？你猜对了，点符号！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car.paint(<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Tesla Model S is now black&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car.color</span><br><span class=\"line\"><span class=\"string\">&#x27;black&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面是一个调用paint方法的过程，我们仔细看一下这个方法，它需要两个参数，那么为什么我们不需要传递两个参数呢？就好像我们在init构造函数中看到的那样，一个类的所有方法都有一个self参数，python会自动将调用该方法的实例绑定到该参数，在这里，self绑定到tiffanys_car这个实例，并调用paint函数改变实例属性</p>\n<p>您还可以使用类名和点符号来调用方法；例如，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Car.paint(tiffanys_car, <span class=\"string\">&#x27;red&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Tesla Model S is now red&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，与我们将 Tiffany 的汽车漆成黑色不同，这次我们必须传入两个参数：一个 self和一个 color。这是因为当您使用点表示法从实例调用方法时，Python 知道要自动绑定到哪个实例self。但是，当您使用类中的点表示法调用方法时，Python 不知道Car我们要绘制哪个实例 ，因此我们也要将实例作为参数传入。</p>\n<h3 id=\"继承与方法重写\"><a href=\"#继承与方法重写\" class=\"headerlink\" title=\"继承与方法重写\"></a>继承与方法重写</h3><p>61A讲继承的时候举了一个很有意思的例子，大家小时候都玩过宝可梦吧，让我们来创建一个宝可梦的类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pokemon</span>:</span></span><br><span class=\"line\">    basic_attack = <span class=\"string\">&#x27;tackle&#x27;</span></span><br><span class=\"line\">    damage = <span class=\"number\">40</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, trainer</span>):</span></span><br><span class=\"line\">        self.name, self.trainer = name, trainer</span><br><span class=\"line\">        self.level, self.hp = <span class=\"number\">1</span>, <span class=\"number\">50</span></span><br><span class=\"line\">        self.paralyzed = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">speak</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.name + <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.paralyzed:</span><br><span class=\"line\">            self.speak()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;used&#x27;</span>, self.basic_attack, <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">            other.receive_damage(self.damage)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">receive_damage</span>(<span class=\"params\">self, damage</span>):</span></span><br><span class=\"line\">        self.hp = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, self.hp - damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.hp == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure>\n\n<p>噢我们可以看见，一个宝可梦类有类属性damage，basic_attack，有实例属性name，level，paralyzed，还有一些类方法。</p>\n<p>现在我们再来创建一个电属性的宝可梦类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElectricType</span>:</span></span><br><span class=\"line\">    basic_attack = <span class=\"string\">&#x27;thunder shock&#x27;</span></span><br><span class=\"line\">    damage = <span class=\"number\">40</span></span><br><span class=\"line\">    prob = <span class=\"number\">0.1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, trainer</span>):</span></span><br><span class=\"line\">          self.name, self.trainer = name, trainer</span><br><span class=\"line\">          self.level, self.hp = <span class=\"number\">1</span>, <span class=\"number\">50</span></span><br><span class=\"line\">          self.paralyzed = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        self.speak()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;used&#x27;</span>, self.basic_attack, <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">        other.receive_damage(self.damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random() &lt; self.prob <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(other) != ElectricType:</span><br><span class=\"line\">            other.paralyzed = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(other.name, <span class=\"string\">&#x27;is paralyzed!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">receive_damage</span>(<span class=\"params\">self, damage</span>):</span></span><br><span class=\"line\">        self.hp = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, self.hp - damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.hp == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure>\n\n<p>有些人会说好麻烦，为什么不直接在原来的基础上修改，说的好，这就是继承的概念，我们会发现电属性宝可梦类和宝可梦类只有</p>\n<p>类属性部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prob &#x3D; 0.1</span><br></pre></td></tr></table></figure>\n\n<p>attack方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        self.speak()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;used&#x27;</span>, self.basic_attack, <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">        other.receive_damage(self.damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random() &lt; self.prob <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(other) != ElectricType:</span><br><span class=\"line\">            other.paralyzed = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(other.name, <span class=\"string\">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这两个模块是不同的，其他都是相同的，所以我们可以这样来写电属性宝可梦类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElectricType</span>(<span class=\"params\">Pokemon</span>):</span></span><br><span class=\"line\">    basic_attack = <span class=\"string\">&#x27;thunder shock&#x27;</span></span><br><span class=\"line\">    prob = <span class=\"number\">0.1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        Pokemon.attack(self, other)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random() &lt; self.prob <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(other) != ElectricType:</span><br><span class=\"line\">            other.paralyzed = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(other.name, <span class=\"string\">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>class &lt;Class Name&gt;(&lt;Superclass Name&gt;):</code>结构就是继承，通过继承，我们可以在新创建的类中保留下原有的类属性和实例属性</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Pica = ElectricType(<span class=\"string\">&#x27;pica&#x27;</span>,<span class=\"string\">&#x27;me&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Pica.hp</span><br><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看得出，新类所创建的实例拥有和被继承类相同的实例属性。</p>\n<p>我们还可以看到，attack方法被重写了，原来attack的方法被覆盖了，这种情况叫做方法重写，新类可以创建与被继承类相同名称的方法，将会覆盖原有方法.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;Pica.attack(Yib)</span><br><span class=\"line\"><span class=\"string\">&#x27;Yib is paralyzed!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候有人会问，那如果需要增加或删除实例属性项，是不是要重写一遍构造函数？</p>\n<p>当然，重写固然没有问题，但是还有更简便的方法。</p>\n<p>我们举一个61A Project ant的例子</p>\n<p>假设我们有一个昆虫类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Insect</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An Insect, the base class of Ant and Bee, has armor and a Place.&quot;&quot;&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    is_ant = <span class=\"literal\">False</span></span><br><span class=\"line\">    damage = <span class=\"number\">0</span></span><br><span class=\"line\">    is_watersafe = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, armor, place=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Create an Insect with an ARMOR amount and a starting PLACE.&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.armor = armor</span><br><span class=\"line\">        self.armor = armor</span><br><span class=\"line\">        self.place = place  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reduce_armor</span>(<span class=\"params\">self, amount</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Reduce armor by AMOUNT, and remove the insect from its place if it</span></span><br><span class=\"line\"><span class=\"string\">        has no armor remaining.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; test_insect = Insect(5)</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; test_insect.reduce_armor(2)</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; test_insect.armor</span></span><br><span class=\"line\"><span class=\"string\">        3</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        self.armor -= amount</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.armor &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.place.remove_insect(self)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们要创建一个新的Ant类，这个Ant类是Insert类的一个子类，它继承了Insert类的一些方法和属性，不同的是，我们要修改一下Ant类当中amor属性的默认值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ant</span>(<span class=\"params\">Insect</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An Ant occupies a place and does work for the colony.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    is_ant = <span class=\"literal\">True</span></span><br><span class=\"line\">    implemented = <span class=\"literal\">False</span>  <span class=\"comment\"># Only implemented Ant classes should be instantiated</span></span><br><span class=\"line\">    food_cost = <span class=\"number\">0</span></span><br><span class=\"line\">    blocks_path = <span class=\"literal\">True</span></span><br><span class=\"line\">    is_container = <span class=\"literal\">False</span></span><br><span class=\"line\">    is_double = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, armor=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Create an Ant with an ARMOR quantity.&quot;&quot;&quot;</span></span><br><span class=\"line\">        Insect.__init__(self, armor)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">can_contain</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用了<code>Insert.__init__(self,armor=1)</code>来修改父类的构造函数</p>\n<p>我们再以Ant为父类，创建一个名为HungryAnt的子类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungryAnt</span>(<span class=\"params\">Ant</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;HungryAnt will take three turns to digest a Bee in its place.</span></span><br><span class=\"line\"><span class=\"string\">    While digesting, the HungryAnt can&#x27;t eat another Bee.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;Hungry&#x27;</span></span><br><span class=\"line\">    food_cost = <span class=\"number\">4</span></span><br><span class=\"line\">    time_to_digest = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">    implemented = <span class=\"literal\">True</span>  <span class=\"comment\"># Change to True to view in the GUI</span></span><br><span class=\"line\">    <span class=\"comment\"># END Problem 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, armor=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">        Ant.__init__(self, armor)</span><br><span class=\"line\">        self.digesting = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># END Problem 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eat_bee</span>(<span class=\"params\">self, bee</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">        bee.armor = <span class=\"number\">0</span></span><br><span class=\"line\">        self.place.remove_insect(bee)</span><br><span class=\"line\">        self.digesting = self.time_to_digest</span><br><span class=\"line\">        <span class=\"comment\"># END Problem 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">action</span>(<span class=\"params\">self, colony</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.digesting == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> random_or_none(self.place.bees) !=<span class=\"literal\">None</span>:</span><br><span class=\"line\">                self.eat_bee(random_or_none(self.place.bees))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.digesting -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># END Problem 6</span></span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这里我们使用<code>Insert.__init__(self,armor)</code>继承了父类的所有实例属性，并且在这基础上又增加了一个digesting属性作为该类独有的实例属性。</p>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><p>多重继承顾名思义，就是从多个父类继承的子类，比如，作为你父母的孩子，你既继承了你父亲的身高智慧，又继承了你母亲的高鼻梁大眼睛，因此在你这个类当中，既有父亲传给你的属性，又有母亲传给你的属性。</p>\n<p>Python 支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。</p>\n<p>恩，突然一下子想不出什么特别好的例子，大家可以在CS61A的一些习题当中找一些例子来看。</p>\n<h4 id=\"特殊方法\"><a href=\"#特殊方法\" class=\"headerlink\" title=\"特殊方法\"></a>特殊方法</h4><p>在 Python 中，某些特殊名称会在特殊情况下由 Python 解释器调用。例如，每当构造对象时，都会自动调用类的__init__方法。每当打印对象时会自动调用__str__方法，在交互式会话到显示值会调用repr方法。</p>\n<p>假设我们有一个类A</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,number</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;&#x27;</span> + self.name + <span class=\"string\">&#x27;&gt;&#x27;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.name</span><br></pre></td></tr></table></figure>\n\n<p>那么我们在打印A类所构造的实例对象时，就会自动调用__str__函数打印，交互式对话输入自动调用repr</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = A(<span class=\"string\">&#x27;alien&#x27;</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&lt;alien&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">alien</span><br></pre></td></tr></table></figure>\n\n<p>我们用Link对象举个例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Link</span>:</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A linked list.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = Link(1)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.first</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest is Link.empty</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.first = 5</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest.first = 6</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest.rest = Link.empty</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)</span></span><br><span class=\"line\"><span class=\"string\">    Link(5, Link(6))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s</span></span><br><span class=\"line\"><span class=\"string\">    Link(5, Link(7, Link(Link(8, Link(9)))))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print(s)                             # Prints str(s)</span></span><br><span class=\"line\"><span class=\"string\">    &lt;5 7 &lt;8 9&gt;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    empty = ()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, first, rest=empty</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> rest <span class=\"keyword\">is</span> Link.empty <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(rest, Link)</span><br><span class=\"line\">        self.first = first</span><br><span class=\"line\">        self.rest = rest</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"built_in\">repr</span>(self.rest)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Link(&#x27;</span> + <span class=\"built_in\">repr</span>(self.first) + rest_repr + <span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        string = <span class=\"string\">&#x27;&lt;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            string += <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27; &#x27;</span></span><br><span class=\"line\">            self = self.rest</span><br><span class=\"line\">        <span class=\"keyword\">return</span> string + <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然我们还没有讲到链表类，但是我们可以看到，Link类也重写了str和repr方法，因此Link类实现 方法的实现如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;s = Link(<span class=\"number\">2</span>, Link(<span class=\"number\">3</span>, Link(<span class=\"number\">4</span>)))</span><br><span class=\"line\">&gt;&gt;&gt;s</span><br><span class=\"line\">Link(<span class=\"number\">2</span>, Link(<span class=\"number\">3</span>, Link(<span class=\"number\">4</span>)))</span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">print</span>(s)</span><br><span class=\"line\">&lt; <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>除了最基本的str和repr特殊方法之外，python也支持对其他特殊方法进行修改，我们这里以contain特殊方法为例进行介绍,contain特殊方会在对实例使用in指令时自动调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__contains__</span>(<span class=\"params\">self,x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.first == x：</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> self.rest <span class=\"keyword\">is</span> Link.empty:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x <span class=\"keyword\">in</span> self.rest</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就改写了contain特殊方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;l=Link(<span class=\"number\">1</span>,Link(<span class=\"number\">2</span>,Link(<span class=\"number\">3</span>)))</span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"number\">2</span> <span class=\"keyword\">in</span> l</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"number\">4</span> <span class=\"keyword\">in</span> l</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是一些常见的特殊方法，大家可以对其进行改写试一试。</p>\n<p><img src=\"https://i.loli.net/2021/08/09/eG2QDp4y7vlIH9a.png\" alt=\"image-20210809105526287\"></p>\n<h3 id=\"递归对象的实现\"><a href=\"#递归对象的实现\" class=\"headerlink\" title=\"递归对象的实现\"></a>递归对象的实现</h3><p>对象可以有其他对象作为属性值。当某个类的对象具有同一个类的属性值时，它就是递归对象。</p>\n<p>常见的递归对象有链表类和树类两种</p>\n<h4 id=\"链表类\"><a href=\"#链表类\" class=\"headerlink\" title=\"链表类\"></a>链表类</h4><p>本章前面已经提前给出Link类的概念，我们再次回顾一下，链表由第一个元素和列表的其余部分组成，链表的其余部分只能是一个链表，链表是一个序列，它的长度是有限的，并且支持按索引选择元素。</p>\n<p>我们可以实现一个Link类，表示一个链表对象。每个Link实例都有两个实例属性，first和rest。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Link</span>:</span></span><br><span class=\"line\">    empty = ()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, first, rest=empty</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> rest <span class=\"keyword\">is</span> Link.empty <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(rest, Link)</span><br><span class=\"line\">        self.first = first</span><br><span class=\"line\">        self.rest = rest</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"built_in\">repr</span>(self.rest)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Link(&#x27;</span> + <span class=\"built_in\">repr</span>(self.first) + rest_repr + <span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        string = <span class=\"string\">&#x27;&lt;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            string += <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27; &#x27;</span></span><br><span class=\"line\">            self = self.rest</span><br><span class=\"line\">        <span class=\"keyword\">return</span> string + <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，链表第一个元素没有限制，但是第二个元素只能是一个链表或空链表，由于每个链表的第二个元素都是链表，所以链表是一个递归对象</p>\n<p>让我们通过一个例子来进一步加深印象，这道题是61A的题目。</p>\n<blockquote>\n<p>编写一个函数store_digits，接收一个整数n并返回一个链表，其中链表的每个元素都是 的一个数字n。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">store_digits</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Stores the digits of a positive number n in a linked list.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = store_digits(1)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s</span></span><br><span class=\"line\"><span class=\"string\">    Link(1)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; store_digits(2345)</span></span><br><span class=\"line\"><span class=\"string\">    Link(2, Link(3, Link(4, Link(5))))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; store_digits(876)</span></span><br><span class=\"line\"><span class=\"string\">    Link(8, Link(7, Link(6)))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># In iteration</span></span><br><span class=\"line\">    new_link = Link.empty</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n !=<span class=\"number\">0</span>:</span><br><span class=\"line\">        new_link = Link(n%<span class=\"number\">10</span>,new_link)</span><br><span class=\"line\">        n = n//<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_link</span><br></pre></td></tr></table></figure>\n\n<p>这道题目就利用了Link递归的特性，通过递归过程对不断加长拓展链表，最终构成一个单一数字的链表。</p>\n<h4 id=\"树类\"><a href=\"#树类\" class=\"headerlink\" title=\"树类\"></a>树类</h4><p>回想一下，树是一种递归抽象数据类型，它具有label（存储在树根中的值）和branches（根正下方的树列表）两种不同类型的值，在数据抽象一章中，我们曾经使用将树视为列表的构造函数和选择器函数实现过树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Tree ADT</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tree</span>(<span class=\"params\">label, branches=[]</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> is_tree(branch), <span class=\"string\">&#x27;branches must be trees&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [label] + <span class=\"built_in\">list</span>(branches)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">label</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">branches</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_tree</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(tree) != <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">len</span>(tree) &lt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches(tree):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> is_tree(branch):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_leaf</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span><br><span class=\"line\"><span class=\"string\">    otherwise.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> branches(tree)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_tree</span>(<span class=\"params\">t, indent=<span class=\"number\">0</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span><br><span class=\"line\"><span class=\"string\">    indented by two spaces times its depth from the root.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1))</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(numbers)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">      3</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\">      6</span></span><br><span class=\"line\"><span class=\"string\">        7</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;  &#x27;</span> * indent + <span class=\"built_in\">str</span>(label(t)))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t):</span><br><span class=\"line\">        print_tree(b, indent + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">copy_tree</span>(<span class=\"params\">t</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns a copy of t. Only for testing purposes.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t = tree(5)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; copy = copy_tree(t)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t = tree(6)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(copy)</span></span><br><span class=\"line\"><span class=\"string\">    5</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree(label(t), [copy_tree(b) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t)])</span><br></pre></td></tr></table></figure>\n\n<p>但是我们会发现使用这种方式创建的树是不可更改的，因为我们无法为调用表达式赋值，为了能够实现对树的修改，我们将构造器的功能用树类实现，而将选择器的功能用访问实例属性的点表达式实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span>:</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t.label</span></span><br><span class=\"line\"><span class=\"string\">    3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t.branches[0].label</span></span><br><span class=\"line\"><span class=\"string\">    2</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t.branches[1].is_leaf()</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, label, branches=[]</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches:</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(b, Tree)</span><br><span class=\"line\">        self.label = label</span><br><span class=\"line\">        self.branches = <span class=\"built_in\">list</span>(branches)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_leaf</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.branches</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们就可以方便的创建树对象和修改树对象的label和branches属性，而不需要通过调用函数来获得树对象的各项属性，同时我们还可以在树类中任意增加各种方法，同样也只需要对实例进行方法调用即可。</p>\n<p>此外，使用构造选择函数和列表实现的树ADT与使用类与对象实现的树ADT还有如下的区别</p>\n<p><img src=\"https://i.loli.net/2021/08/09/q6QKxZFmIGuWihL.png\" alt=\"image-20210809154119551\"></p>\n<p>总的来说，利用类实现的树ADT具有可变的特点，因此使用起来要比函数式的ADT更加便捷。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":14220,"excerpt":"","more":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>面向对象编程（OOP）</p>\n<ul>\n<li>对象和类</li>\n<li>类属性与实例属性</li>\n<li>消息传递与点表达式</li>\n<li>类方法</li>\n</ul>\n<p>继承与方法</p>\n<ul>\n<li>继承与方法重写</li>\n<li>多重继承</li>\n<li>特殊方法</li>\n</ul>\n<p>递归对象的实现</p>\n<ul>\n<li>链表类</li>\n<li>树类</li>\n</ul>\n</blockquote>\n<p>在课程的第一章当中我们提到了使用函数进行抽象，这种方式可以很好的对数据进行处理，然而仅仅只考虑函数式编程往往会产生很多问题，举个例子，假设一家银行仅仅使用变量和函数来对人员的账户进行管理，他们使用xx_money ,xx_name来进行人员账户的登记，利用<code>transfrom()</code>函数进行转账操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tom_money = <span class=\"number\">100</span></span><br><span class=\"line\">Bob_money = <span class=\"number\">200</span></span><br><span class=\"line\">Jef_money = <span class=\"number\">400</span></span><br><span class=\"line\">David_money = <span class=\"number\">500</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span>(<span class=\"params\">from_account,to_account,number</span>):</span></span><br><span class=\"line\">    from_account -= number</span><br><span class=\"line\">    to_account +- number</span><br></pre></td></tr></table></figure>\n\n<p>突然有一天，银行的i系统在调试过程中被某个程序员整崩溃了，重新找回数据的时候变成了这样</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">￥&amp;×.money = <span class=\"number\">100</span></span><br><span class=\"line\">%^&amp;.money = <span class=\"number\">200</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>银行傻眼了，这下怎么区分金额属于谁啊，他们只能重新寻找曾经顾客注册登记用的纸质材料，费了好大的功夫才好不容易将数据恢复了回去，经过这次事件，银行的工作人员开始思考，是不是应该换一种方式对数据进行记录，经过长时间的研究讨论，他们决定使用面向对象的编程方式重新组织和记录数据，从此以后，再也没有出现过类似的事情。</p>\n<p>面向对象OOP，究竟强大在何处？</p>\n<p>接下来我们将对OOP进行深入分析，为大家揭开这个谜底。</p>\n<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3><h4 id=\"对象和类\"><a href=\"#对象和类\" class=\"headerlink\" title=\"对象和类\"></a>对象和类</h4><p>上面我们讲到，利用面向对象的思考方式，我们可以解决银行账户的问题，那么为什么呢？原因就在于，之前银行储存数据时，没有考虑到数据与数据之间的关联性，仅仅只采用了很弱的关系，统一变量名来进行关联，而利用面向对象的思考方式，是将一个账户看做一个对象，每一个变量都是其对象的对象属性。</p>\n<p>什么是对象？对象就是具有同一特征的一类元素，比如，一个人就是一个对象，每个人都有鼻子眼睛嘴巴，而且都能行走和思考，这些具有的同一特征就被称作一个类，类就好像上帝在造人的时候使用的模板。再比如一支笔，无论他是钢笔还是水笔，毛笔，都具有写字这个功能，因此同属于笔这个类，而每一支笔都是一个独立的对象。</p>\n<p>下面我们通过一个例子来具体讲解类和对象，Lab8的这个例子很好，我就直接借用了。</p>\n<p>Tiffany 迟到了，需要在讲座开始前从旧金山赶到伯克利。她会乘坐 BART，但这会花费太长时间。要是有车就好了 一辆巨型卡车会是最好的。</p>\n<p>我们要为Tiffany造一辆汽车，我们首先要创建一个汽车类，用户定义的类是由class语句创建的，它由单个子句组成。class 语句定义类名称，然后包含一组语句来定义类的属性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">car</span>：</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们要对这个类增加一些属性，一辆车有哪些属性呢？品牌，型号，颜色，轮子数，汽油量，那么我们要对这个类附加属性，类的构造函数是一个函数，它创建类所概述的对象的实例或单个实例。在 Python 中，构造函数方法名为init，在Car类的构造函数如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">car</span>:</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, make, model</span>):</span></span><br><span class=\"line\">    self.make = make</span><br><span class=\"line\">    self.model = model</span><br><span class=\"line\">    self.color = <span class=\"string\">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class=\"line\">    self.wheels = Car.num_wheels</span><br><span class=\"line\">    self.gas = Car.gas</span><br></pre></td></tr></table></figure>\n\n<p>该__init__有三个参数。第一个参数self，自动绑定到新创建的Car对象。第二个和第三个参数make和model绑定到传递给构造函数的参数，这意味着当我们创建一个Car对象时，我们必须提供两个参数。</p>\n<p>于是，汽车这个类我们就构造完毕了，让我们开始造我们的车。蒂芙尼想开一辆特斯拉 Model S 去上课。所以我们可以构造一个厂家为“Tesla”，型号为“Model S”的汽车实例，Python 允许我们通过类的名称来创建类的实例，而不是显式调用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car = Car(<span class=\"string\">&#x27;Tesla&#x27;</span>, <span class=\"string\">&#x27;Model S&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在这里，’Tesla’作为 make传入，“Model S”作为model传入， 请注意，我们没有传递参数self，因为它的值始终是正在创建的对象，一个对象是类的一个实例。在这种情况下， tiffanys_car现在绑定到一个Car对象，或者换句话说，绑定到Car类的一个实例。</p>\n<p>这样，我们就创建了一个Car类，并且通过Car类创建了一个tiffanys_car的实例对象。</p>\n<h4 id=\"实例属性与类属性\"><a href=\"#实例属性与类属性\" class=\"headerlink\" title=\"实例属性与类属性\"></a>实例属性与类属性</h4><p>我们继续来看我们上面创建的Car类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    num_wheels = <span class=\"number\">4</span></span><br><span class=\"line\">    gas = <span class=\"number\">30</span></span><br><span class=\"line\">    headlights = <span class=\"number\">2</span></span><br><span class=\"line\">    size = <span class=\"string\">&#x27;Tiny&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, make, model</span>):</span></span><br><span class=\"line\">        self.make = make</span><br><span class=\"line\">        self.model = model</span><br><span class=\"line\">        self.color = <span class=\"string\">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class=\"line\">        self.wheels = Car.num_wheels</span><br><span class=\"line\">        self.gas = Car.gas</span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，诶，除了我们刚刚利用构造函数所创建的属性，上面怎么还多了几行？</p>\n<p>这里就涉及到实例属性和类属性两个概念了，什么是类属性？类属性就是同属于一个类的对象所共有的属性 ，比如，只要是汽车，肯定都是四个轮子，两个头灯，一个后备箱，这些是所有汽车共有的属性，所以被称作类属性。而不同的汽车有不同的型号，品牌，颜色和汽油量，因此这些属性就被称作实例属性。每创建一个实例对象，都会自动将类属性附加给该实例。</p>\n<h4 id=\"消息传递与点表达式\"><a href=\"#消息传递与点表达式\" class=\"headerlink\" title=\"消息传递与点表达式\"></a>消息传递与点表达式</h4><p>上面，我们为tiffany造了一辆车，但如果有一天，tiffany说，我不想开Tesla了，我想换辆Benz开开，那该怎么办呢？我们当然可以重新利用Car类创造一个新的实例对象，但这太麻烦了，有没有什么办法可以对已有的车辆属性进行改变呢？</p>\n<p>有的，利用点符号就可以。</p>\n<p>例如，我们可以访问Car类的类属性size</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Car.size</span><br><span class=\"line\"><span class=\"string\">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>同样也可以对Car类的属性进行改变</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Car.size = <span class=\"string\">&#x27;Big&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>对实例属性的改变也是同样如此，在以下行中，我们访问tiffanys_car的make属性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt; tiffanys_car.make </span><br><span class=\"line\"><span class=\"string\">&#x27;Tesla&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>而后我们将make属性修改为‘Benz’:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car.make = <span class=\"string\">&#x27;Benz&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就成功改造了tiffany的车子，是不是很简单呢？</p>\n<h4 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h4><p>让我们再为Car类增加一些东西</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    num_wheels = <span class=\"number\">4</span></span><br><span class=\"line\">    gas = <span class=\"number\">30</span></span><br><span class=\"line\">    headlights = <span class=\"number\">2</span></span><br><span class=\"line\">    size = <span class=\"string\">&#x27;Tiny&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, make, model</span>):</span></span><br><span class=\"line\">        self.make = make</span><br><span class=\"line\">        self.model = model</span><br><span class=\"line\">        self.color = <span class=\"string\">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class=\"line\">        self.wheels = Car.num_wheels</span><br><span class=\"line\">        self.gas = Car.gas</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">paint</span>(<span class=\"params\">self, color</span>):</span></span><br><span class=\"line\">        self.color = color</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.make + <span class=\"string\">&#x27; &#x27;</span> + self.model + <span class=\"string\">&#x27; is now &#x27;</span> + color</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">drive</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.wheels &lt; Car.num_wheels <span class=\"keyword\">or</span> self.gas &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Cannot drive!&#x27;</span></span><br><span class=\"line\">        self.gas -= <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.make + <span class=\"string\">&#x27; &#x27;</span> + self.model + <span class=\"string\">&#x27; goes vroom!&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop_tire</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.wheels &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.wheels -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fill_gas</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.gas += <span class=\"number\">20</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Gas level: &#x27;</span> + <span class=\"built_in\">str</span>(self.gas)</span><br></pre></td></tr></table></figure>\n\n<p>这些def叫做类的方法，他们可以调用类的属性，并且输出给外界。方法是特定于类的函数，只有类的一个实例可以使用它们，那么，我们如何在实例上调用方法？你猜对了，点符号！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car.paint(<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Tesla Model S is now black&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>tiffanys_car.color</span><br><span class=\"line\"><span class=\"string\">&#x27;black&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面是一个调用paint方法的过程，我们仔细看一下这个方法，它需要两个参数，那么为什么我们不需要传递两个参数呢？就好像我们在init构造函数中看到的那样，一个类的所有方法都有一个self参数，python会自动将调用该方法的实例绑定到该参数，在这里，self绑定到tiffanys_car这个实例，并调用paint函数改变实例属性</p>\n<p>您还可以使用类名和点符号来调用方法；例如，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Car.paint(tiffanys_car, <span class=\"string\">&#x27;red&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Tesla Model S is now red&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，与我们将 Tiffany 的汽车漆成黑色不同，这次我们必须传入两个参数：一个 self和一个 color。这是因为当您使用点表示法从实例调用方法时，Python 知道要自动绑定到哪个实例self。但是，当您使用类中的点表示法调用方法时，Python 不知道Car我们要绘制哪个实例 ，因此我们也要将实例作为参数传入。</p>\n<h3 id=\"继承与方法重写\"><a href=\"#继承与方法重写\" class=\"headerlink\" title=\"继承与方法重写\"></a>继承与方法重写</h3><p>61A讲继承的时候举了一个很有意思的例子，大家小时候都玩过宝可梦吧，让我们来创建一个宝可梦的类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pokemon</span>:</span></span><br><span class=\"line\">    basic_attack = <span class=\"string\">&#x27;tackle&#x27;</span></span><br><span class=\"line\">    damage = <span class=\"number\">40</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, trainer</span>):</span></span><br><span class=\"line\">        self.name, self.trainer = name, trainer</span><br><span class=\"line\">        self.level, self.hp = <span class=\"number\">1</span>, <span class=\"number\">50</span></span><br><span class=\"line\">        self.paralyzed = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">speak</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.name + <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.paralyzed:</span><br><span class=\"line\">            self.speak()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;used&#x27;</span>, self.basic_attack, <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">            other.receive_damage(self.damage)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">receive_damage</span>(<span class=\"params\">self, damage</span>):</span></span><br><span class=\"line\">        self.hp = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, self.hp - damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.hp == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure>\n\n<p>噢我们可以看见，一个宝可梦类有类属性damage，basic_attack，有实例属性name，level，paralyzed，还有一些类方法。</p>\n<p>现在我们再来创建一个电属性的宝可梦类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElectricType</span>:</span></span><br><span class=\"line\">    basic_attack = <span class=\"string\">&#x27;thunder shock&#x27;</span></span><br><span class=\"line\">    damage = <span class=\"number\">40</span></span><br><span class=\"line\">    prob = <span class=\"number\">0.1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, trainer</span>):</span></span><br><span class=\"line\">          self.name, self.trainer = name, trainer</span><br><span class=\"line\">          self.level, self.hp = <span class=\"number\">1</span>, <span class=\"number\">50</span></span><br><span class=\"line\">          self.paralyzed = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        self.speak()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;used&#x27;</span>, self.basic_attack, <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">        other.receive_damage(self.damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random() &lt; self.prob <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(other) != ElectricType:</span><br><span class=\"line\">            other.paralyzed = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(other.name, <span class=\"string\">&#x27;is paralyzed!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">receive_damage</span>(<span class=\"params\">self, damage</span>):</span></span><br><span class=\"line\">        self.hp = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, self.hp - damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.hp == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure>\n\n<p>有些人会说好麻烦，为什么不直接在原来的基础上修改，说的好，这就是继承的概念，我们会发现电属性宝可梦类和宝可梦类只有</p>\n<p>类属性部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prob &#x3D; 0.1</span><br></pre></td></tr></table></figure>\n\n<p>attack方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        self.speak()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.name, <span class=\"string\">&#x27;used&#x27;</span>, self.basic_attack, <span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">        other.receive_damage(self.damage)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random() &lt; self.prob <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(other) != ElectricType:</span><br><span class=\"line\">            other.paralyzed = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(other.name, <span class=\"string\">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这两个模块是不同的，其他都是相同的，所以我们可以这样来写电属性宝可梦类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElectricType</span>(<span class=\"params\">Pokemon</span>):</span></span><br><span class=\"line\">    basic_attack = <span class=\"string\">&#x27;thunder shock&#x27;</span></span><br><span class=\"line\">    prob = <span class=\"number\">0.1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">attack</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        Pokemon.attack(self, other)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random() &lt; self.prob <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(other) != ElectricType:</span><br><span class=\"line\">            other.paralyzed = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(other.name, <span class=\"string\">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>class &lt;Class Name&gt;(&lt;Superclass Name&gt;):</code>结构就是继承，通过继承，我们可以在新创建的类中保留下原有的类属性和实例属性</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Pica = ElectricType(<span class=\"string\">&#x27;pica&#x27;</span>,<span class=\"string\">&#x27;me&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Pica.hp</span><br><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看得出，新类所创建的实例拥有和被继承类相同的实例属性。</p>\n<p>我们还可以看到，attack方法被重写了，原来attack的方法被覆盖了，这种情况叫做方法重写，新类可以创建与被继承类相同名称的方法，将会覆盖原有方法.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;Pica.attack(Yib)</span><br><span class=\"line\"><span class=\"string\">&#x27;Yib is paralyzed!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候有人会问，那如果需要增加或删除实例属性项，是不是要重写一遍构造函数？</p>\n<p>当然，重写固然没有问题，但是还有更简便的方法。</p>\n<p>我们举一个61A Project ant的例子</p>\n<p>假设我们有一个昆虫类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Insect</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An Insect, the base class of Ant and Bee, has armor and a Place.&quot;&quot;&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    is_ant = <span class=\"literal\">False</span></span><br><span class=\"line\">    damage = <span class=\"number\">0</span></span><br><span class=\"line\">    is_watersafe = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, armor, place=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Create an Insect with an ARMOR amount and a starting PLACE.&quot;&quot;&quot;</span></span><br><span class=\"line\">        self.armor = armor</span><br><span class=\"line\">        self.armor = armor</span><br><span class=\"line\">        self.place = place  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reduce_armor</span>(<span class=\"params\">self, amount</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Reduce armor by AMOUNT, and remove the insect from its place if it</span></span><br><span class=\"line\"><span class=\"string\">        has no armor remaining.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; test_insect = Insect(5)</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; test_insect.reduce_armor(2)</span></span><br><span class=\"line\"><span class=\"string\">        &gt;&gt;&gt; test_insect.armor</span></span><br><span class=\"line\"><span class=\"string\">        3</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        self.armor -= amount</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.armor &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.place.remove_insect(self)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们要创建一个新的Ant类，这个Ant类是Insert类的一个子类，它继承了Insert类的一些方法和属性，不同的是，我们要修改一下Ant类当中amor属性的默认值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ant</span>(<span class=\"params\">Insect</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;An Ant occupies a place and does work for the colony.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    is_ant = <span class=\"literal\">True</span></span><br><span class=\"line\">    implemented = <span class=\"literal\">False</span>  <span class=\"comment\"># Only implemented Ant classes should be instantiated</span></span><br><span class=\"line\">    food_cost = <span class=\"number\">0</span></span><br><span class=\"line\">    blocks_path = <span class=\"literal\">True</span></span><br><span class=\"line\">    is_container = <span class=\"literal\">False</span></span><br><span class=\"line\">    is_double = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, armor=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Create an Ant with an ARMOR quantity.&quot;&quot;&quot;</span></span><br><span class=\"line\">        Insect.__init__(self, armor)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">can_contain</span>(<span class=\"params\">self, other</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用了<code>Insert.__init__(self,armor=1)</code>来修改父类的构造函数</p>\n<p>我们再以Ant为父类，创建一个名为HungryAnt的子类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungryAnt</span>(<span class=\"params\">Ant</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;HungryAnt will take three turns to digest a Bee in its place.</span></span><br><span class=\"line\"><span class=\"string\">    While digesting, the HungryAnt can&#x27;t eat another Bee.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;Hungry&#x27;</span></span><br><span class=\"line\">    food_cost = <span class=\"number\">4</span></span><br><span class=\"line\">    time_to_digest = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">    implemented = <span class=\"literal\">True</span>  <span class=\"comment\"># Change to True to view in the GUI</span></span><br><span class=\"line\">    <span class=\"comment\"># END Problem 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, armor=<span class=\"number\">1</span></span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">        Ant.__init__(self, armor)</span><br><span class=\"line\">        self.digesting = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># END Problem 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eat_bee</span>(<span class=\"params\">self, bee</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">        bee.armor = <span class=\"number\">0</span></span><br><span class=\"line\">        self.place.remove_insect(bee)</span><br><span class=\"line\">        self.digesting = self.time_to_digest</span><br><span class=\"line\">        <span class=\"comment\"># END Problem 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">action</span>(<span class=\"params\">self, colony</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># BEGIN Problem 6</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.digesting == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> random_or_none(self.place.bees) !=<span class=\"literal\">None</span>:</span><br><span class=\"line\">                self.eat_bee(random_or_none(self.place.bees))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.digesting -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># END Problem 6</span></span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这里我们使用<code>Insert.__init__(self,armor)</code>继承了父类的所有实例属性，并且在这基础上又增加了一个digesting属性作为该类独有的实例属性。</p>\n<h4 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h4><p>多重继承顾名思义，就是从多个父类继承的子类，比如，作为你父母的孩子，你既继承了你父亲的身高智慧，又继承了你母亲的高鼻梁大眼睛，因此在你这个类当中，既有父亲传给你的属性，又有母亲传给你的属性。</p>\n<p>Python 支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。</p>\n<p>恩，突然一下子想不出什么特别好的例子，大家可以在CS61A的一些习题当中找一些例子来看。</p>\n<h4 id=\"特殊方法\"><a href=\"#特殊方法\" class=\"headerlink\" title=\"特殊方法\"></a>特殊方法</h4><p>在 Python 中，某些特殊名称会在特殊情况下由 Python 解释器调用。例如，每当构造对象时，都会自动调用类的__init__方法。每当打印对象时会自动调用__str__方法，在交互式会话到显示值会调用repr方法。</p>\n<p>假设我们有一个类A</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,number</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;&#x27;</span> + self.name + <span class=\"string\">&#x27;&gt;&#x27;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.name</span><br></pre></td></tr></table></figure>\n\n<p>那么我们在打印A类所构造的实例对象时，就会自动调用__str__函数打印，交互式对话输入自动调用repr</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = A(<span class=\"string\">&#x27;alien&#x27;</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&lt;alien&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">alien</span><br></pre></td></tr></table></figure>\n\n<p>我们用Link对象举个例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Link</span>:</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A linked list.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = Link(1)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.first</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest is Link.empty</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.first = 5</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest.first = 6</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest.rest = Link.empty</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)</span></span><br><span class=\"line\"><span class=\"string\">    Link(5, Link(6))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s</span></span><br><span class=\"line\"><span class=\"string\">    Link(5, Link(7, Link(Link(8, Link(9)))))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print(s)                             # Prints str(s)</span></span><br><span class=\"line\"><span class=\"string\">    &lt;5 7 &lt;8 9&gt;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    empty = ()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, first, rest=empty</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> rest <span class=\"keyword\">is</span> Link.empty <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(rest, Link)</span><br><span class=\"line\">        self.first = first</span><br><span class=\"line\">        self.rest = rest</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"built_in\">repr</span>(self.rest)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Link(&#x27;</span> + <span class=\"built_in\">repr</span>(self.first) + rest_repr + <span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        string = <span class=\"string\">&#x27;&lt;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            string += <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27; &#x27;</span></span><br><span class=\"line\">            self = self.rest</span><br><span class=\"line\">        <span class=\"keyword\">return</span> string + <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然我们还没有讲到链表类，但是我们可以看到，Link类也重写了str和repr方法，因此Link类实现 方法的实现如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;s = Link(<span class=\"number\">2</span>, Link(<span class=\"number\">3</span>, Link(<span class=\"number\">4</span>)))</span><br><span class=\"line\">&gt;&gt;&gt;s</span><br><span class=\"line\">Link(<span class=\"number\">2</span>, Link(<span class=\"number\">3</span>, Link(<span class=\"number\">4</span>)))</span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">print</span>(s)</span><br><span class=\"line\">&lt; <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>除了最基本的str和repr特殊方法之外，python也支持对其他特殊方法进行修改，我们这里以contain特殊方法为例进行介绍,contain特殊方会在对实例使用in指令时自动调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__contains__</span>(<span class=\"params\">self,x</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.first == x：</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> self.rest <span class=\"keyword\">is</span> Link.empty:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x <span class=\"keyword\">in</span> self.rest</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就改写了contain特殊方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;l=Link(<span class=\"number\">1</span>,Link(<span class=\"number\">2</span>,Link(<span class=\"number\">3</span>)))</span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"number\">2</span> <span class=\"keyword\">in</span> l</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"number\">4</span> <span class=\"keyword\">in</span> l</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是一些常见的特殊方法，大家可以对其进行改写试一试。</p>\n<p><img src=\"https://i.loli.net/2021/08/09/eG2QDp4y7vlIH9a.png\" alt=\"image-20210809105526287\"></p>\n<h3 id=\"递归对象的实现\"><a href=\"#递归对象的实现\" class=\"headerlink\" title=\"递归对象的实现\"></a>递归对象的实现</h3><p>对象可以有其他对象作为属性值。当某个类的对象具有同一个类的属性值时，它就是递归对象。</p>\n<p>常见的递归对象有链表类和树类两种</p>\n<h4 id=\"链表类\"><a href=\"#链表类\" class=\"headerlink\" title=\"链表类\"></a>链表类</h4><p>本章前面已经提前给出Link类的概念，我们再次回顾一下，链表由第一个元素和列表的其余部分组成，链表的其余部分只能是一个链表，链表是一个序列，它的长度是有限的，并且支持按索引选择元素。</p>\n<p>我们可以实现一个Link类，表示一个链表对象。每个Link实例都有两个实例属性，first和rest。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Link</span>:</span></span><br><span class=\"line\">    empty = ()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, first, rest=empty</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> rest <span class=\"keyword\">is</span> Link.empty <span class=\"keyword\">or</span> <span class=\"built_in\">isinstance</span>(rest, Link)</span><br><span class=\"line\">        self.first = first</span><br><span class=\"line\">        self.rest = rest</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"built_in\">repr</span>(self.rest)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest_repr = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Link(&#x27;</span> + <span class=\"built_in\">repr</span>(self.first) + rest_repr + <span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        string = <span class=\"string\">&#x27;&lt;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.rest <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> Link.empty:</span><br><span class=\"line\">            string += <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27; &#x27;</span></span><br><span class=\"line\">            self = self.rest</span><br><span class=\"line\">        <span class=\"keyword\">return</span> string + <span class=\"built_in\">str</span>(self.first) + <span class=\"string\">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看出，链表第一个元素没有限制，但是第二个元素只能是一个链表或空链表，由于每个链表的第二个元素都是链表，所以链表是一个递归对象</p>\n<p>让我们通过一个例子来进一步加深印象，这道题是61A的题目。</p>\n<blockquote>\n<p>编写一个函数store_digits，接收一个整数n并返回一个链表，其中链表的每个元素都是 的一个数字n。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">store_digits</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Stores the digits of a positive number n in a linked list.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s = store_digits(1)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; s</span></span><br><span class=\"line\"><span class=\"string\">    Link(1)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; store_digits(2345)</span></span><br><span class=\"line\"><span class=\"string\">    Link(2, Link(3, Link(4, Link(5))))</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; store_digits(876)</span></span><br><span class=\"line\"><span class=\"string\">    Link(8, Link(7, Link(6)))</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># In iteration</span></span><br><span class=\"line\">    new_link = Link.empty</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n !=<span class=\"number\">0</span>:</span><br><span class=\"line\">        new_link = Link(n%<span class=\"number\">10</span>,new_link)</span><br><span class=\"line\">        n = n//<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_link</span><br></pre></td></tr></table></figure>\n\n<p>这道题目就利用了Link递归的特性，通过递归过程对不断加长拓展链表，最终构成一个单一数字的链表。</p>\n<h4 id=\"树类\"><a href=\"#树类\" class=\"headerlink\" title=\"树类\"></a>树类</h4><p>回想一下，树是一种递归抽象数据类型，它具有label（存储在树根中的值）和branches（根正下方的树列表）两种不同类型的值，在数据抽象一章中，我们曾经使用将树视为列表的构造函数和选择器函数实现过树。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Tree ADT</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tree</span>(<span class=\"params\">label, branches=[]</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches:</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> is_tree(branch), <span class=\"string\">&#x27;branches must be trees&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [label] + <span class=\"built_in\">list</span>(branches)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">label</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">branches</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree[<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_tree</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(tree) != <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">len</span>(tree) &lt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> branches(tree):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> is_tree(branch):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_leaf</span>(<span class=\"params\">tree</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span><br><span class=\"line\"><span class=\"string\">    otherwise.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> branches(tree)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_tree</span>(<span class=\"params\">t, indent=<span class=\"number\">0</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span><br><span class=\"line\"><span class=\"string\">    indented by two spaces times its depth from the root.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1))</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(numbers)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">      2</span></span><br><span class=\"line\"><span class=\"string\">      3</span></span><br><span class=\"line\"><span class=\"string\">        4</span></span><br><span class=\"line\"><span class=\"string\">        5</span></span><br><span class=\"line\"><span class=\"string\">      6</span></span><br><span class=\"line\"><span class=\"string\">        7</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;  &#x27;</span> * indent + <span class=\"built_in\">str</span>(label(t)))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t):</span><br><span class=\"line\">        print_tree(b, indent + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">copy_tree</span>(<span class=\"params\">t</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Returns a copy of t. Only for testing purposes.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t = tree(5)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; copy = copy_tree(t)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t = tree(6)</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; print_tree(copy)</span></span><br><span class=\"line\"><span class=\"string\">    5</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree(label(t), [copy_tree(b) <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches(t)])</span><br></pre></td></tr></table></figure>\n\n<p>但是我们会发现使用这种方式创建的树是不可更改的，因为我们无法为调用表达式赋值，为了能够实现对树的修改，我们将构造器的功能用树类实现，而将选择器的功能用访问实例属性的点表达式实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span>:</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t.label</span></span><br><span class=\"line\"><span class=\"string\">    3</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t.branches[0].label</span></span><br><span class=\"line\"><span class=\"string\">    2</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; t.branches[1].is_leaf()</span></span><br><span class=\"line\"><span class=\"string\">    True</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, label, branches=[]</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> branches:</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(b, Tree)</span><br><span class=\"line\">        self.label = label</span><br><span class=\"line\">        self.branches = <span class=\"built_in\">list</span>(branches)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_leaf</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> self.branches</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们就可以方便的创建树对象和修改树对象的label和branches属性，而不需要通过调用函数来获得树对象的各项属性，同时我们还可以在树类中任意增加各种方法，同样也只需要对实例进行方法调用即可。</p>\n<p>此外，使用构造选择函数和列表实现的树ADT与使用类与对象实现的树ADT还有如下的区别</p>\n<p><img src=\"https://i.loli.net/2021/08/09/q6QKxZFmIGuWihL.png\" alt=\"image-20210809154119551\"></p>\n<p>总的来说，利用类实现的树ADT具有可变的特点，因此使用起来要比函数式的ADT更加便捷。</p>\n"},{"title":"My year 2022","date":"2021-09-03T04:40:02.000Z","cover":"/myimage/my_year/My_Year_2022_cover.jpg","sticky":1,"_content":"\n就这样，二十三了了\n\n这个生日过的很草率，但并不是无奈之举。\n\n我故意的。\n\n我也可以热热闹闹的叫上一大帮人，觥筹交错，贺词不断，但我觉得太俗套，我就想看看，一个人买蛋糕，点蜡烛，许愿，是种什么感觉。\n\n体验极差。\n\n我还是高估了我的饭量。\n\n在连队里，每次生日我都参加了，气氛很热烈，氛围很浓厚，但是总感觉少了点什么。\n\n后来才发现，少了一个人的独处时光。\n\n点燃一根蜡烛，静静的思考，这种时刻弥足珍贵，闭上眼，过往历历在目，前路愈加清晰。\n\n跨越年岁的重大时刻，最该陪伴你的，不是父母，不是好友，也不是情人，而是你自己。\n\n呼朋引伴，把自己喝的七荤八素，不省人事，这不叫长大一岁，这叫老了一岁。\n\n我觉得长大是需要思考的，而思考需要安静的环境，独处才能安静。\n\n贾平凹说，生命是孤独的旅程，林清玄说，孤独是一个人的清欢，周国平说，要有敢于面对孤独的勇气。\n\n都不如村上说的一句话，人与人之间的沟通和理解几乎是不可能的。任何尝试都可能是徒劳的。\n\n非常直白，也非常真实，孤独是人生常态，越早理解这个道理，就越早得到自由。\n\n这就是我二十三岁生日学会的道理。\n\n祝自己生日快乐，喜怒哀乐一笔勾销，从此开始新的逍遥。\n\n![](https://s2.loli.net/2022/05/29/V23ceFhztY6Njg8.jpg)","source":"_posts/My-year-2022.md","raw":"---\ntitle: My year 2022\ndate: 2021-09-03 12:40:02\ntags:\n- Years\ncategories: \n- Article\ncover: /myimage/my_year/My_Year_2022_cover.jpg\nsticky: 1\n---\n\n就这样，二十三了了\n\n这个生日过的很草率，但并不是无奈之举。\n\n我故意的。\n\n我也可以热热闹闹的叫上一大帮人，觥筹交错，贺词不断，但我觉得太俗套，我就想看看，一个人买蛋糕，点蜡烛，许愿，是种什么感觉。\n\n体验极差。\n\n我还是高估了我的饭量。\n\n在连队里，每次生日我都参加了，气氛很热烈，氛围很浓厚，但是总感觉少了点什么。\n\n后来才发现，少了一个人的独处时光。\n\n点燃一根蜡烛，静静的思考，这种时刻弥足珍贵，闭上眼，过往历历在目，前路愈加清晰。\n\n跨越年岁的重大时刻，最该陪伴你的，不是父母，不是好友，也不是情人，而是你自己。\n\n呼朋引伴，把自己喝的七荤八素，不省人事，这不叫长大一岁，这叫老了一岁。\n\n我觉得长大是需要思考的，而思考需要安静的环境，独处才能安静。\n\n贾平凹说，生命是孤独的旅程，林清玄说，孤独是一个人的清欢，周国平说，要有敢于面对孤独的勇气。\n\n都不如村上说的一句话，人与人之间的沟通和理解几乎是不可能的。任何尝试都可能是徒劳的。\n\n非常直白，也非常真实，孤独是人生常态，越早理解这个道理，就越早得到自由。\n\n这就是我二十三岁生日学会的道理。\n\n祝自己生日快乐，喜怒哀乐一笔勾销，从此开始新的逍遥。\n\n![](https://s2.loli.net/2022/05/29/V23ceFhztY6Njg8.jpg)","slug":"My-year-2022","published":1,"updated":"2023-02-11T11:18:23.452Z","_id":"cl3qvw1650000fkrh4pfv31i9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>就这样，二十三了了</p>\n<p>这个生日过的很草率，但并不是无奈之举。</p>\n<p>我故意的。</p>\n<p>我也可以热热闹闹的叫上一大帮人，觥筹交错，贺词不断，但我觉得太俗套，我就想看看，一个人买蛋糕，点蜡烛，许愿，是种什么感觉。</p>\n<p>体验极差。</p>\n<p>我还是高估了我的饭量。</p>\n<p>在连队里，每次生日我都参加了，气氛很热烈，氛围很浓厚，但是总感觉少了点什么。</p>\n<p>后来才发现，少了一个人的独处时光。</p>\n<p>点燃一根蜡烛，静静的思考，这种时刻弥足珍贵，闭上眼，过往历历在目，前路愈加清晰。</p>\n<p>跨越年岁的重大时刻，最该陪伴你的，不是父母，不是好友，也不是情人，而是你自己。</p>\n<p>呼朋引伴，把自己喝的七荤八素，不省人事，这不叫长大一岁，这叫老了一岁。</p>\n<p>我觉得长大是需要思考的，而思考需要安静的环境，独处才能安静。</p>\n<p>贾平凹说，生命是孤独的旅程，林清玄说，孤独是一个人的清欢，周国平说，要有敢于面对孤独的勇气。</p>\n<p>都不如村上说的一句话，人与人之间的沟通和理解几乎是不可能的。任何尝试都可能是徒劳的。</p>\n<p>非常直白，也非常真实，孤独是人生常态，越早理解这个道理，就越早得到自由。</p>\n<p>这就是我二十三岁生日学会的道理。</p>\n<p>祝自己生日快乐，喜怒哀乐一笔勾销，从此开始新的逍遥。</p>\n<p><img src=\"https://s2.loli.net/2022/05/29/V23ceFhztY6Njg8.jpg\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":475,"excerpt":"","more":"<p>就这样，二十三了了</p>\n<p>这个生日过的很草率，但并不是无奈之举。</p>\n<p>我故意的。</p>\n<p>我也可以热热闹闹的叫上一大帮人，觥筹交错，贺词不断，但我觉得太俗套，我就想看看，一个人买蛋糕，点蜡烛，许愿，是种什么感觉。</p>\n<p>体验极差。</p>\n<p>我还是高估了我的饭量。</p>\n<p>在连队里，每次生日我都参加了，气氛很热烈，氛围很浓厚，但是总感觉少了点什么。</p>\n<p>后来才发现，少了一个人的独处时光。</p>\n<p>点燃一根蜡烛，静静的思考，这种时刻弥足珍贵，闭上眼，过往历历在目，前路愈加清晰。</p>\n<p>跨越年岁的重大时刻，最该陪伴你的，不是父母，不是好友，也不是情人，而是你自己。</p>\n<p>呼朋引伴，把自己喝的七荤八素，不省人事，这不叫长大一岁，这叫老了一岁。</p>\n<p>我觉得长大是需要思考的，而思考需要安静的环境，独处才能安静。</p>\n<p>贾平凹说，生命是孤独的旅程，林清玄说，孤独是一个人的清欢，周国平说，要有敢于面对孤独的勇气。</p>\n<p>都不如村上说的一句话，人与人之间的沟通和理解几乎是不可能的。任何尝试都可能是徒劳的。</p>\n<p>非常直白，也非常真实，孤独是人生常态，越早理解这个道理，就越早得到自由。</p>\n<p>这就是我二十三岁生日学会的道理。</p>\n<p>祝自己生日快乐，喜怒哀乐一笔勾销，从此开始新的逍遥。</p>\n<p><img src=\"https://s2.loli.net/2022/05/29/V23ceFhztY6Njg8.jpg\"></p>\n"},{"title":"后来的我们","date":"2022-06-05T03:33:34.000Z","cover":"/myimage/literature/lastus_cover.png","_content":"\n\n\n昨晚下了大雨，我一个人在房间里读书，突然响起了敲门声。\n\n\n\n我打开门，寒风夹杂着细密的雨点扑面而来，让我一个踉跄，等我缓过神来，发现门外站立着一个黑衣男子，戴着一副厚厚的镜片。\n\n\n\n这个人全身上下都穿着黑色，在大雨中，我看不清他的样貌，但奇怪的是，我隐隐约约却有种熟悉感。\n\n\n\n“你好，请问你找谁？”\n\n\n\n他没有说话，径直走进了房间，找了把椅子坐下。\n\n\n\n我有点讶异，但还是又问了一次。\n\n\n\n“请问你是谁，有什么事么？”\n\n\n\n他摘下了兜帽，露出一张棱角分明的脸，眼神锐利，目光如炬，大约和我年龄相当。\n\n\n\n我发誓肯定没见过这张脸，但是我突然有种莫名其妙的熟悉感，就好像在照镜子一样。\n\n\n\n他站起身，很高，跟我几乎一样，随后他伸出手，你好，我是东京大学数据科学院的学生，初次见面，请多关照。\n\n\n\n我盯着他的眼睛，没有说话。\n\n\n\n他笑了笑，摘下眼镜。\n\n\n\n“当然，我也叫王川。”\n\n\n\n我皱了皱眉头，所以呢。\n\n\n\n他脱下外套搭在沙发上，转身面向落满细雨的窗檐，细密的雨点不断敲打着窗台，发出滴滴答答的声音，仿佛对世间的一切都感到不满。\n\n\n\n“你想听故事吗？”\n\n\n\n“我不介意听”\n\n\n\n“这个故事，要从2012年说起，那一年，你还记得发生了什么吗？”\n\n\n\n我努力回想了2012年发生的事情，可记忆就好像坠入冰窟的石子，怎么努力都只是一片空白，最后我无奈的摇了摇头。\n\n\n\n“那一年，地球发生了磁极倒转，随即火山爆发，洪水肆虐，一半的城市被海水淹没，另一半在不断的地震中化为废墟，人们躲进了地底庇护所，可是岩浆不断的侵袭渗透，庇护所也岌岌可危。”\n\n\n\n他停顿了一下，看了看我。\n\n\n\n我面无表情，努了努嘴，示意他继续。\n\n\n\n“地球上所有的国家联合起来建立了科学研究院，翻遍了所有曾经的研究记录，终于在岩浆吞没庇护所的前一天，找出了唯一的解决方案，研究人员认为，磁极的倒转是由于部分人类的存在压迫了地磁场，他们把这种人称作完全体”\n\n\n\n“所以呢，要杀掉他们？”\n\n\n\n他瞪大了眼睛，嘴里不知嘟囔着什么。\n\n\n\n“那倒没有，科学家们认为，完全体的各项能力过于完美，所以压迫了地球的运行逻辑，唯一的解决方案就是，用等离子分离加速器将他们拆解后重组，减弱其完全性，于是，我和剩下的17453人被送进了加速器，一声巨响，我失去了意识。”\n\n\n\n他端起身旁的杯子喝了一口，继续说。\n\n\n\n“当我再次醒来的时候，我在一个陌生的地方，时间指向早晨8:00，我走出门，眼前是破败的小区，滴滴嗒嗒落水的屋檐，这时候我母亲走了进来，穿着素色的衣服。”\n\n\n\n“我连忙问母亲，这是什么地方，母亲很奇怪的看了我一眼，说这是我们家，我难以置信的环顾四周，这和我印象中的家完全没有一点相似之处，我家应该是明亮，清净，宽敞的，可这个地方破败，肮脏，昏暗。”\n\n\n\n“后来呢？”\n\n\n\n“后来我努力读书，考进了厦门大学，毕业后留学日本东京，在东京大学地球数据研究所工作，偶然的机会，我接触到一个关于粒子加速器的项目，借此机会，我查阅了很多资料，最终得出了一个惊人的结果。”\n\n\n\n“惊人的结果？”\n\n\n\n“粒子加速器在加速到一定速度的时候，人会粒子化，当粒子呈现不同性质的时候，它们可能会进入不同的时空进行重组。”\n\n\n\n“也就是说…”\n\n\n\n“没错，你和我，就是我们经历粒子分裂后在不同时空重组的结果。”\n\n\n\n“不同的时空？”\n\n\n\n“是的，如果我们没有猜错的话，他们对粒子加速器进行了改造，随机性的改变了一部分粒子的性质。”\n\n\n\n“这就是，为什么你醒来的时候，发现自己的家庭改变了？因为粒子的改变重塑了周边的地磁场？”\n\n\n\n“果然，你和我一样聪明…”\n\n\n\n我竖起一个指头。\n\n\n\n“一个问题，那你是怎么来到我这个时空的？”\n\n\n\n“我反向设置了粒子加速器，然后，重新加速了我自己，于是，我就可以重新回到粒子曾经走过的地方。”\n\n\n\n我沉默了一下。\n\n\n\n“一个问题…”\n\n\n\n“你这已经是第二个了。”\n\n\n\n“好吧，第二个问题，你和她在一起了么？别问我是谁，你知道的。”\n\n\n\n“恩，我们在一起四年，后来，分手了…”\n\n\n\n“分手了？”\n\n\n\n“你也知道她家的情况，以我那时候的经济状况，我给不了她幸福。”\n\n\n\n“噢…”\n\n\n\n我默默喝了一口气泡水，柠檬的味道在口中徘徊，很酸。\n\n\n\n“所以，你最后走完这么多时空，会怎么样？”\n\n\n\n他没有说话，只是静静望着眼前热水腾起的雾气，空气死一般的寂静，只听到雨声和偶尔的鸣笛声。\n\n\n\n他默默站起身，朝门走去，我不知该怎么安慰他，或者说，挽留他。\n\n\n\n他打开门，门外依然是大雨滂沱。他回头望了我一眼，身影逐渐消失在雨幕中。\n\n\n\n我关上门，失魂落魄的转过身，发现他的大衣还留在沙发上，我走过去拿起大衣，一个笔记本突然的从兜里掉了出来。\n\n\n\n我捡了起来，翻开扉页。\n\n\n\n突然不知是触动了什么机关，笔记本中传来了音乐声…\n\n\n\n*然后呢*\n\n*他们说你的心 似乎痊愈了*\n\n*也开始有个人 为你守护着*\n\n*我该心安或是 心痛呢？* \n\n*然后呢*\n\n*其实我的日子 也还可以呢*\n\n*除了回忆肆虐 的某些时刻*\n\n*庆幸还有眼泪 冲淡苦涩*\n\n*而那些昨日 依然缤纷着 它们都有我 细心收藏着*\n\n*也许你还记得 也许你都忘了*\n\n*也不是那么 重要了*\n\n*只期待 后来的你 能快乐*\n\n*那就是 后来的我 最想的*\n\n*后来的我们 依然走着*\n\n*只是不再并肩了*\n\n*朝各自的人生 追寻了*\n\n*无论是 后来故事 怎么了*\n\n*也要让 后来人生 精彩着*\n\n*后来的我们 我期待着*\n\n###### 泪水中能看到 你真的 自由了  ######\n\n--------------------\n\n第一页\n\n2012年6月一个普通的早上，我从睡梦中醒来，背上书包去学校，发现脑子很痛，好像看什么都记不住，到学校后，刚好是考试，我打开卷子，脑子一片空白，怎么想都写不出一个字。\n\n毕业后，父亲托人把我送进了私立学校，我依然学不会数学，读不懂英语，但是我还是努力学习，最后勉强考上了一个本科学校。\n\n我和她在一起十年后结婚，靠家里买了房，买了车，定居在杭州，自己在一家小公司做新媒体运营，日子虽然平淡，但也挺开心的。\n\n----------------------\n\n第二页\n\n2012年并没有发生什么奇怪的事，但是，从那以后，我就再也没有长高过，三年，五年，直到我上大学的那天，我的身高都一直停留在162。\n\n我和她也在一起了，虽然经常听到她闺蜜明里暗里嘲讽我矮，但她还是坚定的和我一起走了下去，高中毕业后，我为了和她一所学校，放弃了目标院校，和她一起去了一所普通的一本，入校那天，我作为成绩第一的学生代表发言，她站在下面，我望着她娇羞的脸，感觉一切都值得。\n\n毕业后，我因为身高没办法参加大多数服务业工作，于是我自学了计算机，考上了天津大学的研究生，打算明年在福建买房，然后结婚。\n\n------------------\n\n第三页\n\n2012年是我最难忘的一年，那天，我和平常一样去补习班上课，在路过一个红绿灯路口时，一辆大货车突然失控，撞向了人行道，我眼前一黑。\n\n再醒来的时候，我躺在床上，身旁母亲不住的啜泣，我突然发现好像感觉不到右腿的存在，我起身一看，右腿空荡荡的。\n\n康复后，我装上了假肢，继续进行学业，由于身体残缺，从小到大少不了被排挤欺负，无奈之下，我只能保持沉默，慢慢的越来越抑郁。\n\n你们说的她，我知道，毕竟我们喜欢的都是同一种类型，遇见的肯定也是同一个人，可是，她再怎么热情，我都没有回应，最后她就再也没理我。\n\n我努力读书，考上了一所985大学的生物科学专业，毕业后考研进了中科大，现在在生物学研究所读研，未来可能一直都会在实验室吧。\n\n-----------------------\n\n我默默合上了笔记，窗外的雨依然汹涌，好像什么也没发生过。","source":"_posts/后来的我们.md","raw":"---\ntitle: 后来的我们\ndate: 2022-06-05 11:33:34\ntags:\n- 故事\n- 文章\ncategories:\n- Article\ncover: /myimage/literature/lastus_cover.png\n---\n\n\n\n昨晚下了大雨，我一个人在房间里读书，突然响起了敲门声。\n\n\n\n我打开门，寒风夹杂着细密的雨点扑面而来，让我一个踉跄，等我缓过神来，发现门外站立着一个黑衣男子，戴着一副厚厚的镜片。\n\n\n\n这个人全身上下都穿着黑色，在大雨中，我看不清他的样貌，但奇怪的是，我隐隐约约却有种熟悉感。\n\n\n\n“你好，请问你找谁？”\n\n\n\n他没有说话，径直走进了房间，找了把椅子坐下。\n\n\n\n我有点讶异，但还是又问了一次。\n\n\n\n“请问你是谁，有什么事么？”\n\n\n\n他摘下了兜帽，露出一张棱角分明的脸，眼神锐利，目光如炬，大约和我年龄相当。\n\n\n\n我发誓肯定没见过这张脸，但是我突然有种莫名其妙的熟悉感，就好像在照镜子一样。\n\n\n\n他站起身，很高，跟我几乎一样，随后他伸出手，你好，我是东京大学数据科学院的学生，初次见面，请多关照。\n\n\n\n我盯着他的眼睛，没有说话。\n\n\n\n他笑了笑，摘下眼镜。\n\n\n\n“当然，我也叫王川。”\n\n\n\n我皱了皱眉头，所以呢。\n\n\n\n他脱下外套搭在沙发上，转身面向落满细雨的窗檐，细密的雨点不断敲打着窗台，发出滴滴答答的声音，仿佛对世间的一切都感到不满。\n\n\n\n“你想听故事吗？”\n\n\n\n“我不介意听”\n\n\n\n“这个故事，要从2012年说起，那一年，你还记得发生了什么吗？”\n\n\n\n我努力回想了2012年发生的事情，可记忆就好像坠入冰窟的石子，怎么努力都只是一片空白，最后我无奈的摇了摇头。\n\n\n\n“那一年，地球发生了磁极倒转，随即火山爆发，洪水肆虐，一半的城市被海水淹没，另一半在不断的地震中化为废墟，人们躲进了地底庇护所，可是岩浆不断的侵袭渗透，庇护所也岌岌可危。”\n\n\n\n他停顿了一下，看了看我。\n\n\n\n我面无表情，努了努嘴，示意他继续。\n\n\n\n“地球上所有的国家联合起来建立了科学研究院，翻遍了所有曾经的研究记录，终于在岩浆吞没庇护所的前一天，找出了唯一的解决方案，研究人员认为，磁极的倒转是由于部分人类的存在压迫了地磁场，他们把这种人称作完全体”\n\n\n\n“所以呢，要杀掉他们？”\n\n\n\n他瞪大了眼睛，嘴里不知嘟囔着什么。\n\n\n\n“那倒没有，科学家们认为，完全体的各项能力过于完美，所以压迫了地球的运行逻辑，唯一的解决方案就是，用等离子分离加速器将他们拆解后重组，减弱其完全性，于是，我和剩下的17453人被送进了加速器，一声巨响，我失去了意识。”\n\n\n\n他端起身旁的杯子喝了一口，继续说。\n\n\n\n“当我再次醒来的时候，我在一个陌生的地方，时间指向早晨8:00，我走出门，眼前是破败的小区，滴滴嗒嗒落水的屋檐，这时候我母亲走了进来，穿着素色的衣服。”\n\n\n\n“我连忙问母亲，这是什么地方，母亲很奇怪的看了我一眼，说这是我们家，我难以置信的环顾四周，这和我印象中的家完全没有一点相似之处，我家应该是明亮，清净，宽敞的，可这个地方破败，肮脏，昏暗。”\n\n\n\n“后来呢？”\n\n\n\n“后来我努力读书，考进了厦门大学，毕业后留学日本东京，在东京大学地球数据研究所工作，偶然的机会，我接触到一个关于粒子加速器的项目，借此机会，我查阅了很多资料，最终得出了一个惊人的结果。”\n\n\n\n“惊人的结果？”\n\n\n\n“粒子加速器在加速到一定速度的时候，人会粒子化，当粒子呈现不同性质的时候，它们可能会进入不同的时空进行重组。”\n\n\n\n“也就是说…”\n\n\n\n“没错，你和我，就是我们经历粒子分裂后在不同时空重组的结果。”\n\n\n\n“不同的时空？”\n\n\n\n“是的，如果我们没有猜错的话，他们对粒子加速器进行了改造，随机性的改变了一部分粒子的性质。”\n\n\n\n“这就是，为什么你醒来的时候，发现自己的家庭改变了？因为粒子的改变重塑了周边的地磁场？”\n\n\n\n“果然，你和我一样聪明…”\n\n\n\n我竖起一个指头。\n\n\n\n“一个问题，那你是怎么来到我这个时空的？”\n\n\n\n“我反向设置了粒子加速器，然后，重新加速了我自己，于是，我就可以重新回到粒子曾经走过的地方。”\n\n\n\n我沉默了一下。\n\n\n\n“一个问题…”\n\n\n\n“你这已经是第二个了。”\n\n\n\n“好吧，第二个问题，你和她在一起了么？别问我是谁，你知道的。”\n\n\n\n“恩，我们在一起四年，后来，分手了…”\n\n\n\n“分手了？”\n\n\n\n“你也知道她家的情况，以我那时候的经济状况，我给不了她幸福。”\n\n\n\n“噢…”\n\n\n\n我默默喝了一口气泡水，柠檬的味道在口中徘徊，很酸。\n\n\n\n“所以，你最后走完这么多时空，会怎么样？”\n\n\n\n他没有说话，只是静静望着眼前热水腾起的雾气，空气死一般的寂静，只听到雨声和偶尔的鸣笛声。\n\n\n\n他默默站起身，朝门走去，我不知该怎么安慰他，或者说，挽留他。\n\n\n\n他打开门，门外依然是大雨滂沱。他回头望了我一眼，身影逐渐消失在雨幕中。\n\n\n\n我关上门，失魂落魄的转过身，发现他的大衣还留在沙发上，我走过去拿起大衣，一个笔记本突然的从兜里掉了出来。\n\n\n\n我捡了起来，翻开扉页。\n\n\n\n突然不知是触动了什么机关，笔记本中传来了音乐声…\n\n\n\n*然后呢*\n\n*他们说你的心 似乎痊愈了*\n\n*也开始有个人 为你守护着*\n\n*我该心安或是 心痛呢？* \n\n*然后呢*\n\n*其实我的日子 也还可以呢*\n\n*除了回忆肆虐 的某些时刻*\n\n*庆幸还有眼泪 冲淡苦涩*\n\n*而那些昨日 依然缤纷着 它们都有我 细心收藏着*\n\n*也许你还记得 也许你都忘了*\n\n*也不是那么 重要了*\n\n*只期待 后来的你 能快乐*\n\n*那就是 后来的我 最想的*\n\n*后来的我们 依然走着*\n\n*只是不再并肩了*\n\n*朝各自的人生 追寻了*\n\n*无论是 后来故事 怎么了*\n\n*也要让 后来人生 精彩着*\n\n*后来的我们 我期待着*\n\n###### 泪水中能看到 你真的 自由了  ######\n\n--------------------\n\n第一页\n\n2012年6月一个普通的早上，我从睡梦中醒来，背上书包去学校，发现脑子很痛，好像看什么都记不住，到学校后，刚好是考试，我打开卷子，脑子一片空白，怎么想都写不出一个字。\n\n毕业后，父亲托人把我送进了私立学校，我依然学不会数学，读不懂英语，但是我还是努力学习，最后勉强考上了一个本科学校。\n\n我和她在一起十年后结婚，靠家里买了房，买了车，定居在杭州，自己在一家小公司做新媒体运营，日子虽然平淡，但也挺开心的。\n\n----------------------\n\n第二页\n\n2012年并没有发生什么奇怪的事，但是，从那以后，我就再也没有长高过，三年，五年，直到我上大学的那天，我的身高都一直停留在162。\n\n我和她也在一起了，虽然经常听到她闺蜜明里暗里嘲讽我矮，但她还是坚定的和我一起走了下去，高中毕业后，我为了和她一所学校，放弃了目标院校，和她一起去了一所普通的一本，入校那天，我作为成绩第一的学生代表发言，她站在下面，我望着她娇羞的脸，感觉一切都值得。\n\n毕业后，我因为身高没办法参加大多数服务业工作，于是我自学了计算机，考上了天津大学的研究生，打算明年在福建买房，然后结婚。\n\n------------------\n\n第三页\n\n2012年是我最难忘的一年，那天，我和平常一样去补习班上课，在路过一个红绿灯路口时，一辆大货车突然失控，撞向了人行道，我眼前一黑。\n\n再醒来的时候，我躺在床上，身旁母亲不住的啜泣，我突然发现好像感觉不到右腿的存在，我起身一看，右腿空荡荡的。\n\n康复后，我装上了假肢，继续进行学业，由于身体残缺，从小到大少不了被排挤欺负，无奈之下，我只能保持沉默，慢慢的越来越抑郁。\n\n你们说的她，我知道，毕竟我们喜欢的都是同一种类型，遇见的肯定也是同一个人，可是，她再怎么热情，我都没有回应，最后她就再也没理我。\n\n我努力读书，考上了一所985大学的生物科学专业，毕业后考研进了中科大，现在在生物学研究所读研，未来可能一直都会在实验室吧。\n\n-----------------------\n\n我默默合上了笔记，窗外的雨依然汹涌，好像什么也没发生过。","slug":"后来的我们","published":1,"updated":"2022-10-06T11:37:38.653Z","_id":"cl40x3tit00011erhfttxevjc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>昨晚下了大雨，我一个人在房间里读书，突然响起了敲门声。</p>\n<p>我打开门，寒风夹杂着细密的雨点扑面而来，让我一个踉跄，等我缓过神来，发现门外站立着一个黑衣男子，戴着一副厚厚的镜片。</p>\n<p>这个人全身上下都穿着黑色，在大雨中，我看不清他的样貌，但奇怪的是，我隐隐约约却有种熟悉感。</p>\n<p>“你好，请问你找谁？”</p>\n<p>他没有说话，径直走进了房间，找了把椅子坐下。</p>\n<p>我有点讶异，但还是又问了一次。</p>\n<p>“请问你是谁，有什么事么？”</p>\n<p>他摘下了兜帽，露出一张棱角分明的脸，眼神锐利，目光如炬，大约和我年龄相当。</p>\n<p>我发誓肯定没见过这张脸，但是我突然有种莫名其妙的熟悉感，就好像在照镜子一样。</p>\n<p>他站起身，很高，跟我几乎一样，随后他伸出手，你好，我是东京大学数据科学院的学生，初次见面，请多关照。</p>\n<p>我盯着他的眼睛，没有说话。</p>\n<p>他笑了笑，摘下眼镜。</p>\n<p>“当然，我也叫王川。”</p>\n<p>我皱了皱眉头，所以呢。</p>\n<p>他脱下外套搭在沙发上，转身面向落满细雨的窗檐，细密的雨点不断敲打着窗台，发出滴滴答答的声音，仿佛对世间的一切都感到不满。</p>\n<p>“你想听故事吗？”</p>\n<p>“我不介意听”</p>\n<p>“这个故事，要从2012年说起，那一年，你还记得发生了什么吗？”</p>\n<p>我努力回想了2012年发生的事情，可记忆就好像坠入冰窟的石子，怎么努力都只是一片空白，最后我无奈的摇了摇头。</p>\n<p>“那一年，地球发生了磁极倒转，随即火山爆发，洪水肆虐，一半的城市被海水淹没，另一半在不断的地震中化为废墟，人们躲进了地底庇护所，可是岩浆不断的侵袭渗透，庇护所也岌岌可危。”</p>\n<p>他停顿了一下，看了看我。</p>\n<p>我面无表情，努了努嘴，示意他继续。</p>\n<p>“地球上所有的国家联合起来建立了科学研究院，翻遍了所有曾经的研究记录，终于在岩浆吞没庇护所的前一天，找出了唯一的解决方案，研究人员认为，磁极的倒转是由于部分人类的存在压迫了地磁场，他们把这种人称作完全体”</p>\n<p>“所以呢，要杀掉他们？”</p>\n<p>他瞪大了眼睛，嘴里不知嘟囔着什么。</p>\n<p>“那倒没有，科学家们认为，完全体的各项能力过于完美，所以压迫了地球的运行逻辑，唯一的解决方案就是，用等离子分离加速器将他们拆解后重组，减弱其完全性，于是，我和剩下的17453人被送进了加速器，一声巨响，我失去了意识。”</p>\n<p>他端起身旁的杯子喝了一口，继续说。</p>\n<p>“当我再次醒来的时候，我在一个陌生的地方，时间指向早晨8:00，我走出门，眼前是破败的小区，滴滴嗒嗒落水的屋檐，这时候我母亲走了进来，穿着素色的衣服。”</p>\n<p>“我连忙问母亲，这是什么地方，母亲很奇怪的看了我一眼，说这是我们家，我难以置信的环顾四周，这和我印象中的家完全没有一点相似之处，我家应该是明亮，清净，宽敞的，可这个地方破败，肮脏，昏暗。”</p>\n<p>“后来呢？”</p>\n<p>“后来我努力读书，考进了厦门大学，毕业后留学日本东京，在东京大学地球数据研究所工作，偶然的机会，我接触到一个关于粒子加速器的项目，借此机会，我查阅了很多资料，最终得出了一个惊人的结果。”</p>\n<p>“惊人的结果？”</p>\n<p>“粒子加速器在加速到一定速度的时候，人会粒子化，当粒子呈现不同性质的时候，它们可能会进入不同的时空进行重组。”</p>\n<p>“也就是说…”</p>\n<p>“没错，你和我，就是我们经历粒子分裂后在不同时空重组的结果。”</p>\n<p>“不同的时空？”</p>\n<p>“是的，如果我们没有猜错的话，他们对粒子加速器进行了改造，随机性的改变了一部分粒子的性质。”</p>\n<p>“这就是，为什么你醒来的时候，发现自己的家庭改变了？因为粒子的改变重塑了周边的地磁场？”</p>\n<p>“果然，你和我一样聪明…”</p>\n<p>我竖起一个指头。</p>\n<p>“一个问题，那你是怎么来到我这个时空的？”</p>\n<p>“我反向设置了粒子加速器，然后，重新加速了我自己，于是，我就可以重新回到粒子曾经走过的地方。”</p>\n<p>我沉默了一下。</p>\n<p>“一个问题…”</p>\n<p>“你这已经是第二个了。”</p>\n<p>“好吧，第二个问题，你和她在一起了么？别问我是谁，你知道的。”</p>\n<p>“恩，我们在一起四年，后来，分手了…”</p>\n<p>“分手了？”</p>\n<p>“你也知道她家的情况，以我那时候的经济状况，我给不了她幸福。”</p>\n<p>“噢…”</p>\n<p>我默默喝了一口气泡水，柠檬的味道在口中徘徊，很酸。</p>\n<p>“所以，你最后走完这么多时空，会怎么样？”</p>\n<p>他没有说话，只是静静望着眼前热水腾起的雾气，空气死一般的寂静，只听到雨声和偶尔的鸣笛声。</p>\n<p>他默默站起身，朝门走去，我不知该怎么安慰他，或者说，挽留他。</p>\n<p>他打开门，门外依然是大雨滂沱。他回头望了我一眼，身影逐渐消失在雨幕中。</p>\n<p>我关上门，失魂落魄的转过身，发现他的大衣还留在沙发上，我走过去拿起大衣，一个笔记本突然的从兜里掉了出来。</p>\n<p>我捡了起来，翻开扉页。</p>\n<p>突然不知是触动了什么机关，笔记本中传来了音乐声…</p>\n<p><em>然后呢</em></p>\n<p><em>他们说你的心 似乎痊愈了</em></p>\n<p><em>也开始有个人 为你守护着</em></p>\n<p><em>我该心安或是 心痛呢？</em> </p>\n<p><em>然后呢</em></p>\n<p><em>其实我的日子 也还可以呢</em></p>\n<p><em>除了回忆肆虐 的某些时刻</em></p>\n<p><em>庆幸还有眼泪 冲淡苦涩</em></p>\n<p><em>而那些昨日 依然缤纷着 它们都有我 细心收藏着</em></p>\n<p><em>也许你还记得 也许你都忘了</em></p>\n<p><em>也不是那么 重要了</em></p>\n<p><em>只期待 后来的你 能快乐</em></p>\n<p><em>那就是 后来的我 最想的</em></p>\n<p><em>后来的我们 依然走着</em></p>\n<p><em>只是不再并肩了</em></p>\n<p><em>朝各自的人生 追寻了</em></p>\n<p><em>无论是 后来故事 怎么了</em></p>\n<p><em>也要让 后来人生 精彩着</em></p>\n<p><em>后来的我们 我期待着</em></p>\n<h6 id=\"泪水中能看到-你真的-自由了\"><a href=\"#泪水中能看到-你真的-自由了\" class=\"headerlink\" title=\"泪水中能看到 你真的 自由了\"></a>泪水中能看到 你真的 自由了</h6><hr>\n<p>第一页</p>\n<p>2012年6月一个普通的早上，我从睡梦中醒来，背上书包去学校，发现脑子很痛，好像看什么都记不住，到学校后，刚好是考试，我打开卷子，脑子一片空白，怎么想都写不出一个字。</p>\n<p>毕业后，父亲托人把我送进了私立学校，我依然学不会数学，读不懂英语，但是我还是努力学习，最后勉强考上了一个本科学校。</p>\n<p>我和她在一起十年后结婚，靠家里买了房，买了车，定居在杭州，自己在一家小公司做新媒体运营，日子虽然平淡，但也挺开心的。</p>\n<hr>\n<p>第二页</p>\n<p>2012年并没有发生什么奇怪的事，但是，从那以后，我就再也没有长高过，三年，五年，直到我上大学的那天，我的身高都一直停留在162。</p>\n<p>我和她也在一起了，虽然经常听到她闺蜜明里暗里嘲讽我矮，但她还是坚定的和我一起走了下去，高中毕业后，我为了和她一所学校，放弃了目标院校，和她一起去了一所普通的一本，入校那天，我作为成绩第一的学生代表发言，她站在下面，我望着她娇羞的脸，感觉一切都值得。</p>\n<p>毕业后，我因为身高没办法参加大多数服务业工作，于是我自学了计算机，考上了天津大学的研究生，打算明年在福建买房，然后结婚。</p>\n<hr>\n<p>第三页</p>\n<p>2012年是我最难忘的一年，那天，我和平常一样去补习班上课，在路过一个红绿灯路口时，一辆大货车突然失控，撞向了人行道，我眼前一黑。</p>\n<p>再醒来的时候，我躺在床上，身旁母亲不住的啜泣，我突然发现好像感觉不到右腿的存在，我起身一看，右腿空荡荡的。</p>\n<p>康复后，我装上了假肢，继续进行学业，由于身体残缺，从小到大少不了被排挤欺负，无奈之下，我只能保持沉默，慢慢的越来越抑郁。</p>\n<p>你们说的她，我知道，毕竟我们喜欢的都是同一种类型，遇见的肯定也是同一个人，可是，她再怎么热情，我都没有回应，最后她就再也没理我。</p>\n<p>我努力读书，考上了一所985大学的生物科学专业，毕业后考研进了中科大，现在在生物学研究所读研，未来可能一直都会在实验室吧。</p>\n<hr>\n<p>我默默合上了笔记，窗外的雨依然汹涌，好像什么也没发生过。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":2795,"excerpt":"","more":"<p>昨晚下了大雨，我一个人在房间里读书，突然响起了敲门声。</p>\n<p>我打开门，寒风夹杂着细密的雨点扑面而来，让我一个踉跄，等我缓过神来，发现门外站立着一个黑衣男子，戴着一副厚厚的镜片。</p>\n<p>这个人全身上下都穿着黑色，在大雨中，我看不清他的样貌，但奇怪的是，我隐隐约约却有种熟悉感。</p>\n<p>“你好，请问你找谁？”</p>\n<p>他没有说话，径直走进了房间，找了把椅子坐下。</p>\n<p>我有点讶异，但还是又问了一次。</p>\n<p>“请问你是谁，有什么事么？”</p>\n<p>他摘下了兜帽，露出一张棱角分明的脸，眼神锐利，目光如炬，大约和我年龄相当。</p>\n<p>我发誓肯定没见过这张脸，但是我突然有种莫名其妙的熟悉感，就好像在照镜子一样。</p>\n<p>他站起身，很高，跟我几乎一样，随后他伸出手，你好，我是东京大学数据科学院的学生，初次见面，请多关照。</p>\n<p>我盯着他的眼睛，没有说话。</p>\n<p>他笑了笑，摘下眼镜。</p>\n<p>“当然，我也叫王川。”</p>\n<p>我皱了皱眉头，所以呢。</p>\n<p>他脱下外套搭在沙发上，转身面向落满细雨的窗檐，细密的雨点不断敲打着窗台，发出滴滴答答的声音，仿佛对世间的一切都感到不满。</p>\n<p>“你想听故事吗？”</p>\n<p>“我不介意听”</p>\n<p>“这个故事，要从2012年说起，那一年，你还记得发生了什么吗？”</p>\n<p>我努力回想了2012年发生的事情，可记忆就好像坠入冰窟的石子，怎么努力都只是一片空白，最后我无奈的摇了摇头。</p>\n<p>“那一年，地球发生了磁极倒转，随即火山爆发，洪水肆虐，一半的城市被海水淹没，另一半在不断的地震中化为废墟，人们躲进了地底庇护所，可是岩浆不断的侵袭渗透，庇护所也岌岌可危。”</p>\n<p>他停顿了一下，看了看我。</p>\n<p>我面无表情，努了努嘴，示意他继续。</p>\n<p>“地球上所有的国家联合起来建立了科学研究院，翻遍了所有曾经的研究记录，终于在岩浆吞没庇护所的前一天，找出了唯一的解决方案，研究人员认为，磁极的倒转是由于部分人类的存在压迫了地磁场，他们把这种人称作完全体”</p>\n<p>“所以呢，要杀掉他们？”</p>\n<p>他瞪大了眼睛，嘴里不知嘟囔着什么。</p>\n<p>“那倒没有，科学家们认为，完全体的各项能力过于完美，所以压迫了地球的运行逻辑，唯一的解决方案就是，用等离子分离加速器将他们拆解后重组，减弱其完全性，于是，我和剩下的17453人被送进了加速器，一声巨响，我失去了意识。”</p>\n<p>他端起身旁的杯子喝了一口，继续说。</p>\n<p>“当我再次醒来的时候，我在一个陌生的地方，时间指向早晨8:00，我走出门，眼前是破败的小区，滴滴嗒嗒落水的屋檐，这时候我母亲走了进来，穿着素色的衣服。”</p>\n<p>“我连忙问母亲，这是什么地方，母亲很奇怪的看了我一眼，说这是我们家，我难以置信的环顾四周，这和我印象中的家完全没有一点相似之处，我家应该是明亮，清净，宽敞的，可这个地方破败，肮脏，昏暗。”</p>\n<p>“后来呢？”</p>\n<p>“后来我努力读书，考进了厦门大学，毕业后留学日本东京，在东京大学地球数据研究所工作，偶然的机会，我接触到一个关于粒子加速器的项目，借此机会，我查阅了很多资料，最终得出了一个惊人的结果。”</p>\n<p>“惊人的结果？”</p>\n<p>“粒子加速器在加速到一定速度的时候，人会粒子化，当粒子呈现不同性质的时候，它们可能会进入不同的时空进行重组。”</p>\n<p>“也就是说…”</p>\n<p>“没错，你和我，就是我们经历粒子分裂后在不同时空重组的结果。”</p>\n<p>“不同的时空？”</p>\n<p>“是的，如果我们没有猜错的话，他们对粒子加速器进行了改造，随机性的改变了一部分粒子的性质。”</p>\n<p>“这就是，为什么你醒来的时候，发现自己的家庭改变了？因为粒子的改变重塑了周边的地磁场？”</p>\n<p>“果然，你和我一样聪明…”</p>\n<p>我竖起一个指头。</p>\n<p>“一个问题，那你是怎么来到我这个时空的？”</p>\n<p>“我反向设置了粒子加速器，然后，重新加速了我自己，于是，我就可以重新回到粒子曾经走过的地方。”</p>\n<p>我沉默了一下。</p>\n<p>“一个问题…”</p>\n<p>“你这已经是第二个了。”</p>\n<p>“好吧，第二个问题，你和她在一起了么？别问我是谁，你知道的。”</p>\n<p>“恩，我们在一起四年，后来，分手了…”</p>\n<p>“分手了？”</p>\n<p>“你也知道她家的情况，以我那时候的经济状况，我给不了她幸福。”</p>\n<p>“噢…”</p>\n<p>我默默喝了一口气泡水，柠檬的味道在口中徘徊，很酸。</p>\n<p>“所以，你最后走完这么多时空，会怎么样？”</p>\n<p>他没有说话，只是静静望着眼前热水腾起的雾气，空气死一般的寂静，只听到雨声和偶尔的鸣笛声。</p>\n<p>他默默站起身，朝门走去，我不知该怎么安慰他，或者说，挽留他。</p>\n<p>他打开门，门外依然是大雨滂沱。他回头望了我一眼，身影逐渐消失在雨幕中。</p>\n<p>我关上门，失魂落魄的转过身，发现他的大衣还留在沙发上，我走过去拿起大衣，一个笔记本突然的从兜里掉了出来。</p>\n<p>我捡了起来，翻开扉页。</p>\n<p>突然不知是触动了什么机关，笔记本中传来了音乐声…</p>\n<p><em>然后呢</em></p>\n<p><em>他们说你的心 似乎痊愈了</em></p>\n<p><em>也开始有个人 为你守护着</em></p>\n<p><em>我该心安或是 心痛呢？</em> </p>\n<p><em>然后呢</em></p>\n<p><em>其实我的日子 也还可以呢</em></p>\n<p><em>除了回忆肆虐 的某些时刻</em></p>\n<p><em>庆幸还有眼泪 冲淡苦涩</em></p>\n<p><em>而那些昨日 依然缤纷着 它们都有我 细心收藏着</em></p>\n<p><em>也许你还记得 也许你都忘了</em></p>\n<p><em>也不是那么 重要了</em></p>\n<p><em>只期待 后来的你 能快乐</em></p>\n<p><em>那就是 后来的我 最想的</em></p>\n<p><em>后来的我们 依然走着</em></p>\n<p><em>只是不再并肩了</em></p>\n<p><em>朝各自的人生 追寻了</em></p>\n<p><em>无论是 后来故事 怎么了</em></p>\n<p><em>也要让 后来人生 精彩着</em></p>\n<p><em>后来的我们 我期待着</em></p>\n<h6 id=\"泪水中能看到-你真的-自由了\"><a href=\"#泪水中能看到-你真的-自由了\" class=\"headerlink\" title=\"泪水中能看到 你真的 自由了\"></a>泪水中能看到 你真的 自由了</h6><hr>\n<p>第一页</p>\n<p>2012年6月一个普通的早上，我从睡梦中醒来，背上书包去学校，发现脑子很痛，好像看什么都记不住，到学校后，刚好是考试，我打开卷子，脑子一片空白，怎么想都写不出一个字。</p>\n<p>毕业后，父亲托人把我送进了私立学校，我依然学不会数学，读不懂英语，但是我还是努力学习，最后勉强考上了一个本科学校。</p>\n<p>我和她在一起十年后结婚，靠家里买了房，买了车，定居在杭州，自己在一家小公司做新媒体运营，日子虽然平淡，但也挺开心的。</p>\n<hr>\n<p>第二页</p>\n<p>2012年并没有发生什么奇怪的事，但是，从那以后，我就再也没有长高过，三年，五年，直到我上大学的那天，我的身高都一直停留在162。</p>\n<p>我和她也在一起了，虽然经常听到她闺蜜明里暗里嘲讽我矮，但她还是坚定的和我一起走了下去，高中毕业后，我为了和她一所学校，放弃了目标院校，和她一起去了一所普通的一本，入校那天，我作为成绩第一的学生代表发言，她站在下面，我望着她娇羞的脸，感觉一切都值得。</p>\n<p>毕业后，我因为身高没办法参加大多数服务业工作，于是我自学了计算机，考上了天津大学的研究生，打算明年在福建买房，然后结婚。</p>\n<hr>\n<p>第三页</p>\n<p>2012年是我最难忘的一年，那天，我和平常一样去补习班上课，在路过一个红绿灯路口时，一辆大货车突然失控，撞向了人行道，我眼前一黑。</p>\n<p>再醒来的时候，我躺在床上，身旁母亲不住的啜泣，我突然发现好像感觉不到右腿的存在，我起身一看，右腿空荡荡的。</p>\n<p>康复后，我装上了假肢，继续进行学业，由于身体残缺，从小到大少不了被排挤欺负，无奈之下，我只能保持沉默，慢慢的越来越抑郁。</p>\n<p>你们说的她，我知道，毕竟我们喜欢的都是同一种类型，遇见的肯定也是同一个人，可是，她再怎么热情，我都没有回应，最后她就再也没理我。</p>\n<p>我努力读书，考上了一所985大学的生物科学专业，毕业后考研进了中科大，现在在生物学研究所读研，未来可能一直都会在实验室吧。</p>\n<hr>\n<p>我默默合上了笔记，窗外的雨依然汹涌，好像什么也没发生过。</p>\n"},{"title":"如果世界有尽头","date":"2022-06-06T14:16:55.000Z","cover":"/myimage/literature/endworld_cover.png","_content":"\n赛虎死了，不知是昨天，还是今天。\n\n\n\n赛虎是中队养的一条德国牧羊犬，棕黑色的毛发油光发亮，跑起来像一阵风，我曾经以为，这个队把我们都送走了，赛虎也不会走。\n\n\n\n可是一个小小的伤口，就堂而皇之的夺走了它的生命。\n\n\n\n我们挖了个很深的坑，把赛虎放了进去，填上土，在上面摆着它最爱吃的大骨。\n\n\n\n昨夜又下雨了，下的很大，几乎要把营区都淹没了，我以为第二天早晨醒来，要游泳去查哨，早上起来一看，水早就退了，狗圈焕然一新，钢质的笼子上挂满了水珠，好像刚从冰箱里取出来，透着凉气的雪糕。\n\n\n\n我才发现，轻描淡写的抹去一个生命存在的痕迹，如此简单。\n\n\n\n再过几个月，老兵离开，新兵入营，狗圈门口的牌子为了应付检查会留着，但总有一天也会换掉，甚至，中队又会养一条狗，它也可以叫赛虎。\n\n\n\n原来的故事和奔跑的身影，再也没人提起。\n\n\n\n毕竟那只是一条狗。\n\n\n\n寻梦环游记里那句话翻译成中文是，死亡不是生命的终点，遗忘才是。\n\n\n\n我突然感到很悲伤，不是因为赛虎的死，我跟它一点感情都没有，如果硬要说有的话，那就是每天差人去喂他，我甚至都不知道它是几点死的，哪天死的。\n\n\n\n昨天站在土堆旁，有人惋惜的感叹了一句，太惨了.\n\n\n\n我不知道他这句话是在说赛虎，还是他自己。\n\n\n\n具体多久我已经忘了，毕竟在这里面，只需要记住今天是周几，该干什么就足够了。\n\n\n\n因为就算你记住了日期，日子也遥遥无期。\n\n\n\n在没有尽头的世界里，清醒是种罪。\n\n\n\n","source":"_posts/如果世界有尽头.md","raw":"---\ntitle: 如果世界有尽头\ndate: 2022-06-06 22:16:55\ntags:\n- 故事\n- 文章\ncategories:\n- Article\ncover: /myimage/literature/endworld_cover.png\n---\n\n赛虎死了，不知是昨天，还是今天。\n\n\n\n赛虎是中队养的一条德国牧羊犬，棕黑色的毛发油光发亮，跑起来像一阵风，我曾经以为，这个队把我们都送走了，赛虎也不会走。\n\n\n\n可是一个小小的伤口，就堂而皇之的夺走了它的生命。\n\n\n\n我们挖了个很深的坑，把赛虎放了进去，填上土，在上面摆着它最爱吃的大骨。\n\n\n\n昨夜又下雨了，下的很大，几乎要把营区都淹没了，我以为第二天早晨醒来，要游泳去查哨，早上起来一看，水早就退了，狗圈焕然一新，钢质的笼子上挂满了水珠，好像刚从冰箱里取出来，透着凉气的雪糕。\n\n\n\n我才发现，轻描淡写的抹去一个生命存在的痕迹，如此简单。\n\n\n\n再过几个月，老兵离开，新兵入营，狗圈门口的牌子为了应付检查会留着，但总有一天也会换掉，甚至，中队又会养一条狗，它也可以叫赛虎。\n\n\n\n原来的故事和奔跑的身影，再也没人提起。\n\n\n\n毕竟那只是一条狗。\n\n\n\n寻梦环游记里那句话翻译成中文是，死亡不是生命的终点，遗忘才是。\n\n\n\n我突然感到很悲伤，不是因为赛虎的死，我跟它一点感情都没有，如果硬要说有的话，那就是每天差人去喂他，我甚至都不知道它是几点死的，哪天死的。\n\n\n\n昨天站在土堆旁，有人惋惜的感叹了一句，太惨了.\n\n\n\n我不知道他这句话是在说赛虎，还是他自己。\n\n\n\n具体多久我已经忘了，毕竟在这里面，只需要记住今天是周几，该干什么就足够了。\n\n\n\n因为就算你记住了日期，日子也遥遥无期。\n\n\n\n在没有尽头的世界里，清醒是种罪。\n\n\n\n","slug":"如果世界有尽头","published":1,"updated":"2022-10-06T11:38:09.208Z","_id":"cl411w4jh00002nrh29dc6w18","comments":1,"layout":"post","photos":[],"link":"","content":"<p>赛虎死了，不知是昨天，还是今天。</p>\n<p>赛虎是中队养的一条德国牧羊犬，棕黑色的毛发油光发亮，跑起来像一阵风，我曾经以为，这个队把我们都送走了，赛虎也不会走。</p>\n<p>可是一个小小的伤口，就堂而皇之的夺走了它的生命。</p>\n<p>我们挖了个很深的坑，把赛虎放了进去，填上土，在上面摆着它最爱吃的大骨。</p>\n<p>昨夜又下雨了，下的很大，几乎要把营区都淹没了，我以为第二天早晨醒来，要游泳去查哨，早上起来一看，水早就退了，狗圈焕然一新，钢质的笼子上挂满了水珠，好像刚从冰箱里取出来，透着凉气的雪糕。</p>\n<p>我才发现，轻描淡写的抹去一个生命存在的痕迹，如此简单。</p>\n<p>再过几个月，老兵离开，新兵入营，狗圈门口的牌子为了应付检查会留着，但总有一天也会换掉，甚至，中队又会养一条狗，它也可以叫赛虎。</p>\n<p>原来的故事和奔跑的身影，再也没人提起。</p>\n<p>毕竟那只是一条狗。</p>\n<p>寻梦环游记里那句话翻译成中文是，死亡不是生命的终点，遗忘才是。</p>\n<p>我突然感到很悲伤，不是因为赛虎的死，我跟它一点感情都没有，如果硬要说有的话，那就是每天差人去喂他，我甚至都不知道它是几点死的，哪天死的。</p>\n<p>昨天站在土堆旁，有人惋惜的感叹了一句，太惨了.</p>\n<p>我不知道他这句话是在说赛虎，还是他自己。</p>\n<p>具体多久我已经忘了，毕竟在这里面，只需要记住今天是周几，该干什么就足够了。</p>\n<p>因为就算你记住了日期，日子也遥遥无期。</p>\n<p>在没有尽头的世界里，清醒是种罪。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":557,"excerpt":"","more":"<p>赛虎死了，不知是昨天，还是今天。</p>\n<p>赛虎是中队养的一条德国牧羊犬，棕黑色的毛发油光发亮，跑起来像一阵风，我曾经以为，这个队把我们都送走了，赛虎也不会走。</p>\n<p>可是一个小小的伤口，就堂而皇之的夺走了它的生命。</p>\n<p>我们挖了个很深的坑，把赛虎放了进去，填上土，在上面摆着它最爱吃的大骨。</p>\n<p>昨夜又下雨了，下的很大，几乎要把营区都淹没了，我以为第二天早晨醒来，要游泳去查哨，早上起来一看，水早就退了，狗圈焕然一新，钢质的笼子上挂满了水珠，好像刚从冰箱里取出来，透着凉气的雪糕。</p>\n<p>我才发现，轻描淡写的抹去一个生命存在的痕迹，如此简单。</p>\n<p>再过几个月，老兵离开，新兵入营，狗圈门口的牌子为了应付检查会留着，但总有一天也会换掉，甚至，中队又会养一条狗，它也可以叫赛虎。</p>\n<p>原来的故事和奔跑的身影，再也没人提起。</p>\n<p>毕竟那只是一条狗。</p>\n<p>寻梦环游记里那句话翻译成中文是，死亡不是生命的终点，遗忘才是。</p>\n<p>我突然感到很悲伤，不是因为赛虎的死，我跟它一点感情都没有，如果硬要说有的话，那就是每天差人去喂他，我甚至都不知道它是几点死的，哪天死的。</p>\n<p>昨天站在土堆旁，有人惋惜的感叹了一句，太惨了.</p>\n<p>我不知道他这句话是在说赛虎，还是他自己。</p>\n<p>具体多久我已经忘了，毕竟在这里面，只需要记住今天是周几，该干什么就足够了。</p>\n<p>因为就算你记住了日期，日子也遥遥无期。</p>\n<p>在没有尽头的世界里，清醒是种罪。</p>\n"},{"title":"Linux操作与使用","date":"2022-10-05T12:06:11.000Z","_content":"\n## Linux操作与使用\n\n#### 目录\n\n>操作系统与硬件\n>\n>主机规划与磁盘分区\n>\n>CentoOS安装\n>\n>登录与在线求助\n>\n>文件权限与目录管理\n>\n>磁盘划分与目录挂载\n>\n>系统压缩与备份\n>\n>程序编辑器vim\n>\n\n\n\n### 操作系统与硬件\n\n\n\n#### 操作系统\n\n>操作系统主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、负责进程管理以及系统调用等等。因此，只要能够让硬件准备妥当的情况，就是一个合格的操作系统了。\n\n\n\n#### Unix\n\n>Unix 的前身是由贝尔实验室(Bell lab.)的Ken Thompson利用汇编语言写成的，后来在 1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。\n\n\n\n#### BSD\n\n>1977年由Bill Joy释出BSD (Berkeley Software Distribution),这些称为Unix-like的操作系统.\n\n\n\n#### Minix\n\n>1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供原始码以及软件;\n\n\n\n#### GNU计划\n\n>1984年由Richard Sallman提倡GNU计划，倡导自由软件(Free software)，强调其软件可以 「自由的取得、复制、修改与再发行」，并规范出GPL授权模式，任何 GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。\n\n\n\n#### Linux Kernel\n\n>从Linux kernel 3.0开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本(MainLine) 为依据，并提供长期支持版本 (longterm)来加强某些功能的持续维护。\n\n\n\n#### Linux Distrbutiom\n\n>Linux distributions的组成含有: [Linux Kernel + Free Software + Documentations(Tools) +可完全安装的程序」所制成的一套完整的系统。\n>\n>常见的Linux distributions分类有[商业、社群」分类法，或「RPM、DPKG」 分类法\n\n\n\n### 主机规划与硬盘分区\n\n\n\n#### 主机规划\n\n>主机规划一定要按照自己的需求来进行使用。\n\n\n\n#### 装置文件名\n\n>磁盘装置文件名通常分为两种，实际SATA/USB装置文件名为/dev/sd[a-p], 而虚拟机的装置可能为/dev/vd[a-p]\n\n\n\n#### MBR分区\n\n> 磁盘的第一个扇区 主要记录了两个重要的信息，一是要启动记录区(Master Boot Record, MBR):可以安装开机管理程序的地方,有446 bytes ，二是分区表(artition table):记录整颗硬盘分区的状态，有64 bytes;\n>\n> 磁盘的MBR分区方式中，主要与延伸分区最多可以有四个，所以逻辑分区的装置文件名号码，一定是由从5号开始。\n\n![image-20221007192837574](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192837574.png)\n\n> 如果采用逻辑分区，那么磁盘的规划会变成这样\n\n![image-20221007192922041](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192922041.png)\n\n\n\n#### GPT分区\n\n>如果磁盘容量大于2TB以上时，系统会自动使用GPT分区方式来处理磁盘分区。\n>\n>GPT分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区.\n>\n>某些操作系统要使用GPT分区时，必须要搭配UEFI的新型BIOS 格式才可安装使用。\n\n![image-20221007192955934](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192955934.png)\n\n#### 开机的流程\n\n>开机的流程由: BIOS-->MBR-->boot loader-->核心文件。\n>\n>boot loader的功能主要有:提供选单、加载核心、转交控制权给其他loader。\n>\n>boot loader可以安装的地点有两个，分别是MBR与boot sector,这个特色造就了多重引导功能。\n\n![image-20221007193014623](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193014623.png)\n\n#### 目录树\n\n```\nLinux 操作系统的文件使用目录树系统，与磁盘的对应需要有[挂载」的动作才行;\n```\n\n![image-20221007161907887](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007161907887.png)\n\n> 挂载示意如下：\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162003856.png\" alt=\"image-20221007162003856\" style=\"zoom:80%;\" />\n\n\n\n\n\n### CentOS安装\n\n\n\n#### 安装模式\n\n>安装CentOS 7.x的模式至少有两种，分别是图形接口与文字接口;\n\n\n\n#### 分区设定\n\n>CentOS 7会主动依据你的磁盘容量判断要用MBR或GPT分区方式，你也可以强迫使用GPT，在安装时按下<kbd>tab</kbd>,在最后加入`ist.gpt`。\n>\n>若安装笔记本电脑时失败，可尝试在开机时加入`linux nofb apm=off acpi=off`来关闭省电功能;\n>\n>安装过程进入分区后，请以「自定义的分区模式」来处理自己规划的分区方式;\n>\n>常见的分区为 /  /boot  BIOS boot /home\n\n![image-20221007162258318](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162258318.png)\n\n>规划后的分区如下\n\n![image-20221007162726289](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162726289.png)\n\n\n\n#### 网络设定\n\n>网卡和地址的正确配置如下\n\n![image-20221007163140672](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007163140672.png)\n\n\n\n\n\n### 登录与在线求助\n\n\n\n#### root登录\n\n>养成良好的操作习惯，尽量不要使用root 直接登入系统，应使用一般账号登入系统，有需要再转换身份可以透过「活动总览」查看系统所有使用的软件及快速启用惯用软件\n>\n>在终端机环境中，可依据提示字符为$或#判断为一般账号或root账号:\n>\n>使用`su -` 切换至root帐号\n\n\n\n#### X-图形界面与命令行界面的切换\n\n>预设情况下，Linux 提供ty1-tty6的终端机界面。\n>\n>在X的环境下想要「强制」重新启动X的组合按键为:<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>Backspace</KBD>\n>\n>从X环境切换至命令行界面的组合按键为：<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>F2-F6</KBD>\n>\n>无图形界面下切换X桌面使用`startx`指令，不过不一定能够使用。\n>\n>启动`graphic.target`服务并设置为默认，则自动启动图形界面\n\n\n\n#### 语系支持\n\n>如果输入指令出现乱码，需要进行语系的更改。\n\n![image-20221007165447135](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007165447135.png)\n\n\n\n#### 组合按键\n\n>组合按键中, <kbd>Tab</kbd>按键 可做为命令补齐/档名补齐或/参数选项补齐\n>\n><kbd>Ctrl+c</kbd>可 以中断目前正在运作中的程序;\n\n\n\n#### 帮助系统\n\n>man指令是一个自带的帮助系统，可以查询指令以及系统文件的作用，例如，`man ls`以及`man issue`\n>\n>man page说明后面的数字中， 1代表一般账号可用指令，8代表系统管理员常用指令，5代表系统配置文件格式\n>\n\n![image-20221007193137847](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193137847.png)\n\n>info指令也是一个帮助系统，可以采用浏览器的方式进行点击跳转，可将一份说明文件拆成多个节点(node)显示，并具有类似超链接的功能，增加易读性;\n\n![image-20221007170037728](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170037728.png)\n\n>此外可使用的帮助系统还有/usr/share/doc   --help  以及`tldr`，后者需要自行安装。\n\n\n\n#### 文本编辑器nano\n\n![image-20221007170237461](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170237461.png)\n\n\n\n#### 关机与注销\n\n>系统需正确的关机比较不容易损坏，可使用shutdown, poweroff等指令关机。\n>\n>shutdown指令只有root管理员能够下达。\n>\n>使用exit注销帐号，返回登录界面\n>\n>在关机之前最好使用sync指令将内存中的数据写入储存。\n\n\n\n### 文件权限与目录管理\n\n\n\n#### rwx权限\n\n>Linux的每个文件中，可分别给予使用者、群组与其他人三种身份个别的rwx权限;\n>\n>利用`ls -l`显示的文件属性中，第一个字段是文件的权限，共有十个位，第一个位是文件类型，接下来三个为一组共三组，为使用者、群组、其他人的权限，权限有r,w,x三种;\n\n![image-20221007170605114](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png)\n\n>对于文件来说\n>\n>>r：可读取此一文件的实际内容，如读取文本文件的文字内容等\n>\n>>w：可以编辑、新增或者是修改该文件的内容(但不含删除该文件);\n>\n>>x：该文件具有可以被系统执行的权限。\n>>\n\n>对于目录来说\n>\n>>r ：浏览目录内容\n>\n>>w ：增加或删除目录内容\n>\n>>x ：切换进入目录，使得目录成为工作目录\n\n![image-20221007171002409](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171002409.png)\n\n>文件的类型有以下几种\n\n![image-20221007193427772](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193427772.png)\n\n\n\n#### 隐藏文件\n\n>如果档名之前多一一个`.`，则代表这个文件为隐藏文件，隐藏文件需要使用`ls -a`查看\n\n![image-20221007170605114](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png)\n\n\n\n#### 修改文件权限\n\n>若需要root的权限时，可以使用`su-`这个指令来切换身份。处理完毕则使用exit 离开su的指令环境。\n>\n>更改文件的群组支持可用`chgrp`,修改文件的拥有者可用`chown`,修改文件的权限可用`chmod`\n>\n>`chmod`修改权限的方法有两种，分别是符号法与数字法，数字法中r,w,x分数为4.2.1;\n\n>>符号法\n>\n>>`chmod +rx xx.py`\n>\n\n![image-20221007193514337](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193514337.png)\n\n>>数字法\n>\n>>`chmod 770 xx.py`\n>\n\n![image-20221007171143570](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171143570.png)\n\n#### 文件权限限制\n\n>要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给;\n>\n>能否读取到某个文件内容，跟该文件所在的目录权限也有关系,目录至少需要有x的权限。\n\n![image-20221007171118654](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171118654.png)\n\n\n\n#### FHS目录配置\n\n>根据FHS的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下FHS订定出来的四种目录特色为: shareable, unshareable, static, variable等四类;\n\n![image-20221007171342613](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171342613.png)\n\n>根据目录树架构，FHS定义三层主目录为/   /usr   /var\n\n![image-20221007171523603](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171523603.png)\n\n> 根目录/ 的结构\n\n![image-20221007171716624](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171716624.png)\n\n> /usr 目录的结构\n\n![image-20221007171808024](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171808024.png)\n\n> /var 目录的结构\n\n![image-20221007171833498](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171833498.png)\n\n> 不同目录之间的链接情况\n\n![image-20221007171914229](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171914229.png)\n\n\n\n#### 绝对路径与相对路径\n\n>绝对路径文件名为从根目录开始写起，否则都是相对路径的文件名。\n\n\n\n#### 文件操作重要指令\n\n>与目录相关的指令有: `cd, mkdir, rmdir, pwd,rm,mv,cp`等重要指令;\n>\n>`rmdir`仅能删除空目录，要删除非空目录需使用 -p 指令;\n>\n>`Is`可以检视文件的属性，尤其-d, -a, 1等选项特别重要!\n>\n>文件的复制、删除、移动可以分别使用: `cp, rm , mv`等指令来操作;\n\n\n\n#### 特殊目录\n\n![image-20221007173311358](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173311358.png)\n\n#### $PATH\n\n>用户能使用的指令是依据PATH 变量所规定的目录去搜寻的;\n>\n>加入$PATH的路径内存放的指令执行文件可以直接在shell中输入指令名来执行\n>\n>使用`PATH = “$PATH=/root”`将路径加入PATH\n\n\n\n#### 取得路径名称\n\n![image-20221007173546414](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173546414.png)\n\n\n\n#### 查看文件内容\n\n>检查文件的内容(读文件)可使用的指令包括有: `cat, tac, nl, more, lss, head, til,od`等\n>\n>`cat-n`与`nl`均可显示行号，但默认的情况下，空白行会不会编号并不相同;\n\n![image-20221007173655406](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173655406.png)\n\n> less指令使用\n\n![image-20221007173754819](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173754819.png)\n\n> od指令使用\n\n![image-20221007173838377](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173838377.png)\n\n\n\n#### 修改文件参数\n\n>touch的目的在修改文件的时间参数，但亦可用来建立空文件;\n>\n>一个文件记录的时间参数有三种，分别是access time(aime), status time (ctime), mdification time(mtime)\n\n![image-20221007193936078](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193936078.png)\n\n\n\n#### 文件的预设权限\n\n> 新建文件/目录时，新文件的预设权限使用umask来规范，其预设权限如下\n\n![image-20221007194522691](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194522691.png)\n\n>利用umask更改预设权限，更改后\n\n![image-20221007194649352](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194649352.png)\n\n![image-20221007194853337](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194853337.png)\n\n\n\n#### 文件的隐藏属性 \n\n> 除了传统的rwx权限之外，在Ex2/Ext3/Ext4/xfs文件系统中，还存在隐藏属性，以下是所有隐藏属性，最常见的隐藏属性为+i和+a\n\n![image-20221007195304005](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195304005.png)\n\n>使用chattr 给文件配置隐藏属性\n\n![image-20221007195612867](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195612867.png)\n\n> 使用lsattr显示文件隐藏属性\n\n![image-20221007195741048](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195741048.png)\n\n\n\n#### 文件的特殊权限\n\n>文件具有SUID的特殊权限时,代表当用户执行此binary程序时，在执行过程中用户会暂时具有程序拥有者的权限\n\n![image-20221007195959605](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195959605.png)\n\n>用一张漫画来说明这个权限的使用过程\n\n![image-20221007200217090](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200217090.png)\n\n>目录具有SGID的特殊权限时，代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。\n\n![image-20221007200631139](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200631139.png)\n\n>目录具有SBIT的特殊权限时，代表在该目录下用户建立的文件只有自己与root能够删除\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200730676.png\" alt=\"image-20221007200730676\" style=\"zoom:80%;\" />\n\n>给文件或目录加上SUID，SGID，SBIT权限，只需要在chmod 使用数字授权时候在标准数字之前加上代表三个权限的数字，SUID为4,  SGID为2,  SBIT为1\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201026907.png\" alt=\"image-20221007201026907\" style=\"zoom:80%;\" />\n\n\n\n#### 观察文件类型\n\n> 使用file指令观察文件类型\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201131838.png\" alt=\"image-20221007201131838\"  />\n\n\n\n#### 指令与文件的查找\n\n> 搜寻指令的完整文件名可用which 或type ，这两个指令都是透过PATH变量来搜寻文件名;\n\n![image-20221007201449046](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201449046.png)\n\n> 搜寻文件的完整档名可以使用whereis 找特定目录或locate 到数据库去搜寻，而不实际搜寻文件系统;\n\n![image-20221007201507176](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201507176.png)\n\n> 用find可以加入许多选项来直接查询文件系统，以获得自己想要知道的档名，find指令复杂多变。具体可以参考\n>\n> `man find`\n\n\n\n#### 权限和指令之间的关系（整合）\n\n![image-20221007201747868](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201747868.png)\n\n\n\n\n\n### 磁盘划分和目录挂载\n\n\n\n#### MBR和GPT\n\n![image-20221007215146933](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215146933.png)\n\n#### 文件系统\n\n\n\n**Ext文件系统**\n\n>基本上Linux 的传统文件系统为ExI2，该文件系统内的信息主要有:\n>\n>superblock: 记录此filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等;\n>\n>inode:记录文件的属性，一个 文件占用-一个inode,同时记录此文件的数据所在的block 号码;\n>\n>block:实际记录文件的内容，若文件太大时，会占用多个block.\n>\n>这种数据存取的方式我们称为索引式文件系统\n\n![image-20221007215534068](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215534068.png)\n\n> 相比起来FAT格式的读取方式是这样的\n\n![image-20221007215712073](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215712073.png)\n\n>Ext2文件系统主要有: boot sector, superblock, inode bitmap, block bitmap, inode table, data block等六大部分。\n>\n>Ext2文件系统的示意图如下.\n\n![image-20221007215921814](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215921814.png)\n\n>data block是用来放置文件内容数据地方，在Ext2 文件系统中所支持的block 大小有1K,2K 及4K\n\n>inode 记录文件的属性/权限等数据，其他重要项目为:每个 inode大小均为固定，128/256bytes 两种基本容量。\n>\n>每个文件都仅会占用一个inode而已，因此文件系统能够建立的文件数量与inode 的数量有关;\n>\n>文件的block 在记录文件的实际数据，目录的block 则在记录该目录底下文件名与其inode 号码的对照表;\n\n![image-20221007220501891](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007220501891.png)\n\n>superblock记录整个filesystem的信息，主要记录inode和block的总量，未使用和已使用的inode和block，大小等。\n\n\n\n>使用dump2fs查询ext家族superblock的指令\n\n![image-20221007221002782](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221002782.png)\n\n![image-20221007221040698](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221040698.png)\n\n\n\n**xfs文件系统**\n\n>xfs文件系统主要分为三个部分，资料区，文件系统活动登录区，和实时运作区\n\n\n\n#### 文件系统的操作\n\n\n\n**查看文件系统磁盘使用量**\n\n>查看文件系统的磁盘使用量使用指令df和du\n\n>df列出文件系统的整体磁盘使用量\n\n![image-20221007221859758](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221859758.png)\n\n>du 评估文件系统各个文件的磁盘使用量\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221934486.png\" alt=\"image-20221007221934486\"  />\n\n\n\n**创建链接**\n\n>创建链接有两种类型，分别是实体链接与符号链接的建立\n\n>实体链接的建立，是在某个目录下新增一个链接到某inode号码的关联记录，这两个档名链接到同一个inode，无论你删除哪一个文档，文件的inode和block都是存在的，从另一个都可以访问到对应的文件。\n\n![image-20221007222352413](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222352413.png)\n\n>其链接模式如图所示\n\n![image-20221007222821931](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222821931.png)\n\n> 符号链接的建立是在建立一个独立的文件，而这个文件会让数据读取指向link的文件，所以当被链接的原文件被删除后，符号链接也作废了，有点像windows的快捷方式。\n\n![image-20221007223057831](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223057831.png)\n\n>其链接模式如图所示\n\n![image-20221007223128721](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223128721.png)\n\n\n\n#### 磁盘的分区，格式化与挂载\n\n\n\n**观察磁盘分区状态** \n\n> 使用lsblk指令列出系统上所有磁盘列表\n\n![image-20221007223351460](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223351460.png)\n\n>使用blkid列出装置的UUID，文件系统格式，等参数\n\n![image-20221007223558635](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223558635.png)\n\n>使用parted列出磁盘的分区表类型与分区信息\n\n![image-20221007223638672](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223638672.png)\n\n\n\n**进行磁盘分区**\n\n>磁盘分区中，使用GPT格式的磁盘使用gdisk指令，使用MBR格式的磁盘使用fdisk指令\n>\n>先要透过lsblk和blkid找到磁盘，然后利用part查看分区表类型，最后再确定使用的指令\n\n![image-20221007223815647](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223815647.png)\n\n>gdisk中，p为查看分区情况，n为增加一个分区，d为删除一个分区，q为不保存退出，w为保存退出\n>\n>其中增加分区的n，在LastSector这里使用+500M或+2G这样的描述划分存储量\n>\n>分区后w保存，而后使用partprobe -s  更新分区表信息\n\n![image-20221007224251998](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224251998.png)\n\n\n\n**磁盘格式化**\n\n>使用mkfs.xxx指令对不同的文件系统进行格式化，例如将分区格式化为xfs格式，使用mkfs.xfs指令进行\n\n![image-20221007224433502](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224433502.png)\n\n\n\n**文件系统检验**\n\n> 使用xfs_repair ，fsck.ext4 对错乱的文件系统进行整理修复\n\n![image-20221007224625761](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224625761.png)\n\n\n\n **文件系统挂载**\n\n>使用mount进行挂载.\n\n![image-20221007224832732](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224832732.png)\n\n\n\n>挂载CD或者DVD时，同样，一般将之挂在到根目录下的 /mnt目录查看\n\n>重新挂载使用指令`mount -o remouont,rw,auto`\n\n>将某个目录挂载到另一个目录使用指令`mount --bind /var /data/var`\n\n>使用unmount指令卸出\n\n![image-20221007225559098](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225559098.png)\n\n>使用xfs_admin和tune2fs修改labelname和UUID\n\n![image-20221007225756390](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225756390.png)\n\n>设定开机挂载 ，将记录写入etc/fstab，格式模仿上面的就是了\n\n>可以使用dd制作空的大文件再挂载到某个目录下当分区用\n\n![image-20221007230208670](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007230208670.png)\n\n> 建立swap分区，可以通过增加分区进行，`swapon`，也通过空大文件挂载进行\n\n> 挂载操作也可以使用parted实现，具体操作和gdisk相差不大\n\n\n\n### 文件压缩和备份\n\n\n\n#### 常见的压缩指令\n\n> 压缩指令为透过一些运算方法去将原本的文件进行压缩，以减少文件所占用的磁盘容量。压缩前与压缩后的文件所占用的磁盘容量比值，就可以被称为是[压缩比」\n\n>常见的压缩指令有gzip，bzip2和xz三种，他们的用法都差不多，zcat，bzcat和xzcat也是用于查看压缩文件内容，其使用方法也大多相同\n\n![image-20221008221342368](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221342368.png)\n\n![image-20221008221751871](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221751871.png)\n\n\n\n#### 打包指令\n\n>使用tar指令对文件进行打包，tar指令的常用选项如下\n\n![image-20221008221926526](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221926526.png)\n\n>简而言之可以归纳为如下的指令 \n\n![image-20221008221935274](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221935274.png)\n\n>tar指令还可以对目录进行备份，加上-p参数保留原有权限，加上-v参数会显示作用中的文件名，-J参数会花更多时间。\n\n![image-20221008222243419](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222243419.png)\n\n> 解压时候，如果只需要解压单一文件，可以使用grep指令\n\n![image-20221008222408951](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222408951.png)\n\n> 如果想排除某些文件可以使用exclude参数\n\n![image-20221008222540399](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222540399.png)\n\n>只备份比某个时间新的文件可以使用--newer-time参数\n\n![image-20221008222708221](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222708221.png)\n\n\n\n#### 文件系统备份\n\n\n\n>xfs系统的备份可以使用xfs_dump指令进行，使用xfsrestore指令复原\n\n![image-20221008223119606](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223119606.png)\n\n>还可以 进行差异备份 \n\n![image-20221008223533596](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223533596.png)\n\n>可以使用xfstore -I指令进行查看备份的数据内容以及label\n\n![image-20221008223642483](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223642483.png)\n\n>复原的时候也可以分部进行，按照label进行定位复原\n\n![image-20221008223718524](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223718524.png)\n\n>使用-i参数进入互动备份界面\n\n![image-20221008223902471](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223902471.png)\n\n\n\n#### 光盘写入工具\n\n\n\n>使用mkisofs指令建立映像档，储存需要的数据。\n\n![image-20221008224235226](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008224235226.png)\n\n>这样操作会导致文件的混乱，所以我们使用-graft-point参数进行划分\n\n![image-20221008231311733](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231311733.png)\n\n**制作可开机光盘映像**\n\n\n\n>取得iso映像之后，使用isoinfo指令对iso文件进行查看\n\n![image-20221008231624761](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231624761.png)\n\n>将iso镜像挂载到/mnt目录，而后将所有数据完整到/srv/newed里面，使用rsync指令完整复制所有权限属性等数据，这样在/srv/newed里面就有了完整的映像档内容。\n\n![image-20221008231957898](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231957898.png)\n\n>按照需要对iso镜像进行修改后恢复其为iso镜像即可。\n\n![image-20221008232147990](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232147990.png)\n\n>进行光盘刻录操作，centos是wdim指令，自己去查询自己所在的distribution中的光盘刻录指令，这里以wdim为例子\n\n![image-20221008232320530](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232320530.png)\n\n>先得找到刻录机的位置，一般都是/dev/sr0这样的文件名，QEMU是虚拟机的虚拟光驱，而ASUS是真实光驱\n\n![image-20221008232451568](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232451568.png)\n\n>最后使用iso进行刻录操作\n\n![image-20221008232622911](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232622911.png)\n\n>最后测试挂载一下，检验内容\n\n![image-20221008232714078](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232714078.png)\n\n\n\n#### 其他指令\n\n>我们上面建立空的大文件使用的dd指令也可以进行备份操作，其中有一个重要操作就是将刚才的刻录后的光盘进行一个备份\n\n![image-20221008232844977](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232844977.png)\n\n>同样，这里也介绍了如何将iso镜像刻录到usb磁盘作为安装盘\n\n![image-20221008233105343](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008233105343.png)\n\n\n\n>cpio指令也是一个备份指令，可以备份任何东西，但是要和find这类查询指令配合一起使用。使用><进行数据流重定向，从而进行备份和还原。\n\n![image-20221009220206332](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220206332.png)\n\n![image-20221009220535972](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220535972.png)\n\n\n\n\n\n### Vim程序编辑器\n\n\n\n#### Vim的三种模式\n\n>vi有三种模式，- -般指令模式可变换到编辑与指令列模式，但编辑模式与指令列模式不能互换;一般模式切换编辑模式，可以通过i，a，o等指令，按下`ESC`键切换到一般模式，一般模式切换到指令列模式输入：，/，？切换，同样按下`ESC`键回到一般模式。\n\n![image-20221009222419976](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222419976.png)\n\n\n\n#### 切换指令列模式\n\n>使用`:`切换至指令列模式，可以在此基础上进行退出`q`，储存`w`，读取`r`，临时跳出等操作`！`\n\n![image-20221009224809443](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224809443.png)\n\n#### 移动指令\n\n>按下`hjkl`四个键可以上下左右移动，同样移动到行首`0`，行尾`$`,文件头`gg`，文件末尾`G`，某一列`nG`，向下移动几列`5j`，都可以使用不同的指令进行，其他具体指令参考如下。\n\n![image-20221009222725370](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222725370.png)\n\n\n\n​       \n\n#### 搜索与替代指令\n\n>**搜索，**使用`/word`和`？word`进行搜索，前者向下搜索，后者向上搜索，使用`n`和`N`指令移动到下一个匹配位置，\n\n![image-20221009223303496](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223303496.png)\n\n> **替代，**使用`：n1,n2s/word1/word2/g`将匹配到的字符进行替换，其他使用方式如下\n\n![image-20221009223454878](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223454878.png)\n\n\n\n#### 删除和复制指令\n\n>**删除**，使用`x`删除光标位置字符，使用`dd`删除本行，使用`d1G`删除本行到文件末尾，其他使用如下\n\n![image-20221009223740393](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223740393.png)\n\n\n\n>**复制，**使用yy复制本行，使用`y1G`复制本行到文件末尾，其他相似使用如下\n\n![image-20221009223916781](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223916781.png)\n\n\n\n>粘贴，使用p和P将复制的数据贴在光标所指向的上一列或下一列\n\n![image-20221009224055037](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224055037.png)\n\n\n\n>**结合，**使用`J`指令合并上下列\n>\n>使用`c`重复删除多个指令，这个实际上和`ndd`差不多\n\n![image-20221009224324625](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224324625.png)\n\n\n\n>**重复，**使用`u`指令和`ctrl+r`指令，复原和重做上一个动作，使用.重复上一个操作\n\n![image-20221009224516362](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224516362.png)\n\n\n\n#### 暂存与救援，警告\n\n> 不正常中断Vim后，再打开文件会有六个可用按钮分别对应不同的还原模式\n\n![image-20221010220335279](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220335279.png)\n\n\n\n#### 区块选择\n\n> 在一般模式下，长按v再左右上下移动，可以选中周边的区块，选中后可以使用不同的指令进行操作。\n\n![image-20221010220618713](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220618713.png)\n\n\n\n#### 多文件和多窗口\n\n>在打开文件时候，可以同时打开多个文件，这样进行操作的时候就可以使用不同的指令进行切换，例如使用`vim hosts /etc/hosts`开启两个文件后就可以使用，`n`和`N`指令进行上下切换。\n\n![image-20221010220854275](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220854275.png)\n\n\n\n>在打开一个文件的时候，可以使用`:sp file.txt`打开另一个窗口，并启动另一个文件`file.txt`\n\n![image-20221010222456818](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222456818.png)\n\n>使用`w+j`向上切换，同理向下切换\n\n![image-20221010222553234](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222553234.png)\n\n\n\n#### 环境设定与记录\n\n\n\n>vim的环境设定参数能够提供vim启动的预设环境，常用的环境设定参数如下\n\n![](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223135939.png)\n\n>当然，可以在进入vim编辑之后再设定，但是每次设定多少有点麻烦，vim的设定值放置在 ～/vimrc这个文件中，如果没有可以自己手动建立，而后将所希望的设定值写入。\n\n![image-20221010223413285](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223413285.png)\n\n\n\n#### 一张图总结Vim\n\n![image-20221012223355695](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221012223355695.png)\n\n","source":"_posts/Linux操作与使用.md","raw":"---\ntitle: Linux操作与使用\ndate: 2022-10-05 20:06:11\ntags:\n- Linux \n- 操作系统\n- 命令行\ncategories:\n- Linux/Unix\n---\n\n## Linux操作与使用\n\n#### 目录\n\n>操作系统与硬件\n>\n>主机规划与磁盘分区\n>\n>CentoOS安装\n>\n>登录与在线求助\n>\n>文件权限与目录管理\n>\n>磁盘划分与目录挂载\n>\n>系统压缩与备份\n>\n>程序编辑器vim\n>\n\n\n\n### 操作系统与硬件\n\n\n\n#### 操作系统\n\n>操作系统主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、负责进程管理以及系统调用等等。因此，只要能够让硬件准备妥当的情况，就是一个合格的操作系统了。\n\n\n\n#### Unix\n\n>Unix 的前身是由贝尔实验室(Bell lab.)的Ken Thompson利用汇编语言写成的，后来在 1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。\n\n\n\n#### BSD\n\n>1977年由Bill Joy释出BSD (Berkeley Software Distribution),这些称为Unix-like的操作系统.\n\n\n\n#### Minix\n\n>1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供原始码以及软件;\n\n\n\n#### GNU计划\n\n>1984年由Richard Sallman提倡GNU计划，倡导自由软件(Free software)，强调其软件可以 「自由的取得、复制、修改与再发行」，并规范出GPL授权模式，任何 GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。\n\n\n\n#### Linux Kernel\n\n>从Linux kernel 3.0开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本(MainLine) 为依据，并提供长期支持版本 (longterm)来加强某些功能的持续维护。\n\n\n\n#### Linux Distrbutiom\n\n>Linux distributions的组成含有: [Linux Kernel + Free Software + Documentations(Tools) +可完全安装的程序」所制成的一套完整的系统。\n>\n>常见的Linux distributions分类有[商业、社群」分类法，或「RPM、DPKG」 分类法\n\n\n\n### 主机规划与硬盘分区\n\n\n\n#### 主机规划\n\n>主机规划一定要按照自己的需求来进行使用。\n\n\n\n#### 装置文件名\n\n>磁盘装置文件名通常分为两种，实际SATA/USB装置文件名为/dev/sd[a-p], 而虚拟机的装置可能为/dev/vd[a-p]\n\n\n\n#### MBR分区\n\n> 磁盘的第一个扇区 主要记录了两个重要的信息，一是要启动记录区(Master Boot Record, MBR):可以安装开机管理程序的地方,有446 bytes ，二是分区表(artition table):记录整颗硬盘分区的状态，有64 bytes;\n>\n> 磁盘的MBR分区方式中，主要与延伸分区最多可以有四个，所以逻辑分区的装置文件名号码，一定是由从5号开始。\n\n![image-20221007192837574](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192837574.png)\n\n> 如果采用逻辑分区，那么磁盘的规划会变成这样\n\n![image-20221007192922041](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192922041.png)\n\n\n\n#### GPT分区\n\n>如果磁盘容量大于2TB以上时，系统会自动使用GPT分区方式来处理磁盘分区。\n>\n>GPT分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区.\n>\n>某些操作系统要使用GPT分区时，必须要搭配UEFI的新型BIOS 格式才可安装使用。\n\n![image-20221007192955934](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192955934.png)\n\n#### 开机的流程\n\n>开机的流程由: BIOS-->MBR-->boot loader-->核心文件。\n>\n>boot loader的功能主要有:提供选单、加载核心、转交控制权给其他loader。\n>\n>boot loader可以安装的地点有两个，分别是MBR与boot sector,这个特色造就了多重引导功能。\n\n![image-20221007193014623](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193014623.png)\n\n#### 目录树\n\n```\nLinux 操作系统的文件使用目录树系统，与磁盘的对应需要有[挂载」的动作才行;\n```\n\n![image-20221007161907887](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007161907887.png)\n\n> 挂载示意如下：\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162003856.png\" alt=\"image-20221007162003856\" style=\"zoom:80%;\" />\n\n\n\n\n\n### CentOS安装\n\n\n\n#### 安装模式\n\n>安装CentOS 7.x的模式至少有两种，分别是图形接口与文字接口;\n\n\n\n#### 分区设定\n\n>CentOS 7会主动依据你的磁盘容量判断要用MBR或GPT分区方式，你也可以强迫使用GPT，在安装时按下<kbd>tab</kbd>,在最后加入`ist.gpt`。\n>\n>若安装笔记本电脑时失败，可尝试在开机时加入`linux nofb apm=off acpi=off`来关闭省电功能;\n>\n>安装过程进入分区后，请以「自定义的分区模式」来处理自己规划的分区方式;\n>\n>常见的分区为 /  /boot  BIOS boot /home\n\n![image-20221007162258318](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162258318.png)\n\n>规划后的分区如下\n\n![image-20221007162726289](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162726289.png)\n\n\n\n#### 网络设定\n\n>网卡和地址的正确配置如下\n\n![image-20221007163140672](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007163140672.png)\n\n\n\n\n\n### 登录与在线求助\n\n\n\n#### root登录\n\n>养成良好的操作习惯，尽量不要使用root 直接登入系统，应使用一般账号登入系统，有需要再转换身份可以透过「活动总览」查看系统所有使用的软件及快速启用惯用软件\n>\n>在终端机环境中，可依据提示字符为$或#判断为一般账号或root账号:\n>\n>使用`su -` 切换至root帐号\n\n\n\n#### X-图形界面与命令行界面的切换\n\n>预设情况下，Linux 提供ty1-tty6的终端机界面。\n>\n>在X的环境下想要「强制」重新启动X的组合按键为:<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>Backspace</KBD>\n>\n>从X环境切换至命令行界面的组合按键为：<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>F2-F6</KBD>\n>\n>无图形界面下切换X桌面使用`startx`指令，不过不一定能够使用。\n>\n>启动`graphic.target`服务并设置为默认，则自动启动图形界面\n\n\n\n#### 语系支持\n\n>如果输入指令出现乱码，需要进行语系的更改。\n\n![image-20221007165447135](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007165447135.png)\n\n\n\n#### 组合按键\n\n>组合按键中, <kbd>Tab</kbd>按键 可做为命令补齐/档名补齐或/参数选项补齐\n>\n><kbd>Ctrl+c</kbd>可 以中断目前正在运作中的程序;\n\n\n\n#### 帮助系统\n\n>man指令是一个自带的帮助系统，可以查询指令以及系统文件的作用，例如，`man ls`以及`man issue`\n>\n>man page说明后面的数字中， 1代表一般账号可用指令，8代表系统管理员常用指令，5代表系统配置文件格式\n>\n\n![image-20221007193137847](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193137847.png)\n\n>info指令也是一个帮助系统，可以采用浏览器的方式进行点击跳转，可将一份说明文件拆成多个节点(node)显示，并具有类似超链接的功能，增加易读性;\n\n![image-20221007170037728](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170037728.png)\n\n>此外可使用的帮助系统还有/usr/share/doc   --help  以及`tldr`，后者需要自行安装。\n\n\n\n#### 文本编辑器nano\n\n![image-20221007170237461](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170237461.png)\n\n\n\n#### 关机与注销\n\n>系统需正确的关机比较不容易损坏，可使用shutdown, poweroff等指令关机。\n>\n>shutdown指令只有root管理员能够下达。\n>\n>使用exit注销帐号，返回登录界面\n>\n>在关机之前最好使用sync指令将内存中的数据写入储存。\n\n\n\n### 文件权限与目录管理\n\n\n\n#### rwx权限\n\n>Linux的每个文件中，可分别给予使用者、群组与其他人三种身份个别的rwx权限;\n>\n>利用`ls -l`显示的文件属性中，第一个字段是文件的权限，共有十个位，第一个位是文件类型，接下来三个为一组共三组，为使用者、群组、其他人的权限，权限有r,w,x三种;\n\n![image-20221007170605114](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png)\n\n>对于文件来说\n>\n>>r：可读取此一文件的实际内容，如读取文本文件的文字内容等\n>\n>>w：可以编辑、新增或者是修改该文件的内容(但不含删除该文件);\n>\n>>x：该文件具有可以被系统执行的权限。\n>>\n\n>对于目录来说\n>\n>>r ：浏览目录内容\n>\n>>w ：增加或删除目录内容\n>\n>>x ：切换进入目录，使得目录成为工作目录\n\n![image-20221007171002409](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171002409.png)\n\n>文件的类型有以下几种\n\n![image-20221007193427772](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193427772.png)\n\n\n\n#### 隐藏文件\n\n>如果档名之前多一一个`.`，则代表这个文件为隐藏文件，隐藏文件需要使用`ls -a`查看\n\n![image-20221007170605114](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png)\n\n\n\n#### 修改文件权限\n\n>若需要root的权限时，可以使用`su-`这个指令来切换身份。处理完毕则使用exit 离开su的指令环境。\n>\n>更改文件的群组支持可用`chgrp`,修改文件的拥有者可用`chown`,修改文件的权限可用`chmod`\n>\n>`chmod`修改权限的方法有两种，分别是符号法与数字法，数字法中r,w,x分数为4.2.1;\n\n>>符号法\n>\n>>`chmod +rx xx.py`\n>\n\n![image-20221007193514337](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193514337.png)\n\n>>数字法\n>\n>>`chmod 770 xx.py`\n>\n\n![image-20221007171143570](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171143570.png)\n\n#### 文件权限限制\n\n>要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给;\n>\n>能否读取到某个文件内容，跟该文件所在的目录权限也有关系,目录至少需要有x的权限。\n\n![image-20221007171118654](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171118654.png)\n\n\n\n#### FHS目录配置\n\n>根据FHS的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下FHS订定出来的四种目录特色为: shareable, unshareable, static, variable等四类;\n\n![image-20221007171342613](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171342613.png)\n\n>根据目录树架构，FHS定义三层主目录为/   /usr   /var\n\n![image-20221007171523603](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171523603.png)\n\n> 根目录/ 的结构\n\n![image-20221007171716624](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171716624.png)\n\n> /usr 目录的结构\n\n![image-20221007171808024](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171808024.png)\n\n> /var 目录的结构\n\n![image-20221007171833498](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171833498.png)\n\n> 不同目录之间的链接情况\n\n![image-20221007171914229](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171914229.png)\n\n\n\n#### 绝对路径与相对路径\n\n>绝对路径文件名为从根目录开始写起，否则都是相对路径的文件名。\n\n\n\n#### 文件操作重要指令\n\n>与目录相关的指令有: `cd, mkdir, rmdir, pwd,rm,mv,cp`等重要指令;\n>\n>`rmdir`仅能删除空目录，要删除非空目录需使用 -p 指令;\n>\n>`Is`可以检视文件的属性，尤其-d, -a, 1等选项特别重要!\n>\n>文件的复制、删除、移动可以分别使用: `cp, rm , mv`等指令来操作;\n\n\n\n#### 特殊目录\n\n![image-20221007173311358](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173311358.png)\n\n#### $PATH\n\n>用户能使用的指令是依据PATH 变量所规定的目录去搜寻的;\n>\n>加入$PATH的路径内存放的指令执行文件可以直接在shell中输入指令名来执行\n>\n>使用`PATH = “$PATH=/root”`将路径加入PATH\n\n\n\n#### 取得路径名称\n\n![image-20221007173546414](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173546414.png)\n\n\n\n#### 查看文件内容\n\n>检查文件的内容(读文件)可使用的指令包括有: `cat, tac, nl, more, lss, head, til,od`等\n>\n>`cat-n`与`nl`均可显示行号，但默认的情况下，空白行会不会编号并不相同;\n\n![image-20221007173655406](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173655406.png)\n\n> less指令使用\n\n![image-20221007173754819](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173754819.png)\n\n> od指令使用\n\n![image-20221007173838377](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173838377.png)\n\n\n\n#### 修改文件参数\n\n>touch的目的在修改文件的时间参数，但亦可用来建立空文件;\n>\n>一个文件记录的时间参数有三种，分别是access time(aime), status time (ctime), mdification time(mtime)\n\n![image-20221007193936078](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193936078.png)\n\n\n\n#### 文件的预设权限\n\n> 新建文件/目录时，新文件的预设权限使用umask来规范，其预设权限如下\n\n![image-20221007194522691](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194522691.png)\n\n>利用umask更改预设权限，更改后\n\n![image-20221007194649352](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194649352.png)\n\n![image-20221007194853337](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194853337.png)\n\n\n\n#### 文件的隐藏属性 \n\n> 除了传统的rwx权限之外，在Ex2/Ext3/Ext4/xfs文件系统中，还存在隐藏属性，以下是所有隐藏属性，最常见的隐藏属性为+i和+a\n\n![image-20221007195304005](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195304005.png)\n\n>使用chattr 给文件配置隐藏属性\n\n![image-20221007195612867](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195612867.png)\n\n> 使用lsattr显示文件隐藏属性\n\n![image-20221007195741048](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195741048.png)\n\n\n\n#### 文件的特殊权限\n\n>文件具有SUID的特殊权限时,代表当用户执行此binary程序时，在执行过程中用户会暂时具有程序拥有者的权限\n\n![image-20221007195959605](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195959605.png)\n\n>用一张漫画来说明这个权限的使用过程\n\n![image-20221007200217090](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200217090.png)\n\n>目录具有SGID的特殊权限时，代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。\n\n![image-20221007200631139](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200631139.png)\n\n>目录具有SBIT的特殊权限时，代表在该目录下用户建立的文件只有自己与root能够删除\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200730676.png\" alt=\"image-20221007200730676\" style=\"zoom:80%;\" />\n\n>给文件或目录加上SUID，SGID，SBIT权限，只需要在chmod 使用数字授权时候在标准数字之前加上代表三个权限的数字，SUID为4,  SGID为2,  SBIT为1\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201026907.png\" alt=\"image-20221007201026907\" style=\"zoom:80%;\" />\n\n\n\n#### 观察文件类型\n\n> 使用file指令观察文件类型\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201131838.png\" alt=\"image-20221007201131838\"  />\n\n\n\n#### 指令与文件的查找\n\n> 搜寻指令的完整文件名可用which 或type ，这两个指令都是透过PATH变量来搜寻文件名;\n\n![image-20221007201449046](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201449046.png)\n\n> 搜寻文件的完整档名可以使用whereis 找特定目录或locate 到数据库去搜寻，而不实际搜寻文件系统;\n\n![image-20221007201507176](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201507176.png)\n\n> 用find可以加入许多选项来直接查询文件系统，以获得自己想要知道的档名，find指令复杂多变。具体可以参考\n>\n> `man find`\n\n\n\n#### 权限和指令之间的关系（整合）\n\n![image-20221007201747868](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201747868.png)\n\n\n\n\n\n### 磁盘划分和目录挂载\n\n\n\n#### MBR和GPT\n\n![image-20221007215146933](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215146933.png)\n\n#### 文件系统\n\n\n\n**Ext文件系统**\n\n>基本上Linux 的传统文件系统为ExI2，该文件系统内的信息主要有:\n>\n>superblock: 记录此filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等;\n>\n>inode:记录文件的属性，一个 文件占用-一个inode,同时记录此文件的数据所在的block 号码;\n>\n>block:实际记录文件的内容，若文件太大时，会占用多个block.\n>\n>这种数据存取的方式我们称为索引式文件系统\n\n![image-20221007215534068](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215534068.png)\n\n> 相比起来FAT格式的读取方式是这样的\n\n![image-20221007215712073](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215712073.png)\n\n>Ext2文件系统主要有: boot sector, superblock, inode bitmap, block bitmap, inode table, data block等六大部分。\n>\n>Ext2文件系统的示意图如下.\n\n![image-20221007215921814](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215921814.png)\n\n>data block是用来放置文件内容数据地方，在Ext2 文件系统中所支持的block 大小有1K,2K 及4K\n\n>inode 记录文件的属性/权限等数据，其他重要项目为:每个 inode大小均为固定，128/256bytes 两种基本容量。\n>\n>每个文件都仅会占用一个inode而已，因此文件系统能够建立的文件数量与inode 的数量有关;\n>\n>文件的block 在记录文件的实际数据，目录的block 则在记录该目录底下文件名与其inode 号码的对照表;\n\n![image-20221007220501891](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007220501891.png)\n\n>superblock记录整个filesystem的信息，主要记录inode和block的总量，未使用和已使用的inode和block，大小等。\n\n\n\n>使用dump2fs查询ext家族superblock的指令\n\n![image-20221007221002782](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221002782.png)\n\n![image-20221007221040698](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221040698.png)\n\n\n\n**xfs文件系统**\n\n>xfs文件系统主要分为三个部分，资料区，文件系统活动登录区，和实时运作区\n\n\n\n#### 文件系统的操作\n\n\n\n**查看文件系统磁盘使用量**\n\n>查看文件系统的磁盘使用量使用指令df和du\n\n>df列出文件系统的整体磁盘使用量\n\n![image-20221007221859758](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221859758.png)\n\n>du 评估文件系统各个文件的磁盘使用量\n\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221934486.png\" alt=\"image-20221007221934486\"  />\n\n\n\n**创建链接**\n\n>创建链接有两种类型，分别是实体链接与符号链接的建立\n\n>实体链接的建立，是在某个目录下新增一个链接到某inode号码的关联记录，这两个档名链接到同一个inode，无论你删除哪一个文档，文件的inode和block都是存在的，从另一个都可以访问到对应的文件。\n\n![image-20221007222352413](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222352413.png)\n\n>其链接模式如图所示\n\n![image-20221007222821931](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222821931.png)\n\n> 符号链接的建立是在建立一个独立的文件，而这个文件会让数据读取指向link的文件，所以当被链接的原文件被删除后，符号链接也作废了，有点像windows的快捷方式。\n\n![image-20221007223057831](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223057831.png)\n\n>其链接模式如图所示\n\n![image-20221007223128721](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223128721.png)\n\n\n\n#### 磁盘的分区，格式化与挂载\n\n\n\n**观察磁盘分区状态** \n\n> 使用lsblk指令列出系统上所有磁盘列表\n\n![image-20221007223351460](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223351460.png)\n\n>使用blkid列出装置的UUID，文件系统格式，等参数\n\n![image-20221007223558635](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223558635.png)\n\n>使用parted列出磁盘的分区表类型与分区信息\n\n![image-20221007223638672](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223638672.png)\n\n\n\n**进行磁盘分区**\n\n>磁盘分区中，使用GPT格式的磁盘使用gdisk指令，使用MBR格式的磁盘使用fdisk指令\n>\n>先要透过lsblk和blkid找到磁盘，然后利用part查看分区表类型，最后再确定使用的指令\n\n![image-20221007223815647](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223815647.png)\n\n>gdisk中，p为查看分区情况，n为增加一个分区，d为删除一个分区，q为不保存退出，w为保存退出\n>\n>其中增加分区的n，在LastSector这里使用+500M或+2G这样的描述划分存储量\n>\n>分区后w保存，而后使用partprobe -s  更新分区表信息\n\n![image-20221007224251998](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224251998.png)\n\n\n\n**磁盘格式化**\n\n>使用mkfs.xxx指令对不同的文件系统进行格式化，例如将分区格式化为xfs格式，使用mkfs.xfs指令进行\n\n![image-20221007224433502](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224433502.png)\n\n\n\n**文件系统检验**\n\n> 使用xfs_repair ，fsck.ext4 对错乱的文件系统进行整理修复\n\n![image-20221007224625761](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224625761.png)\n\n\n\n **文件系统挂载**\n\n>使用mount进行挂载.\n\n![image-20221007224832732](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224832732.png)\n\n\n\n>挂载CD或者DVD时，同样，一般将之挂在到根目录下的 /mnt目录查看\n\n>重新挂载使用指令`mount -o remouont,rw,auto`\n\n>将某个目录挂载到另一个目录使用指令`mount --bind /var /data/var`\n\n>使用unmount指令卸出\n\n![image-20221007225559098](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225559098.png)\n\n>使用xfs_admin和tune2fs修改labelname和UUID\n\n![image-20221007225756390](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225756390.png)\n\n>设定开机挂载 ，将记录写入etc/fstab，格式模仿上面的就是了\n\n>可以使用dd制作空的大文件再挂载到某个目录下当分区用\n\n![image-20221007230208670](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007230208670.png)\n\n> 建立swap分区，可以通过增加分区进行，`swapon`，也通过空大文件挂载进行\n\n> 挂载操作也可以使用parted实现，具体操作和gdisk相差不大\n\n\n\n### 文件压缩和备份\n\n\n\n#### 常见的压缩指令\n\n> 压缩指令为透过一些运算方法去将原本的文件进行压缩，以减少文件所占用的磁盘容量。压缩前与压缩后的文件所占用的磁盘容量比值，就可以被称为是[压缩比」\n\n>常见的压缩指令有gzip，bzip2和xz三种，他们的用法都差不多，zcat，bzcat和xzcat也是用于查看压缩文件内容，其使用方法也大多相同\n\n![image-20221008221342368](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221342368.png)\n\n![image-20221008221751871](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221751871.png)\n\n\n\n#### 打包指令\n\n>使用tar指令对文件进行打包，tar指令的常用选项如下\n\n![image-20221008221926526](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221926526.png)\n\n>简而言之可以归纳为如下的指令 \n\n![image-20221008221935274](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221935274.png)\n\n>tar指令还可以对目录进行备份，加上-p参数保留原有权限，加上-v参数会显示作用中的文件名，-J参数会花更多时间。\n\n![image-20221008222243419](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222243419.png)\n\n> 解压时候，如果只需要解压单一文件，可以使用grep指令\n\n![image-20221008222408951](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222408951.png)\n\n> 如果想排除某些文件可以使用exclude参数\n\n![image-20221008222540399](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222540399.png)\n\n>只备份比某个时间新的文件可以使用--newer-time参数\n\n![image-20221008222708221](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222708221.png)\n\n\n\n#### 文件系统备份\n\n\n\n>xfs系统的备份可以使用xfs_dump指令进行，使用xfsrestore指令复原\n\n![image-20221008223119606](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223119606.png)\n\n>还可以 进行差异备份 \n\n![image-20221008223533596](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223533596.png)\n\n>可以使用xfstore -I指令进行查看备份的数据内容以及label\n\n![image-20221008223642483](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223642483.png)\n\n>复原的时候也可以分部进行，按照label进行定位复原\n\n![image-20221008223718524](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223718524.png)\n\n>使用-i参数进入互动备份界面\n\n![image-20221008223902471](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223902471.png)\n\n\n\n#### 光盘写入工具\n\n\n\n>使用mkisofs指令建立映像档，储存需要的数据。\n\n![image-20221008224235226](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008224235226.png)\n\n>这样操作会导致文件的混乱，所以我们使用-graft-point参数进行划分\n\n![image-20221008231311733](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231311733.png)\n\n**制作可开机光盘映像**\n\n\n\n>取得iso映像之后，使用isoinfo指令对iso文件进行查看\n\n![image-20221008231624761](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231624761.png)\n\n>将iso镜像挂载到/mnt目录，而后将所有数据完整到/srv/newed里面，使用rsync指令完整复制所有权限属性等数据，这样在/srv/newed里面就有了完整的映像档内容。\n\n![image-20221008231957898](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231957898.png)\n\n>按照需要对iso镜像进行修改后恢复其为iso镜像即可。\n\n![image-20221008232147990](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232147990.png)\n\n>进行光盘刻录操作，centos是wdim指令，自己去查询自己所在的distribution中的光盘刻录指令，这里以wdim为例子\n\n![image-20221008232320530](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232320530.png)\n\n>先得找到刻录机的位置，一般都是/dev/sr0这样的文件名，QEMU是虚拟机的虚拟光驱，而ASUS是真实光驱\n\n![image-20221008232451568](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232451568.png)\n\n>最后使用iso进行刻录操作\n\n![image-20221008232622911](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232622911.png)\n\n>最后测试挂载一下，检验内容\n\n![image-20221008232714078](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232714078.png)\n\n\n\n#### 其他指令\n\n>我们上面建立空的大文件使用的dd指令也可以进行备份操作，其中有一个重要操作就是将刚才的刻录后的光盘进行一个备份\n\n![image-20221008232844977](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232844977.png)\n\n>同样，这里也介绍了如何将iso镜像刻录到usb磁盘作为安装盘\n\n![image-20221008233105343](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008233105343.png)\n\n\n\n>cpio指令也是一个备份指令，可以备份任何东西，但是要和find这类查询指令配合一起使用。使用><进行数据流重定向，从而进行备份和还原。\n\n![image-20221009220206332](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220206332.png)\n\n![image-20221009220535972](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220535972.png)\n\n\n\n\n\n### Vim程序编辑器\n\n\n\n#### Vim的三种模式\n\n>vi有三种模式，- -般指令模式可变换到编辑与指令列模式，但编辑模式与指令列模式不能互换;一般模式切换编辑模式，可以通过i，a，o等指令，按下`ESC`键切换到一般模式，一般模式切换到指令列模式输入：，/，？切换，同样按下`ESC`键回到一般模式。\n\n![image-20221009222419976](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222419976.png)\n\n\n\n#### 切换指令列模式\n\n>使用`:`切换至指令列模式，可以在此基础上进行退出`q`，储存`w`，读取`r`，临时跳出等操作`！`\n\n![image-20221009224809443](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224809443.png)\n\n#### 移动指令\n\n>按下`hjkl`四个键可以上下左右移动，同样移动到行首`0`，行尾`$`,文件头`gg`，文件末尾`G`，某一列`nG`，向下移动几列`5j`，都可以使用不同的指令进行，其他具体指令参考如下。\n\n![image-20221009222725370](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222725370.png)\n\n\n\n​       \n\n#### 搜索与替代指令\n\n>**搜索，**使用`/word`和`？word`进行搜索，前者向下搜索，后者向上搜索，使用`n`和`N`指令移动到下一个匹配位置，\n\n![image-20221009223303496](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223303496.png)\n\n> **替代，**使用`：n1,n2s/word1/word2/g`将匹配到的字符进行替换，其他使用方式如下\n\n![image-20221009223454878](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223454878.png)\n\n\n\n#### 删除和复制指令\n\n>**删除**，使用`x`删除光标位置字符，使用`dd`删除本行，使用`d1G`删除本行到文件末尾，其他使用如下\n\n![image-20221009223740393](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223740393.png)\n\n\n\n>**复制，**使用yy复制本行，使用`y1G`复制本行到文件末尾，其他相似使用如下\n\n![image-20221009223916781](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223916781.png)\n\n\n\n>粘贴，使用p和P将复制的数据贴在光标所指向的上一列或下一列\n\n![image-20221009224055037](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224055037.png)\n\n\n\n>**结合，**使用`J`指令合并上下列\n>\n>使用`c`重复删除多个指令，这个实际上和`ndd`差不多\n\n![image-20221009224324625](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224324625.png)\n\n\n\n>**重复，**使用`u`指令和`ctrl+r`指令，复原和重做上一个动作，使用.重复上一个操作\n\n![image-20221009224516362](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224516362.png)\n\n\n\n#### 暂存与救援，警告\n\n> 不正常中断Vim后，再打开文件会有六个可用按钮分别对应不同的还原模式\n\n![image-20221010220335279](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220335279.png)\n\n\n\n#### 区块选择\n\n> 在一般模式下，长按v再左右上下移动，可以选中周边的区块，选中后可以使用不同的指令进行操作。\n\n![image-20221010220618713](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220618713.png)\n\n\n\n#### 多文件和多窗口\n\n>在打开文件时候，可以同时打开多个文件，这样进行操作的时候就可以使用不同的指令进行切换，例如使用`vim hosts /etc/hosts`开启两个文件后就可以使用，`n`和`N`指令进行上下切换。\n\n![image-20221010220854275](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220854275.png)\n\n\n\n>在打开一个文件的时候，可以使用`:sp file.txt`打开另一个窗口，并启动另一个文件`file.txt`\n\n![image-20221010222456818](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222456818.png)\n\n>使用`w+j`向上切换，同理向下切换\n\n![image-20221010222553234](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222553234.png)\n\n\n\n#### 环境设定与记录\n\n\n\n>vim的环境设定参数能够提供vim启动的预设环境，常用的环境设定参数如下\n\n![](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223135939.png)\n\n>当然，可以在进入vim编辑之后再设定，但是每次设定多少有点麻烦，vim的设定值放置在 ～/vimrc这个文件中，如果没有可以自己手动建立，而后将所希望的设定值写入。\n\n![image-20221010223413285](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223413285.png)\n\n\n\n#### 一张图总结Vim\n\n![image-20221012223355695](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221012223355695.png)\n\n","slug":"Linux操作与使用","published":1,"updated":"2023-02-11T11:17:46.013Z","_id":"cl8wzj7we0001harh5laug34y","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Linux操作与使用\"><a href=\"#Linux操作与使用\" class=\"headerlink\" title=\"Linux操作与使用\"></a>Linux操作与使用</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>操作系统与硬件</p>\n<p>主机规划与磁盘分区</p>\n<p>CentoOS安装</p>\n<p>登录与在线求助</p>\n<p>文件权限与目录管理</p>\n<p>磁盘划分与目录挂载</p>\n<p>系统压缩与备份</p>\n<p>程序编辑器vim</p>\n</blockquote>\n<h3 id=\"操作系统与硬件\"><a href=\"#操作系统与硬件\" class=\"headerlink\" title=\"操作系统与硬件\"></a>操作系统与硬件</h3><h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><blockquote>\n<p>操作系统主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、负责进程管理以及系统调用等等。因此，只要能够让硬件准备妥当的情况，就是一个合格的操作系统了。</p>\n</blockquote>\n<h4 id=\"Unix\"><a href=\"#Unix\" class=\"headerlink\" title=\"Unix\"></a>Unix</h4><blockquote>\n<p>Unix 的前身是由贝尔实验室(Bell lab.)的Ken Thompson利用汇编语言写成的，后来在 1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。</p>\n</blockquote>\n<h4 id=\"BSD\"><a href=\"#BSD\" class=\"headerlink\" title=\"BSD\"></a>BSD</h4><blockquote>\n<p>1977年由Bill Joy释出BSD (Berkeley Software Distribution),这些称为Unix-like的操作系统.</p>\n</blockquote>\n<h4 id=\"Minix\"><a href=\"#Minix\" class=\"headerlink\" title=\"Minix\"></a>Minix</h4><blockquote>\n<p>1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供原始码以及软件;</p>\n</blockquote>\n<h4 id=\"GNU计划\"><a href=\"#GNU计划\" class=\"headerlink\" title=\"GNU计划\"></a>GNU计划</h4><blockquote>\n<p>1984年由Richard Sallman提倡GNU计划，倡导自由软件(Free software)，强调其软件可以 「自由的取得、复制、修改与再发行」，并规范出GPL授权模式，任何 GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。</p>\n</blockquote>\n<h4 id=\"Linux-Kernel\"><a href=\"#Linux-Kernel\" class=\"headerlink\" title=\"Linux Kernel\"></a>Linux Kernel</h4><blockquote>\n<p>从Linux kernel 3.0开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本(MainLine) 为依据，并提供长期支持版本 (longterm)来加强某些功能的持续维护。</p>\n</blockquote>\n<h4 id=\"Linux-Distrbutiom\"><a href=\"#Linux-Distrbutiom\" class=\"headerlink\" title=\"Linux Distrbutiom\"></a>Linux Distrbutiom</h4><blockquote>\n<p>Linux distributions的组成含有: [Linux Kernel + Free Software + Documentations(Tools) +可完全安装的程序」所制成的一套完整的系统。</p>\n<p>常见的Linux distributions分类有[商业、社群」分类法，或「RPM、DPKG」 分类法</p>\n</blockquote>\n<h3 id=\"主机规划与硬盘分区\"><a href=\"#主机规划与硬盘分区\" class=\"headerlink\" title=\"主机规划与硬盘分区\"></a>主机规划与硬盘分区</h3><h4 id=\"主机规划\"><a href=\"#主机规划\" class=\"headerlink\" title=\"主机规划\"></a>主机规划</h4><blockquote>\n<p>主机规划一定要按照自己的需求来进行使用。</p>\n</blockquote>\n<h4 id=\"装置文件名\"><a href=\"#装置文件名\" class=\"headerlink\" title=\"装置文件名\"></a>装置文件名</h4><blockquote>\n<p>磁盘装置文件名通常分为两种，实际SATA/USB装置文件名为/dev/sd[a-p], 而虚拟机的装置可能为/dev/vd[a-p]</p>\n</blockquote>\n<h4 id=\"MBR分区\"><a href=\"#MBR分区\" class=\"headerlink\" title=\"MBR分区\"></a>MBR分区</h4><blockquote>\n<p>磁盘的第一个扇区 主要记录了两个重要的信息，一是要启动记录区(Master Boot Record, MBR):可以安装开机管理程序的地方,有446 bytes ，二是分区表(artition table):记录整颗硬盘分区的状态，有64 bytes;</p>\n<p>磁盘的MBR分区方式中，主要与延伸分区最多可以有四个，所以逻辑分区的装置文件名号码，一定是由从5号开始。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192837574.png\" alt=\"image-20221007192837574\"></p>\n<blockquote>\n<p>如果采用逻辑分区，那么磁盘的规划会变成这样</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192922041.png\" alt=\"image-20221007192922041\"></p>\n<h4 id=\"GPT分区\"><a href=\"#GPT分区\" class=\"headerlink\" title=\"GPT分区\"></a>GPT分区</h4><blockquote>\n<p>如果磁盘容量大于2TB以上时，系统会自动使用GPT分区方式来处理磁盘分区。</p>\n<p>GPT分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区.</p>\n<p>某些操作系统要使用GPT分区时，必须要搭配UEFI的新型BIOS 格式才可安装使用。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192955934.png\" alt=\"image-20221007192955934\"></p>\n<h4 id=\"开机的流程\"><a href=\"#开机的流程\" class=\"headerlink\" title=\"开机的流程\"></a>开机的流程</h4><blockquote>\n<p>开机的流程由: BIOS–&gt;MBR–&gt;boot loader–&gt;核心文件。</p>\n<p>boot loader的功能主要有:提供选单、加载核心、转交控制权给其他loader。</p>\n<p>boot loader可以安装的地点有两个，分别是MBR与boot sector,这个特色造就了多重引导功能。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193014623.png\" alt=\"image-20221007193014623\"></p>\n<h4 id=\"目录树\"><a href=\"#目录树\" class=\"headerlink\" title=\"目录树\"></a>目录树</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux 操作系统的文件使用目录树系统，与磁盘的对应需要有[挂载」的动作才行;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007161907887.png\" alt=\"image-20221007161907887\"></p>\n<blockquote>\n<p>挂载示意如下：</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162003856.png\" alt=\"image-20221007162003856\" style=\"zoom:80%;\" />\n\n\n\n\n\n<h3 id=\"CentOS安装\"><a href=\"#CentOS安装\" class=\"headerlink\" title=\"CentOS安装\"></a>CentOS安装</h3><h4 id=\"安装模式\"><a href=\"#安装模式\" class=\"headerlink\" title=\"安装模式\"></a>安装模式</h4><blockquote>\n<p>安装CentOS 7.x的模式至少有两种，分别是图形接口与文字接口;</p>\n</blockquote>\n<h4 id=\"分区设定\"><a href=\"#分区设定\" class=\"headerlink\" title=\"分区设定\"></a>分区设定</h4><blockquote>\n<p>CentOS 7会主动依据你的磁盘容量判断要用MBR或GPT分区方式，你也可以强迫使用GPT，在安装时按下<kbd>tab</kbd>,在最后加入<code>ist.gpt</code>。</p>\n<p>若安装笔记本电脑时失败，可尝试在开机时加入<code>linux nofb apm=off acpi=off</code>来关闭省电功能;</p>\n<p>安装过程进入分区后，请以「自定义的分区模式」来处理自己规划的分区方式;</p>\n<p>常见的分区为 /  /boot  BIOS boot /home</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162258318.png\" alt=\"image-20221007162258318\"></p>\n<blockquote>\n<p>规划后的分区如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162726289.png\" alt=\"image-20221007162726289\"></p>\n<h4 id=\"网络设定\"><a href=\"#网络设定\" class=\"headerlink\" title=\"网络设定\"></a>网络设定</h4><blockquote>\n<p>网卡和地址的正确配置如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007163140672.png\" alt=\"image-20221007163140672\"></p>\n<h3 id=\"登录与在线求助\"><a href=\"#登录与在线求助\" class=\"headerlink\" title=\"登录与在线求助\"></a>登录与在线求助</h3><h4 id=\"root登录\"><a href=\"#root登录\" class=\"headerlink\" title=\"root登录\"></a>root登录</h4><blockquote>\n<p>养成良好的操作习惯，尽量不要使用root 直接登入系统，应使用一般账号登入系统，有需要再转换身份可以透过「活动总览」查看系统所有使用的软件及快速启用惯用软件</p>\n<p>在终端机环境中，可依据提示字符为$或#判断为一般账号或root账号:</p>\n<p>使用<code>su -</code> 切换至root帐号</p>\n</blockquote>\n<h4 id=\"X-图形界面与命令行界面的切换\"><a href=\"#X-图形界面与命令行界面的切换\" class=\"headerlink\" title=\"X-图形界面与命令行界面的切换\"></a>X-图形界面与命令行界面的切换</h4><blockquote>\n<p>预设情况下，Linux 提供ty1-tty6的终端机界面。</p>\n<p>在X的环境下想要「强制」重新启动X的组合按键为:<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>Backspace</KBD></p>\n<p>从X环境切换至命令行界面的组合按键为：<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>F2-F6</KBD></p>\n<p>无图形界面下切换X桌面使用<code>startx</code>指令，不过不一定能够使用。</p>\n<p>启动<code>graphic.target</code>服务并设置为默认，则自动启动图形界面</p>\n</blockquote>\n<h4 id=\"语系支持\"><a href=\"#语系支持\" class=\"headerlink\" title=\"语系支持\"></a>语系支持</h4><blockquote>\n<p>如果输入指令出现乱码，需要进行语系的更改。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007165447135.png\" alt=\"image-20221007165447135\"></p>\n<h4 id=\"组合按键\"><a href=\"#组合按键\" class=\"headerlink\" title=\"组合按键\"></a>组合按键</h4><blockquote>\n<p>组合按键中, <kbd>Tab</kbd>按键 可做为命令补齐/档名补齐或/参数选项补齐</p>\n<p><kbd>Ctrl+c</kbd>可 以中断目前正在运作中的程序;</p>\n</blockquote>\n<h4 id=\"帮助系统\"><a href=\"#帮助系统\" class=\"headerlink\" title=\"帮助系统\"></a>帮助系统</h4><blockquote>\n<p>man指令是一个自带的帮助系统，可以查询指令以及系统文件的作用，例如，<code>man ls</code>以及<code>man issue</code></p>\n<p>man page说明后面的数字中， 1代表一般账号可用指令，8代表系统管理员常用指令，5代表系统配置文件格式</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193137847.png\" alt=\"image-20221007193137847\"></p>\n<blockquote>\n<p>info指令也是一个帮助系统，可以采用浏览器的方式进行点击跳转，可将一份说明文件拆成多个节点(node)显示，并具有类似超链接的功能，增加易读性;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170037728.png\" alt=\"image-20221007170037728\"></p>\n<blockquote>\n<p>此外可使用的帮助系统还有/usr/share/doc   –help  以及<code>tldr</code>，后者需要自行安装。</p>\n</blockquote>\n<h4 id=\"文本编辑器nano\"><a href=\"#文本编辑器nano\" class=\"headerlink\" title=\"文本编辑器nano\"></a>文本编辑器nano</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170237461.png\" alt=\"image-20221007170237461\"></p>\n<h4 id=\"关机与注销\"><a href=\"#关机与注销\" class=\"headerlink\" title=\"关机与注销\"></a>关机与注销</h4><blockquote>\n<p>系统需正确的关机比较不容易损坏，可使用shutdown, poweroff等指令关机。</p>\n<p>shutdown指令只有root管理员能够下达。</p>\n<p>使用exit注销帐号，返回登录界面</p>\n<p>在关机之前最好使用sync指令将内存中的数据写入储存。</p>\n</blockquote>\n<h3 id=\"文件权限与目录管理\"><a href=\"#文件权限与目录管理\" class=\"headerlink\" title=\"文件权限与目录管理\"></a>文件权限与目录管理</h3><h4 id=\"rwx权限\"><a href=\"#rwx权限\" class=\"headerlink\" title=\"rwx权限\"></a>rwx权限</h4><blockquote>\n<p>Linux的每个文件中，可分别给予使用者、群组与其他人三种身份个别的rwx权限;</p>\n<p>利用<code>ls -l</code>显示的文件属性中，第一个字段是文件的权限，共有十个位，第一个位是文件类型，接下来三个为一组共三组，为使用者、群组、其他人的权限，权限有r,w,x三种;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png\" alt=\"image-20221007170605114\"></p>\n<blockquote>\n<p>对于文件来说</p>\n<blockquote>\n<p>r：可读取此一文件的实际内容，如读取文本文件的文字内容等</p>\n</blockquote>\n<blockquote>\n<p>w：可以编辑、新增或者是修改该文件的内容(但不含删除该文件);</p>\n</blockquote>\n<blockquote>\n<p>x：该文件具有可以被系统执行的权限。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>对于目录来说</p>\n<blockquote>\n<p>r ：浏览目录内容</p>\n</blockquote>\n<blockquote>\n<p>w ：增加或删除目录内容</p>\n</blockquote>\n<blockquote>\n<p>x ：切换进入目录，使得目录成为工作目录</p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171002409.png\" alt=\"image-20221007171002409\"></p>\n<blockquote>\n<p>文件的类型有以下几种</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193427772.png\" alt=\"image-20221007193427772\"></p>\n<h4 id=\"隐藏文件\"><a href=\"#隐藏文件\" class=\"headerlink\" title=\"隐藏文件\"></a>隐藏文件</h4><blockquote>\n<p>如果档名之前多一一个<code>.</code>，则代表这个文件为隐藏文件，隐藏文件需要使用<code>ls -a</code>查看</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png\" alt=\"image-20221007170605114\"></p>\n<h4 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h4><blockquote>\n<p>若需要root的权限时，可以使用<code>su-</code>这个指令来切换身份。处理完毕则使用exit 离开su的指令环境。</p>\n<p>更改文件的群组支持可用<code>chgrp</code>,修改文件的拥有者可用<code>chown</code>,修改文件的权限可用<code>chmod</code></p>\n<p><code>chmod</code>修改权限的方法有两种，分别是符号法与数字法，数字法中r,w,x分数为4.2.1;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>符号法</p>\n</blockquote>\n<blockquote>\n<p><code>chmod +rx xx.py</code></p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193514337.png\" alt=\"image-20221007193514337\"></p>\n<blockquote>\n<blockquote>\n<p>数字法</p>\n</blockquote>\n<blockquote>\n<p><code>chmod 770 xx.py</code></p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171143570.png\" alt=\"image-20221007171143570\"></p>\n<h4 id=\"文件权限限制\"><a href=\"#文件权限限制\" class=\"headerlink\" title=\"文件权限限制\"></a>文件权限限制</h4><blockquote>\n<p>要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给;</p>\n<p>能否读取到某个文件内容，跟该文件所在的目录权限也有关系,目录至少需要有x的权限。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171118654.png\" alt=\"image-20221007171118654\"></p>\n<h4 id=\"FHS目录配置\"><a href=\"#FHS目录配置\" class=\"headerlink\" title=\"FHS目录配置\"></a>FHS目录配置</h4><blockquote>\n<p>根据FHS的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下FHS订定出来的四种目录特色为: shareable, unshareable, static, variable等四类;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171342613.png\" alt=\"image-20221007171342613\"></p>\n<blockquote>\n<p>根据目录树架构，FHS定义三层主目录为/   /usr   /var</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171523603.png\" alt=\"image-20221007171523603\"></p>\n<blockquote>\n<p>根目录/ 的结构</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171716624.png\" alt=\"image-20221007171716624\"></p>\n<blockquote>\n<p>/usr 目录的结构</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171808024.png\" alt=\"image-20221007171808024\"></p>\n<blockquote>\n<p>/var 目录的结构</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171833498.png\" alt=\"image-20221007171833498\"></p>\n<blockquote>\n<p>不同目录之间的链接情况</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171914229.png\" alt=\"image-20221007171914229\"></p>\n<h4 id=\"绝对路径与相对路径\"><a href=\"#绝对路径与相对路径\" class=\"headerlink\" title=\"绝对路径与相对路径\"></a>绝对路径与相对路径</h4><blockquote>\n<p>绝对路径文件名为从根目录开始写起，否则都是相对路径的文件名。</p>\n</blockquote>\n<h4 id=\"文件操作重要指令\"><a href=\"#文件操作重要指令\" class=\"headerlink\" title=\"文件操作重要指令\"></a>文件操作重要指令</h4><blockquote>\n<p>与目录相关的指令有: <code>cd, mkdir, rmdir, pwd,rm,mv,cp</code>等重要指令;</p>\n<p><code>rmdir</code>仅能删除空目录，要删除非空目录需使用 -p 指令;</p>\n<p><code>Is</code>可以检视文件的属性，尤其-d, -a, 1等选项特别重要!</p>\n<p>文件的复制、删除、移动可以分别使用: <code>cp, rm , mv</code>等指令来操作;</p>\n</blockquote>\n<h4 id=\"特殊目录\"><a href=\"#特殊目录\" class=\"headerlink\" title=\"特殊目录\"></a>特殊目录</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173311358.png\" alt=\"image-20221007173311358\"></p>\n<h4 id=\"PATH\"><a href=\"#PATH\" class=\"headerlink\" title=\"$PATH\"></a>$PATH</h4><blockquote>\n<p>用户能使用的指令是依据PATH 变量所规定的目录去搜寻的;</p>\n<p>加入$PATH的路径内存放的指令执行文件可以直接在shell中输入指令名来执行</p>\n<p>使用<code>PATH = “$PATH=/root”</code>将路径加入PATH</p>\n</blockquote>\n<h4 id=\"取得路径名称\"><a href=\"#取得路径名称\" class=\"headerlink\" title=\"取得路径名称\"></a>取得路径名称</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173546414.png\" alt=\"image-20221007173546414\"></p>\n<h4 id=\"查看文件内容\"><a href=\"#查看文件内容\" class=\"headerlink\" title=\"查看文件内容\"></a>查看文件内容</h4><blockquote>\n<p>检查文件的内容(读文件)可使用的指令包括有: <code>cat, tac, nl, more, lss, head, til,od</code>等</p>\n<p><code>cat-n</code>与<code>nl</code>均可显示行号，但默认的情况下，空白行会不会编号并不相同;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173655406.png\" alt=\"image-20221007173655406\"></p>\n<blockquote>\n<p>less指令使用</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173754819.png\" alt=\"image-20221007173754819\"></p>\n<blockquote>\n<p>od指令使用</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173838377.png\" alt=\"image-20221007173838377\"></p>\n<h4 id=\"修改文件参数\"><a href=\"#修改文件参数\" class=\"headerlink\" title=\"修改文件参数\"></a>修改文件参数</h4><blockquote>\n<p>touch的目的在修改文件的时间参数，但亦可用来建立空文件;</p>\n<p>一个文件记录的时间参数有三种，分别是access time(aime), status time (ctime), mdification time(mtime)</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193936078.png\" alt=\"image-20221007193936078\"></p>\n<h4 id=\"文件的预设权限\"><a href=\"#文件的预设权限\" class=\"headerlink\" title=\"文件的预设权限\"></a>文件的预设权限</h4><blockquote>\n<p>新建文件/目录时，新文件的预设权限使用umask来规范，其预设权限如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194522691.png\" alt=\"image-20221007194522691\"></p>\n<blockquote>\n<p>利用umask更改预设权限，更改后</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194649352.png\" alt=\"image-20221007194649352\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194853337.png\" alt=\"image-20221007194853337\"></p>\n<h4 id=\"文件的隐藏属性\"><a href=\"#文件的隐藏属性\" class=\"headerlink\" title=\"文件的隐藏属性\"></a>文件的隐藏属性</h4><blockquote>\n<p>除了传统的rwx权限之外，在Ex2/Ext3/Ext4/xfs文件系统中，还存在隐藏属性，以下是所有隐藏属性，最常见的隐藏属性为+i和+a</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195304005.png\" alt=\"image-20221007195304005\"></p>\n<blockquote>\n<p>使用chattr 给文件配置隐藏属性</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195612867.png\" alt=\"image-20221007195612867\"></p>\n<blockquote>\n<p>使用lsattr显示文件隐藏属性</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195741048.png\" alt=\"image-20221007195741048\"></p>\n<h4 id=\"文件的特殊权限\"><a href=\"#文件的特殊权限\" class=\"headerlink\" title=\"文件的特殊权限\"></a>文件的特殊权限</h4><blockquote>\n<p>文件具有SUID的特殊权限时,代表当用户执行此binary程序时，在执行过程中用户会暂时具有程序拥有者的权限</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195959605.png\" alt=\"image-20221007195959605\"></p>\n<blockquote>\n<p>用一张漫画来说明这个权限的使用过程</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200217090.png\" alt=\"image-20221007200217090\"></p>\n<blockquote>\n<p>目录具有SGID的特殊权限时，代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200631139.png\" alt=\"image-20221007200631139\"></p>\n<blockquote>\n<p>目录具有SBIT的特殊权限时，代表在该目录下用户建立的文件只有自己与root能够删除</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200730676.png\" alt=\"image-20221007200730676\" style=\"zoom:80%;\" />\n\n<blockquote>\n<p>给文件或目录加上SUID，SGID，SBIT权限，只需要在chmod 使用数字授权时候在标准数字之前加上代表三个权限的数字，SUID为4,  SGID为2,  SBIT为1</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201026907.png\" alt=\"image-20221007201026907\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"观察文件类型\"><a href=\"#观察文件类型\" class=\"headerlink\" title=\"观察文件类型\"></a>观察文件类型</h4><blockquote>\n<p>使用file指令观察文件类型</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201131838.png\" alt=\"image-20221007201131838\"  />\n\n\n\n<h4 id=\"指令与文件的查找\"><a href=\"#指令与文件的查找\" class=\"headerlink\" title=\"指令与文件的查找\"></a>指令与文件的查找</h4><blockquote>\n<p>搜寻指令的完整文件名可用which 或type ，这两个指令都是透过PATH变量来搜寻文件名;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201449046.png\" alt=\"image-20221007201449046\"></p>\n<blockquote>\n<p>搜寻文件的完整档名可以使用whereis 找特定目录或locate 到数据库去搜寻，而不实际搜寻文件系统;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201507176.png\" alt=\"image-20221007201507176\"></p>\n<blockquote>\n<p>用find可以加入许多选项来直接查询文件系统，以获得自己想要知道的档名，find指令复杂多变。具体可以参考</p>\n<p><code>man find</code></p>\n</blockquote>\n<h4 id=\"权限和指令之间的关系（整合）\"><a href=\"#权限和指令之间的关系（整合）\" class=\"headerlink\" title=\"权限和指令之间的关系（整合）\"></a>权限和指令之间的关系（整合）</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201747868.png\" alt=\"image-20221007201747868\"></p>\n<h3 id=\"磁盘划分和目录挂载\"><a href=\"#磁盘划分和目录挂载\" class=\"headerlink\" title=\"磁盘划分和目录挂载\"></a>磁盘划分和目录挂载</h3><h4 id=\"MBR和GPT\"><a href=\"#MBR和GPT\" class=\"headerlink\" title=\"MBR和GPT\"></a>MBR和GPT</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215146933.png\" alt=\"image-20221007215146933\"></p>\n<h4 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h4><p><strong>Ext文件系统</strong></p>\n<blockquote>\n<p>基本上Linux 的传统文件系统为ExI2，该文件系统内的信息主要有:</p>\n<p>superblock: 记录此filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等;</p>\n<p>inode:记录文件的属性，一个 文件占用-一个inode,同时记录此文件的数据所在的block 号码;</p>\n<p>block:实际记录文件的内容，若文件太大时，会占用多个block.</p>\n<p>这种数据存取的方式我们称为索引式文件系统</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215534068.png\" alt=\"image-20221007215534068\"></p>\n<blockquote>\n<p>相比起来FAT格式的读取方式是这样的</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215712073.png\" alt=\"image-20221007215712073\"></p>\n<blockquote>\n<p>Ext2文件系统主要有: boot sector, superblock, inode bitmap, block bitmap, inode table, data block等六大部分。</p>\n<p>Ext2文件系统的示意图如下.</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215921814.png\" alt=\"image-20221007215921814\"></p>\n<blockquote>\n<p>data block是用来放置文件内容数据地方，在Ext2 文件系统中所支持的block 大小有1K,2K 及4K</p>\n</blockquote>\n<blockquote>\n<p>inode 记录文件的属性/权限等数据，其他重要项目为:每个 inode大小均为固定，128/256bytes 两种基本容量。</p>\n<p>每个文件都仅会占用一个inode而已，因此文件系统能够建立的文件数量与inode 的数量有关;</p>\n<p>文件的block 在记录文件的实际数据，目录的block 则在记录该目录底下文件名与其inode 号码的对照表;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007220501891.png\" alt=\"image-20221007220501891\"></p>\n<blockquote>\n<p>superblock记录整个filesystem的信息，主要记录inode和block的总量，未使用和已使用的inode和block，大小等。</p>\n</blockquote>\n<blockquote>\n<p>使用dump2fs查询ext家族superblock的指令</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221002782.png\" alt=\"image-20221007221002782\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221040698.png\" alt=\"image-20221007221040698\"></p>\n<p><strong>xfs文件系统</strong></p>\n<blockquote>\n<p>xfs文件系统主要分为三个部分，资料区，文件系统活动登录区，和实时运作区</p>\n</blockquote>\n<h4 id=\"文件系统的操作\"><a href=\"#文件系统的操作\" class=\"headerlink\" title=\"文件系统的操作\"></a>文件系统的操作</h4><p><strong>查看文件系统磁盘使用量</strong></p>\n<blockquote>\n<p>查看文件系统的磁盘使用量使用指令df和du</p>\n</blockquote>\n<blockquote>\n<p>df列出文件系统的整体磁盘使用量</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221859758.png\" alt=\"image-20221007221859758\"></p>\n<blockquote>\n<p>du 评估文件系统各个文件的磁盘使用量</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221934486.png\" alt=\"image-20221007221934486\"  />\n\n\n\n<p><strong>创建链接</strong></p>\n<blockquote>\n<p>创建链接有两种类型，分别是实体链接与符号链接的建立</p>\n</blockquote>\n<blockquote>\n<p>实体链接的建立，是在某个目录下新增一个链接到某inode号码的关联记录，这两个档名链接到同一个inode，无论你删除哪一个文档，文件的inode和block都是存在的，从另一个都可以访问到对应的文件。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222352413.png\" alt=\"image-20221007222352413\"></p>\n<blockquote>\n<p>其链接模式如图所示</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222821931.png\" alt=\"image-20221007222821931\"></p>\n<blockquote>\n<p>符号链接的建立是在建立一个独立的文件，而这个文件会让数据读取指向link的文件，所以当被链接的原文件被删除后，符号链接也作废了，有点像windows的快捷方式。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223057831.png\" alt=\"image-20221007223057831\"></p>\n<blockquote>\n<p>其链接模式如图所示</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223128721.png\" alt=\"image-20221007223128721\"></p>\n<h4 id=\"磁盘的分区，格式化与挂载\"><a href=\"#磁盘的分区，格式化与挂载\" class=\"headerlink\" title=\"磁盘的分区，格式化与挂载\"></a>磁盘的分区，格式化与挂载</h4><p><strong>观察磁盘分区状态</strong> </p>\n<blockquote>\n<p>使用lsblk指令列出系统上所有磁盘列表</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223351460.png\" alt=\"image-20221007223351460\"></p>\n<blockquote>\n<p>使用blkid列出装置的UUID，文件系统格式，等参数</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223558635.png\" alt=\"image-20221007223558635\"></p>\n<blockquote>\n<p>使用parted列出磁盘的分区表类型与分区信息</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223638672.png\" alt=\"image-20221007223638672\"></p>\n<p><strong>进行磁盘分区</strong></p>\n<blockquote>\n<p>磁盘分区中，使用GPT格式的磁盘使用gdisk指令，使用MBR格式的磁盘使用fdisk指令</p>\n<p>先要透过lsblk和blkid找到磁盘，然后利用part查看分区表类型，最后再确定使用的指令</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223815647.png\" alt=\"image-20221007223815647\"></p>\n<blockquote>\n<p>gdisk中，p为查看分区情况，n为增加一个分区，d为删除一个分区，q为不保存退出，w为保存退出</p>\n<p>其中增加分区的n，在LastSector这里使用+500M或+2G这样的描述划分存储量</p>\n<p>分区后w保存，而后使用partprobe -s  更新分区表信息</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224251998.png\" alt=\"image-20221007224251998\"></p>\n<p><strong>磁盘格式化</strong></p>\n<blockquote>\n<p>使用mkfs.xxx指令对不同的文件系统进行格式化，例如将分区格式化为xfs格式，使用mkfs.xfs指令进行</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224433502.png\" alt=\"image-20221007224433502\"></p>\n<p><strong>文件系统检验</strong></p>\n<blockquote>\n<p>使用xfs_repair ，fsck.ext4 对错乱的文件系统进行整理修复</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224625761.png\" alt=\"image-20221007224625761\"></p>\n<p> <strong>文件系统挂载</strong></p>\n<blockquote>\n<p>使用mount进行挂载.</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224832732.png\" alt=\"image-20221007224832732\"></p>\n<blockquote>\n<p>挂载CD或者DVD时，同样，一般将之挂在到根目录下的 /mnt目录查看</p>\n</blockquote>\n<blockquote>\n<p>重新挂载使用指令<code>mount -o remouont,rw,auto</code></p>\n</blockquote>\n<blockquote>\n<p>将某个目录挂载到另一个目录使用指令<code>mount --bind /var /data/var</code></p>\n</blockquote>\n<blockquote>\n<p>使用unmount指令卸出</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225559098.png\" alt=\"image-20221007225559098\"></p>\n<blockquote>\n<p>使用xfs_admin和tune2fs修改labelname和UUID</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225756390.png\" alt=\"image-20221007225756390\"></p>\n<blockquote>\n<p>设定开机挂载 ，将记录写入etc/fstab，格式模仿上面的就是了</p>\n</blockquote>\n<blockquote>\n<p>可以使用dd制作空的大文件再挂载到某个目录下当分区用</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007230208670.png\" alt=\"image-20221007230208670\"></p>\n<blockquote>\n<p>建立swap分区，可以通过增加分区进行，<code>swapon</code>，也通过空大文件挂载进行</p>\n</blockquote>\n<blockquote>\n<p>挂载操作也可以使用parted实现，具体操作和gdisk相差不大</p>\n</blockquote>\n<h3 id=\"文件压缩和备份\"><a href=\"#文件压缩和备份\" class=\"headerlink\" title=\"文件压缩和备份\"></a>文件压缩和备份</h3><h4 id=\"常见的压缩指令\"><a href=\"#常见的压缩指令\" class=\"headerlink\" title=\"常见的压缩指令\"></a>常见的压缩指令</h4><blockquote>\n<p>压缩指令为透过一些运算方法去将原本的文件进行压缩，以减少文件所占用的磁盘容量。压缩前与压缩后的文件所占用的磁盘容量比值，就可以被称为是[压缩比」</p>\n</blockquote>\n<blockquote>\n<p>常见的压缩指令有gzip，bzip2和xz三种，他们的用法都差不多，zcat，bzcat和xzcat也是用于查看压缩文件内容，其使用方法也大多相同</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221342368.png\" alt=\"image-20221008221342368\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221751871.png\" alt=\"image-20221008221751871\"></p>\n<h4 id=\"打包指令\"><a href=\"#打包指令\" class=\"headerlink\" title=\"打包指令\"></a>打包指令</h4><blockquote>\n<p>使用tar指令对文件进行打包，tar指令的常用选项如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221926526.png\" alt=\"image-20221008221926526\"></p>\n<blockquote>\n<p>简而言之可以归纳为如下的指令 </p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221935274.png\" alt=\"image-20221008221935274\"></p>\n<blockquote>\n<p>tar指令还可以对目录进行备份，加上-p参数保留原有权限，加上-v参数会显示作用中的文件名，-J参数会花更多时间。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222243419.png\" alt=\"image-20221008222243419\"></p>\n<blockquote>\n<p>解压时候，如果只需要解压单一文件，可以使用grep指令</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222408951.png\" alt=\"image-20221008222408951\"></p>\n<blockquote>\n<p>如果想排除某些文件可以使用exclude参数</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222540399.png\" alt=\"image-20221008222540399\"></p>\n<blockquote>\n<p>只备份比某个时间新的文件可以使用–newer-time参数</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222708221.png\" alt=\"image-20221008222708221\"></p>\n<h4 id=\"文件系统备份\"><a href=\"#文件系统备份\" class=\"headerlink\" title=\"文件系统备份\"></a>文件系统备份</h4><blockquote>\n<p>xfs系统的备份可以使用xfs_dump指令进行，使用xfsrestore指令复原</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223119606.png\" alt=\"image-20221008223119606\"></p>\n<blockquote>\n<p>还可以 进行差异备份 </p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223533596.png\" alt=\"image-20221008223533596\"></p>\n<blockquote>\n<p>可以使用xfstore -I指令进行查看备份的数据内容以及label</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223642483.png\" alt=\"image-20221008223642483\"></p>\n<blockquote>\n<p>复原的时候也可以分部进行，按照label进行定位复原</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223718524.png\" alt=\"image-20221008223718524\"></p>\n<blockquote>\n<p>使用-i参数进入互动备份界面</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223902471.png\" alt=\"image-20221008223902471\"></p>\n<h4 id=\"光盘写入工具\"><a href=\"#光盘写入工具\" class=\"headerlink\" title=\"光盘写入工具\"></a>光盘写入工具</h4><blockquote>\n<p>使用mkisofs指令建立映像档，储存需要的数据。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008224235226.png\" alt=\"image-20221008224235226\"></p>\n<blockquote>\n<p>这样操作会导致文件的混乱，所以我们使用-graft-point参数进行划分</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231311733.png\" alt=\"image-20221008231311733\"></p>\n<p><strong>制作可开机光盘映像</strong></p>\n<blockquote>\n<p>取得iso映像之后，使用isoinfo指令对iso文件进行查看</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231624761.png\" alt=\"image-20221008231624761\"></p>\n<blockquote>\n<p>将iso镜像挂载到/mnt目录，而后将所有数据完整到/srv/newed里面，使用rsync指令完整复制所有权限属性等数据，这样在/srv/newed里面就有了完整的映像档内容。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231957898.png\" alt=\"image-20221008231957898\"></p>\n<blockquote>\n<p>按照需要对iso镜像进行修改后恢复其为iso镜像即可。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232147990.png\" alt=\"image-20221008232147990\"></p>\n<blockquote>\n<p>进行光盘刻录操作，centos是wdim指令，自己去查询自己所在的distribution中的光盘刻录指令，这里以wdim为例子</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232320530.png\" alt=\"image-20221008232320530\"></p>\n<blockquote>\n<p>先得找到刻录机的位置，一般都是/dev/sr0这样的文件名，QEMU是虚拟机的虚拟光驱，而ASUS是真实光驱</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232451568.png\" alt=\"image-20221008232451568\"></p>\n<blockquote>\n<p>最后使用iso进行刻录操作</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232622911.png\" alt=\"image-20221008232622911\"></p>\n<blockquote>\n<p>最后测试挂载一下，检验内容</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232714078.png\" alt=\"image-20221008232714078\"></p>\n<h4 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h4><blockquote>\n<p>我们上面建立空的大文件使用的dd指令也可以进行备份操作，其中有一个重要操作就是将刚才的刻录后的光盘进行一个备份</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232844977.png\" alt=\"image-20221008232844977\"></p>\n<blockquote>\n<p>同样，这里也介绍了如何将iso镜像刻录到usb磁盘作为安装盘</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008233105343.png\" alt=\"image-20221008233105343\"></p>\n<blockquote>\n<p>cpio指令也是一个备份指令，可以备份任何东西，但是要和find这类查询指令配合一起使用。使用&gt;&lt;进行数据流重定向，从而进行备份和还原。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220206332.png\" alt=\"image-20221009220206332\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220535972.png\" alt=\"image-20221009220535972\"></p>\n<h3 id=\"Vim程序编辑器\"><a href=\"#Vim程序编辑器\" class=\"headerlink\" title=\"Vim程序编辑器\"></a>Vim程序编辑器</h3><h4 id=\"Vim的三种模式\"><a href=\"#Vim的三种模式\" class=\"headerlink\" title=\"Vim的三种模式\"></a>Vim的三种模式</h4><blockquote>\n<p>vi有三种模式，- -般指令模式可变换到编辑与指令列模式，但编辑模式与指令列模式不能互换;一般模式切换编辑模式，可以通过i，a，o等指令，按下<code>ESC</code>键切换到一般模式，一般模式切换到指令列模式输入：，/，？切换，同样按下<code>ESC</code>键回到一般模式。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222419976.png\" alt=\"image-20221009222419976\"></p>\n<h4 id=\"切换指令列模式\"><a href=\"#切换指令列模式\" class=\"headerlink\" title=\"切换指令列模式\"></a>切换指令列模式</h4><blockquote>\n<p>使用<code>:</code>切换至指令列模式，可以在此基础上进行退出<code>q</code>，储存<code>w</code>，读取<code>r</code>，临时跳出等操作<code>！</code></p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224809443.png\" alt=\"image-20221009224809443\"></p>\n<h4 id=\"移动指令\"><a href=\"#移动指令\" class=\"headerlink\" title=\"移动指令\"></a>移动指令</h4><blockquote>\n<p>按下<code>hjkl</code>四个键可以上下左右移动，同样移动到行首<code>0</code>，行尾<code>$</code>,文件头<code>gg</code>，文件末尾<code>G</code>，某一列<code>nG</code>，向下移动几列<code>5j</code>，都可以使用不同的指令进行，其他具体指令参考如下。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222725370.png\" alt=\"image-20221009222725370\"></p>\n<p>​       </p>\n<h4 id=\"搜索与替代指令\"><a href=\"#搜索与替代指令\" class=\"headerlink\" title=\"搜索与替代指令\"></a>搜索与替代指令</h4><blockquote>\n<p><strong>搜索，</strong>使用<code>/word</code>和<code>？word</code>进行搜索，前者向下搜索，后者向上搜索，使用<code>n</code>和<code>N</code>指令移动到下一个匹配位置，</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223303496.png\" alt=\"image-20221009223303496\"></p>\n<blockquote>\n<p><strong>替代，</strong>使用<code>：n1,n2s/word1/word2/g</code>将匹配到的字符进行替换，其他使用方式如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223454878.png\" alt=\"image-20221009223454878\"></p>\n<h4 id=\"删除和复制指令\"><a href=\"#删除和复制指令\" class=\"headerlink\" title=\"删除和复制指令\"></a>删除和复制指令</h4><blockquote>\n<p><strong>删除</strong>，使用<code>x</code>删除光标位置字符，使用<code>dd</code>删除本行，使用<code>d1G</code>删除本行到文件末尾，其他使用如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223740393.png\" alt=\"image-20221009223740393\"></p>\n<blockquote>\n<p><strong>复制，</strong>使用yy复制本行，使用<code>y1G</code>复制本行到文件末尾，其他相似使用如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223916781.png\" alt=\"image-20221009223916781\"></p>\n<blockquote>\n<p>粘贴，使用p和P将复制的数据贴在光标所指向的上一列或下一列</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224055037.png\" alt=\"image-20221009224055037\"></p>\n<blockquote>\n<p><strong>结合，</strong>使用<code>J</code>指令合并上下列</p>\n<p>使用<code>c</code>重复删除多个指令，这个实际上和<code>ndd</code>差不多</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224324625.png\" alt=\"image-20221009224324625\"></p>\n<blockquote>\n<p><strong>重复，</strong>使用<code>u</code>指令和<code>ctrl+r</code>指令，复原和重做上一个动作，使用.重复上一个操作</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224516362.png\" alt=\"image-20221009224516362\"></p>\n<h4 id=\"暂存与救援，警告\"><a href=\"#暂存与救援，警告\" class=\"headerlink\" title=\"暂存与救援，警告\"></a>暂存与救援，警告</h4><blockquote>\n<p>不正常中断Vim后，再打开文件会有六个可用按钮分别对应不同的还原模式</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220335279.png\" alt=\"image-20221010220335279\"></p>\n<h4 id=\"区块选择\"><a href=\"#区块选择\" class=\"headerlink\" title=\"区块选择\"></a>区块选择</h4><blockquote>\n<p>在一般模式下，长按v再左右上下移动，可以选中周边的区块，选中后可以使用不同的指令进行操作。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220618713.png\" alt=\"image-20221010220618713\"></p>\n<h4 id=\"多文件和多窗口\"><a href=\"#多文件和多窗口\" class=\"headerlink\" title=\"多文件和多窗口\"></a>多文件和多窗口</h4><blockquote>\n<p>在打开文件时候，可以同时打开多个文件，这样进行操作的时候就可以使用不同的指令进行切换，例如使用<code>vim hosts /etc/hosts</code>开启两个文件后就可以使用，<code>n</code>和<code>N</code>指令进行上下切换。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220854275.png\" alt=\"image-20221010220854275\"></p>\n<blockquote>\n<p>在打开一个文件的时候，可以使用<code>:sp file.txt</code>打开另一个窗口，并启动另一个文件<code>file.txt</code></p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222456818.png\" alt=\"image-20221010222456818\"></p>\n<blockquote>\n<p>使用<code>w+j</code>向上切换，同理向下切换</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222553234.png\" alt=\"image-20221010222553234\"></p>\n<h4 id=\"环境设定与记录\"><a href=\"#环境设定与记录\" class=\"headerlink\" title=\"环境设定与记录\"></a>环境设定与记录</h4><blockquote>\n<p>vim的环境设定参数能够提供vim启动的预设环境，常用的环境设定参数如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223135939.png\"></p>\n<blockquote>\n<p>当然，可以在进入vim编辑之后再设定，但是每次设定多少有点麻烦，vim的设定值放置在 ～/vimrc这个文件中，如果没有可以自己手动建立，而后将所希望的设定值写入。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223413285.png\" alt=\"image-20221010223413285\"></p>\n<h4 id=\"一张图总结Vim\"><a href=\"#一张图总结Vim\" class=\"headerlink\" title=\"一张图总结Vim\"></a>一张图总结Vim</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221012223355695.png\" alt=\"image-20221012223355695\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"cover":"/img/cover.jpg","length":7962,"excerpt":"","more":"<h2 id=\"Linux操作与使用\"><a href=\"#Linux操作与使用\" class=\"headerlink\" title=\"Linux操作与使用\"></a>Linux操作与使用</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>操作系统与硬件</p>\n<p>主机规划与磁盘分区</p>\n<p>CentoOS安装</p>\n<p>登录与在线求助</p>\n<p>文件权限与目录管理</p>\n<p>磁盘划分与目录挂载</p>\n<p>系统压缩与备份</p>\n<p>程序编辑器vim</p>\n</blockquote>\n<h3 id=\"操作系统与硬件\"><a href=\"#操作系统与硬件\" class=\"headerlink\" title=\"操作系统与硬件\"></a>操作系统与硬件</h3><h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><blockquote>\n<p>操作系统主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、负责进程管理以及系统调用等等。因此，只要能够让硬件准备妥当的情况，就是一个合格的操作系统了。</p>\n</blockquote>\n<h4 id=\"Unix\"><a href=\"#Unix\" class=\"headerlink\" title=\"Unix\"></a>Unix</h4><blockquote>\n<p>Unix 的前身是由贝尔实验室(Bell lab.)的Ken Thompson利用汇编语言写成的，后来在 1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。</p>\n</blockquote>\n<h4 id=\"BSD\"><a href=\"#BSD\" class=\"headerlink\" title=\"BSD\"></a>BSD</h4><blockquote>\n<p>1977年由Bill Joy释出BSD (Berkeley Software Distribution),这些称为Unix-like的操作系统.</p>\n</blockquote>\n<h4 id=\"Minix\"><a href=\"#Minix\" class=\"headerlink\" title=\"Minix\"></a>Minix</h4><blockquote>\n<p>1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供原始码以及软件;</p>\n</blockquote>\n<h4 id=\"GNU计划\"><a href=\"#GNU计划\" class=\"headerlink\" title=\"GNU计划\"></a>GNU计划</h4><blockquote>\n<p>1984年由Richard Sallman提倡GNU计划，倡导自由软件(Free software)，强调其软件可以 「自由的取得、复制、修改与再发行」，并规范出GPL授权模式，任何 GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。</p>\n</blockquote>\n<h4 id=\"Linux-Kernel\"><a href=\"#Linux-Kernel\" class=\"headerlink\" title=\"Linux Kernel\"></a>Linux Kernel</h4><blockquote>\n<p>从Linux kernel 3.0开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本(MainLine) 为依据，并提供长期支持版本 (longterm)来加强某些功能的持续维护。</p>\n</blockquote>\n<h4 id=\"Linux-Distrbutiom\"><a href=\"#Linux-Distrbutiom\" class=\"headerlink\" title=\"Linux Distrbutiom\"></a>Linux Distrbutiom</h4><blockquote>\n<p>Linux distributions的组成含有: [Linux Kernel + Free Software + Documentations(Tools) +可完全安装的程序」所制成的一套完整的系统。</p>\n<p>常见的Linux distributions分类有[商业、社群」分类法，或「RPM、DPKG」 分类法</p>\n</blockquote>\n<h3 id=\"主机规划与硬盘分区\"><a href=\"#主机规划与硬盘分区\" class=\"headerlink\" title=\"主机规划与硬盘分区\"></a>主机规划与硬盘分区</h3><h4 id=\"主机规划\"><a href=\"#主机规划\" class=\"headerlink\" title=\"主机规划\"></a>主机规划</h4><blockquote>\n<p>主机规划一定要按照自己的需求来进行使用。</p>\n</blockquote>\n<h4 id=\"装置文件名\"><a href=\"#装置文件名\" class=\"headerlink\" title=\"装置文件名\"></a>装置文件名</h4><blockquote>\n<p>磁盘装置文件名通常分为两种，实际SATA/USB装置文件名为/dev/sd[a-p], 而虚拟机的装置可能为/dev/vd[a-p]</p>\n</blockquote>\n<h4 id=\"MBR分区\"><a href=\"#MBR分区\" class=\"headerlink\" title=\"MBR分区\"></a>MBR分区</h4><blockquote>\n<p>磁盘的第一个扇区 主要记录了两个重要的信息，一是要启动记录区(Master Boot Record, MBR):可以安装开机管理程序的地方,有446 bytes ，二是分区表(artition table):记录整颗硬盘分区的状态，有64 bytes;</p>\n<p>磁盘的MBR分区方式中，主要与延伸分区最多可以有四个，所以逻辑分区的装置文件名号码，一定是由从5号开始。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192837574.png\" alt=\"image-20221007192837574\"></p>\n<blockquote>\n<p>如果采用逻辑分区，那么磁盘的规划会变成这样</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192922041.png\" alt=\"image-20221007192922041\"></p>\n<h4 id=\"GPT分区\"><a href=\"#GPT分区\" class=\"headerlink\" title=\"GPT分区\"></a>GPT分区</h4><blockquote>\n<p>如果磁盘容量大于2TB以上时，系统会自动使用GPT分区方式来处理磁盘分区。</p>\n<p>GPT分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区.</p>\n<p>某些操作系统要使用GPT分区时，必须要搭配UEFI的新型BIOS 格式才可安装使用。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007192955934.png\" alt=\"image-20221007192955934\"></p>\n<h4 id=\"开机的流程\"><a href=\"#开机的流程\" class=\"headerlink\" title=\"开机的流程\"></a>开机的流程</h4><blockquote>\n<p>开机的流程由: BIOS–&gt;MBR–&gt;boot loader–&gt;核心文件。</p>\n<p>boot loader的功能主要有:提供选单、加载核心、转交控制权给其他loader。</p>\n<p>boot loader可以安装的地点有两个，分别是MBR与boot sector,这个特色造就了多重引导功能。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193014623.png\" alt=\"image-20221007193014623\"></p>\n<h4 id=\"目录树\"><a href=\"#目录树\" class=\"headerlink\" title=\"目录树\"></a>目录树</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux 操作系统的文件使用目录树系统，与磁盘的对应需要有[挂载」的动作才行;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007161907887.png\" alt=\"image-20221007161907887\"></p>\n<blockquote>\n<p>挂载示意如下：</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162003856.png\" alt=\"image-20221007162003856\" style=\"zoom:80%;\" />\n\n\n\n\n\n<h3 id=\"CentOS安装\"><a href=\"#CentOS安装\" class=\"headerlink\" title=\"CentOS安装\"></a>CentOS安装</h3><h4 id=\"安装模式\"><a href=\"#安装模式\" class=\"headerlink\" title=\"安装模式\"></a>安装模式</h4><blockquote>\n<p>安装CentOS 7.x的模式至少有两种，分别是图形接口与文字接口;</p>\n</blockquote>\n<h4 id=\"分区设定\"><a href=\"#分区设定\" class=\"headerlink\" title=\"分区设定\"></a>分区设定</h4><blockquote>\n<p>CentOS 7会主动依据你的磁盘容量判断要用MBR或GPT分区方式，你也可以强迫使用GPT，在安装时按下<kbd>tab</kbd>,在最后加入<code>ist.gpt</code>。</p>\n<p>若安装笔记本电脑时失败，可尝试在开机时加入<code>linux nofb apm=off acpi=off</code>来关闭省电功能;</p>\n<p>安装过程进入分区后，请以「自定义的分区模式」来处理自己规划的分区方式;</p>\n<p>常见的分区为 /  /boot  BIOS boot /home</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162258318.png\" alt=\"image-20221007162258318\"></p>\n<blockquote>\n<p>规划后的分区如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007162726289.png\" alt=\"image-20221007162726289\"></p>\n<h4 id=\"网络设定\"><a href=\"#网络设定\" class=\"headerlink\" title=\"网络设定\"></a>网络设定</h4><blockquote>\n<p>网卡和地址的正确配置如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007163140672.png\" alt=\"image-20221007163140672\"></p>\n<h3 id=\"登录与在线求助\"><a href=\"#登录与在线求助\" class=\"headerlink\" title=\"登录与在线求助\"></a>登录与在线求助</h3><h4 id=\"root登录\"><a href=\"#root登录\" class=\"headerlink\" title=\"root登录\"></a>root登录</h4><blockquote>\n<p>养成良好的操作习惯，尽量不要使用root 直接登入系统，应使用一般账号登入系统，有需要再转换身份可以透过「活动总览」查看系统所有使用的软件及快速启用惯用软件</p>\n<p>在终端机环境中，可依据提示字符为$或#判断为一般账号或root账号:</p>\n<p>使用<code>su -</code> 切换至root帐号</p>\n</blockquote>\n<h4 id=\"X-图形界面与命令行界面的切换\"><a href=\"#X-图形界面与命令行界面的切换\" class=\"headerlink\" title=\"X-图形界面与命令行界面的切换\"></a>X-图形界面与命令行界面的切换</h4><blockquote>\n<p>预设情况下，Linux 提供ty1-tty6的终端机界面。</p>\n<p>在X的环境下想要「强制」重新启动X的组合按键为:<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>Backspace</KBD></p>\n<p>从X环境切换至命令行界面的组合按键为：<KBD>ALT</KBD>+<KBD>Ctrl</KBD>+<KBD>F2-F6</KBD></p>\n<p>无图形界面下切换X桌面使用<code>startx</code>指令，不过不一定能够使用。</p>\n<p>启动<code>graphic.target</code>服务并设置为默认，则自动启动图形界面</p>\n</blockquote>\n<h4 id=\"语系支持\"><a href=\"#语系支持\" class=\"headerlink\" title=\"语系支持\"></a>语系支持</h4><blockquote>\n<p>如果输入指令出现乱码，需要进行语系的更改。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007165447135.png\" alt=\"image-20221007165447135\"></p>\n<h4 id=\"组合按键\"><a href=\"#组合按键\" class=\"headerlink\" title=\"组合按键\"></a>组合按键</h4><blockquote>\n<p>组合按键中, <kbd>Tab</kbd>按键 可做为命令补齐/档名补齐或/参数选项补齐</p>\n<p><kbd>Ctrl+c</kbd>可 以中断目前正在运作中的程序;</p>\n</blockquote>\n<h4 id=\"帮助系统\"><a href=\"#帮助系统\" class=\"headerlink\" title=\"帮助系统\"></a>帮助系统</h4><blockquote>\n<p>man指令是一个自带的帮助系统，可以查询指令以及系统文件的作用，例如，<code>man ls</code>以及<code>man issue</code></p>\n<p>man page说明后面的数字中， 1代表一般账号可用指令，8代表系统管理员常用指令，5代表系统配置文件格式</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193137847.png\" alt=\"image-20221007193137847\"></p>\n<blockquote>\n<p>info指令也是一个帮助系统，可以采用浏览器的方式进行点击跳转，可将一份说明文件拆成多个节点(node)显示，并具有类似超链接的功能，增加易读性;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170037728.png\" alt=\"image-20221007170037728\"></p>\n<blockquote>\n<p>此外可使用的帮助系统还有/usr/share/doc   –help  以及<code>tldr</code>，后者需要自行安装。</p>\n</blockquote>\n<h4 id=\"文本编辑器nano\"><a href=\"#文本编辑器nano\" class=\"headerlink\" title=\"文本编辑器nano\"></a>文本编辑器nano</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170237461.png\" alt=\"image-20221007170237461\"></p>\n<h4 id=\"关机与注销\"><a href=\"#关机与注销\" class=\"headerlink\" title=\"关机与注销\"></a>关机与注销</h4><blockquote>\n<p>系统需正确的关机比较不容易损坏，可使用shutdown, poweroff等指令关机。</p>\n<p>shutdown指令只有root管理员能够下达。</p>\n<p>使用exit注销帐号，返回登录界面</p>\n<p>在关机之前最好使用sync指令将内存中的数据写入储存。</p>\n</blockquote>\n<h3 id=\"文件权限与目录管理\"><a href=\"#文件权限与目录管理\" class=\"headerlink\" title=\"文件权限与目录管理\"></a>文件权限与目录管理</h3><h4 id=\"rwx权限\"><a href=\"#rwx权限\" class=\"headerlink\" title=\"rwx权限\"></a>rwx权限</h4><blockquote>\n<p>Linux的每个文件中，可分别给予使用者、群组与其他人三种身份个别的rwx权限;</p>\n<p>利用<code>ls -l</code>显示的文件属性中，第一个字段是文件的权限，共有十个位，第一个位是文件类型，接下来三个为一组共三组，为使用者、群组、其他人的权限，权限有r,w,x三种;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png\" alt=\"image-20221007170605114\"></p>\n<blockquote>\n<p>对于文件来说</p>\n<blockquote>\n<p>r：可读取此一文件的实际内容，如读取文本文件的文字内容等</p>\n</blockquote>\n<blockquote>\n<p>w：可以编辑、新增或者是修改该文件的内容(但不含删除该文件);</p>\n</blockquote>\n<blockquote>\n<p>x：该文件具有可以被系统执行的权限。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>对于目录来说</p>\n<blockquote>\n<p>r ：浏览目录内容</p>\n</blockquote>\n<blockquote>\n<p>w ：增加或删除目录内容</p>\n</blockquote>\n<blockquote>\n<p>x ：切换进入目录，使得目录成为工作目录</p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171002409.png\" alt=\"image-20221007171002409\"></p>\n<blockquote>\n<p>文件的类型有以下几种</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193427772.png\" alt=\"image-20221007193427772\"></p>\n<h4 id=\"隐藏文件\"><a href=\"#隐藏文件\" class=\"headerlink\" title=\"隐藏文件\"></a>隐藏文件</h4><blockquote>\n<p>如果档名之前多一一个<code>.</code>，则代表这个文件为隐藏文件，隐藏文件需要使用<code>ls -a</code>查看</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007170605114.png\" alt=\"image-20221007170605114\"></p>\n<h4 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h4><blockquote>\n<p>若需要root的权限时，可以使用<code>su-</code>这个指令来切换身份。处理完毕则使用exit 离开su的指令环境。</p>\n<p>更改文件的群组支持可用<code>chgrp</code>,修改文件的拥有者可用<code>chown</code>,修改文件的权限可用<code>chmod</code></p>\n<p><code>chmod</code>修改权限的方法有两种，分别是符号法与数字法，数字法中r,w,x分数为4.2.1;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>符号法</p>\n</blockquote>\n<blockquote>\n<p><code>chmod +rx xx.py</code></p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193514337.png\" alt=\"image-20221007193514337\"></p>\n<blockquote>\n<blockquote>\n<p>数字法</p>\n</blockquote>\n<blockquote>\n<p><code>chmod 770 xx.py</code></p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171143570.png\" alt=\"image-20221007171143570\"></p>\n<h4 id=\"文件权限限制\"><a href=\"#文件权限限制\" class=\"headerlink\" title=\"文件权限限制\"></a>文件权限限制</h4><blockquote>\n<p>要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给;</p>\n<p>能否读取到某个文件内容，跟该文件所在的目录权限也有关系,目录至少需要有x的权限。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171118654.png\" alt=\"image-20221007171118654\"></p>\n<h4 id=\"FHS目录配置\"><a href=\"#FHS目录配置\" class=\"headerlink\" title=\"FHS目录配置\"></a>FHS目录配置</h4><blockquote>\n<p>根据FHS的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下FHS订定出来的四种目录特色为: shareable, unshareable, static, variable等四类;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171342613.png\" alt=\"image-20221007171342613\"></p>\n<blockquote>\n<p>根据目录树架构，FHS定义三层主目录为/   /usr   /var</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171523603.png\" alt=\"image-20221007171523603\"></p>\n<blockquote>\n<p>根目录/ 的结构</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171716624.png\" alt=\"image-20221007171716624\"></p>\n<blockquote>\n<p>/usr 目录的结构</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171808024.png\" alt=\"image-20221007171808024\"></p>\n<blockquote>\n<p>/var 目录的结构</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171833498.png\" alt=\"image-20221007171833498\"></p>\n<blockquote>\n<p>不同目录之间的链接情况</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007171914229.png\" alt=\"image-20221007171914229\"></p>\n<h4 id=\"绝对路径与相对路径\"><a href=\"#绝对路径与相对路径\" class=\"headerlink\" title=\"绝对路径与相对路径\"></a>绝对路径与相对路径</h4><blockquote>\n<p>绝对路径文件名为从根目录开始写起，否则都是相对路径的文件名。</p>\n</blockquote>\n<h4 id=\"文件操作重要指令\"><a href=\"#文件操作重要指令\" class=\"headerlink\" title=\"文件操作重要指令\"></a>文件操作重要指令</h4><blockquote>\n<p>与目录相关的指令有: <code>cd, mkdir, rmdir, pwd,rm,mv,cp</code>等重要指令;</p>\n<p><code>rmdir</code>仅能删除空目录，要删除非空目录需使用 -p 指令;</p>\n<p><code>Is</code>可以检视文件的属性，尤其-d, -a, 1等选项特别重要!</p>\n<p>文件的复制、删除、移动可以分别使用: <code>cp, rm , mv</code>等指令来操作;</p>\n</blockquote>\n<h4 id=\"特殊目录\"><a href=\"#特殊目录\" class=\"headerlink\" title=\"特殊目录\"></a>特殊目录</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173311358.png\" alt=\"image-20221007173311358\"></p>\n<h4 id=\"PATH\"><a href=\"#PATH\" class=\"headerlink\" title=\"$PATH\"></a>$PATH</h4><blockquote>\n<p>用户能使用的指令是依据PATH 变量所规定的目录去搜寻的;</p>\n<p>加入$PATH的路径内存放的指令执行文件可以直接在shell中输入指令名来执行</p>\n<p>使用<code>PATH = “$PATH=/root”</code>将路径加入PATH</p>\n</blockquote>\n<h4 id=\"取得路径名称\"><a href=\"#取得路径名称\" class=\"headerlink\" title=\"取得路径名称\"></a>取得路径名称</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173546414.png\" alt=\"image-20221007173546414\"></p>\n<h4 id=\"查看文件内容\"><a href=\"#查看文件内容\" class=\"headerlink\" title=\"查看文件内容\"></a>查看文件内容</h4><blockquote>\n<p>检查文件的内容(读文件)可使用的指令包括有: <code>cat, tac, nl, more, lss, head, til,od</code>等</p>\n<p><code>cat-n</code>与<code>nl</code>均可显示行号，但默认的情况下，空白行会不会编号并不相同;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173655406.png\" alt=\"image-20221007173655406\"></p>\n<blockquote>\n<p>less指令使用</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173754819.png\" alt=\"image-20221007173754819\"></p>\n<blockquote>\n<p>od指令使用</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007173838377.png\" alt=\"image-20221007173838377\"></p>\n<h4 id=\"修改文件参数\"><a href=\"#修改文件参数\" class=\"headerlink\" title=\"修改文件参数\"></a>修改文件参数</h4><blockquote>\n<p>touch的目的在修改文件的时间参数，但亦可用来建立空文件;</p>\n<p>一个文件记录的时间参数有三种，分别是access time(aime), status time (ctime), mdification time(mtime)</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007193936078.png\" alt=\"image-20221007193936078\"></p>\n<h4 id=\"文件的预设权限\"><a href=\"#文件的预设权限\" class=\"headerlink\" title=\"文件的预设权限\"></a>文件的预设权限</h4><blockquote>\n<p>新建文件/目录时，新文件的预设权限使用umask来规范，其预设权限如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194522691.png\" alt=\"image-20221007194522691\"></p>\n<blockquote>\n<p>利用umask更改预设权限，更改后</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194649352.png\" alt=\"image-20221007194649352\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007194853337.png\" alt=\"image-20221007194853337\"></p>\n<h4 id=\"文件的隐藏属性\"><a href=\"#文件的隐藏属性\" class=\"headerlink\" title=\"文件的隐藏属性\"></a>文件的隐藏属性</h4><blockquote>\n<p>除了传统的rwx权限之外，在Ex2/Ext3/Ext4/xfs文件系统中，还存在隐藏属性，以下是所有隐藏属性，最常见的隐藏属性为+i和+a</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195304005.png\" alt=\"image-20221007195304005\"></p>\n<blockquote>\n<p>使用chattr 给文件配置隐藏属性</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195612867.png\" alt=\"image-20221007195612867\"></p>\n<blockquote>\n<p>使用lsattr显示文件隐藏属性</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195741048.png\" alt=\"image-20221007195741048\"></p>\n<h4 id=\"文件的特殊权限\"><a href=\"#文件的特殊权限\" class=\"headerlink\" title=\"文件的特殊权限\"></a>文件的特殊权限</h4><blockquote>\n<p>文件具有SUID的特殊权限时,代表当用户执行此binary程序时，在执行过程中用户会暂时具有程序拥有者的权限</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007195959605.png\" alt=\"image-20221007195959605\"></p>\n<blockquote>\n<p>用一张漫画来说明这个权限的使用过程</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200217090.png\" alt=\"image-20221007200217090\"></p>\n<blockquote>\n<p>目录具有SGID的特殊权限时，代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200631139.png\" alt=\"image-20221007200631139\"></p>\n<blockquote>\n<p>目录具有SBIT的特殊权限时，代表在该目录下用户建立的文件只有自己与root能够删除</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007200730676.png\" alt=\"image-20221007200730676\" style=\"zoom:80%;\" />\n\n<blockquote>\n<p>给文件或目录加上SUID，SGID，SBIT权限，只需要在chmod 使用数字授权时候在标准数字之前加上代表三个权限的数字，SUID为4,  SGID为2,  SBIT为1</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201026907.png\" alt=\"image-20221007201026907\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"观察文件类型\"><a href=\"#观察文件类型\" class=\"headerlink\" title=\"观察文件类型\"></a>观察文件类型</h4><blockquote>\n<p>使用file指令观察文件类型</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201131838.png\" alt=\"image-20221007201131838\"  />\n\n\n\n<h4 id=\"指令与文件的查找\"><a href=\"#指令与文件的查找\" class=\"headerlink\" title=\"指令与文件的查找\"></a>指令与文件的查找</h4><blockquote>\n<p>搜寻指令的完整文件名可用which 或type ，这两个指令都是透过PATH变量来搜寻文件名;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201449046.png\" alt=\"image-20221007201449046\"></p>\n<blockquote>\n<p>搜寻文件的完整档名可以使用whereis 找特定目录或locate 到数据库去搜寻，而不实际搜寻文件系统;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201507176.png\" alt=\"image-20221007201507176\"></p>\n<blockquote>\n<p>用find可以加入许多选项来直接查询文件系统，以获得自己想要知道的档名，find指令复杂多变。具体可以参考</p>\n<p><code>man find</code></p>\n</blockquote>\n<h4 id=\"权限和指令之间的关系（整合）\"><a href=\"#权限和指令之间的关系（整合）\" class=\"headerlink\" title=\"权限和指令之间的关系（整合）\"></a>权限和指令之间的关系（整合）</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007201747868.png\" alt=\"image-20221007201747868\"></p>\n<h3 id=\"磁盘划分和目录挂载\"><a href=\"#磁盘划分和目录挂载\" class=\"headerlink\" title=\"磁盘划分和目录挂载\"></a>磁盘划分和目录挂载</h3><h4 id=\"MBR和GPT\"><a href=\"#MBR和GPT\" class=\"headerlink\" title=\"MBR和GPT\"></a>MBR和GPT</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215146933.png\" alt=\"image-20221007215146933\"></p>\n<h4 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h4><p><strong>Ext文件系统</strong></p>\n<blockquote>\n<p>基本上Linux 的传统文件系统为ExI2，该文件系统内的信息主要有:</p>\n<p>superblock: 记录此filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等;</p>\n<p>inode:记录文件的属性，一个 文件占用-一个inode,同时记录此文件的数据所在的block 号码;</p>\n<p>block:实际记录文件的内容，若文件太大时，会占用多个block.</p>\n<p>这种数据存取的方式我们称为索引式文件系统</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215534068.png\" alt=\"image-20221007215534068\"></p>\n<blockquote>\n<p>相比起来FAT格式的读取方式是这样的</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215712073.png\" alt=\"image-20221007215712073\"></p>\n<blockquote>\n<p>Ext2文件系统主要有: boot sector, superblock, inode bitmap, block bitmap, inode table, data block等六大部分。</p>\n<p>Ext2文件系统的示意图如下.</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007215921814.png\" alt=\"image-20221007215921814\"></p>\n<blockquote>\n<p>data block是用来放置文件内容数据地方，在Ext2 文件系统中所支持的block 大小有1K,2K 及4K</p>\n</blockquote>\n<blockquote>\n<p>inode 记录文件的属性/权限等数据，其他重要项目为:每个 inode大小均为固定，128/256bytes 两种基本容量。</p>\n<p>每个文件都仅会占用一个inode而已，因此文件系统能够建立的文件数量与inode 的数量有关;</p>\n<p>文件的block 在记录文件的实际数据，目录的block 则在记录该目录底下文件名与其inode 号码的对照表;</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007220501891.png\" alt=\"image-20221007220501891\"></p>\n<blockquote>\n<p>superblock记录整个filesystem的信息，主要记录inode和block的总量，未使用和已使用的inode和block，大小等。</p>\n</blockquote>\n<blockquote>\n<p>使用dump2fs查询ext家族superblock的指令</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221002782.png\" alt=\"image-20221007221002782\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221040698.png\" alt=\"image-20221007221040698\"></p>\n<p><strong>xfs文件系统</strong></p>\n<blockquote>\n<p>xfs文件系统主要分为三个部分，资料区，文件系统活动登录区，和实时运作区</p>\n</blockquote>\n<h4 id=\"文件系统的操作\"><a href=\"#文件系统的操作\" class=\"headerlink\" title=\"文件系统的操作\"></a>文件系统的操作</h4><p><strong>查看文件系统磁盘使用量</strong></p>\n<blockquote>\n<p>查看文件系统的磁盘使用量使用指令df和du</p>\n</blockquote>\n<blockquote>\n<p>df列出文件系统的整体磁盘使用量</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221859758.png\" alt=\"image-20221007221859758\"></p>\n<blockquote>\n<p>du 评估文件系统各个文件的磁盘使用量</p>\n</blockquote>\n<img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007221934486.png\" alt=\"image-20221007221934486\"  />\n\n\n\n<p><strong>创建链接</strong></p>\n<blockquote>\n<p>创建链接有两种类型，分别是实体链接与符号链接的建立</p>\n</blockquote>\n<blockquote>\n<p>实体链接的建立，是在某个目录下新增一个链接到某inode号码的关联记录，这两个档名链接到同一个inode，无论你删除哪一个文档，文件的inode和block都是存在的，从另一个都可以访问到对应的文件。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222352413.png\" alt=\"image-20221007222352413\"></p>\n<blockquote>\n<p>其链接模式如图所示</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007222821931.png\" alt=\"image-20221007222821931\"></p>\n<blockquote>\n<p>符号链接的建立是在建立一个独立的文件，而这个文件会让数据读取指向link的文件，所以当被链接的原文件被删除后，符号链接也作废了，有点像windows的快捷方式。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223057831.png\" alt=\"image-20221007223057831\"></p>\n<blockquote>\n<p>其链接模式如图所示</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223128721.png\" alt=\"image-20221007223128721\"></p>\n<h4 id=\"磁盘的分区，格式化与挂载\"><a href=\"#磁盘的分区，格式化与挂载\" class=\"headerlink\" title=\"磁盘的分区，格式化与挂载\"></a>磁盘的分区，格式化与挂载</h4><p><strong>观察磁盘分区状态</strong> </p>\n<blockquote>\n<p>使用lsblk指令列出系统上所有磁盘列表</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223351460.png\" alt=\"image-20221007223351460\"></p>\n<blockquote>\n<p>使用blkid列出装置的UUID，文件系统格式，等参数</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223558635.png\" alt=\"image-20221007223558635\"></p>\n<blockquote>\n<p>使用parted列出磁盘的分区表类型与分区信息</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223638672.png\" alt=\"image-20221007223638672\"></p>\n<p><strong>进行磁盘分区</strong></p>\n<blockquote>\n<p>磁盘分区中，使用GPT格式的磁盘使用gdisk指令，使用MBR格式的磁盘使用fdisk指令</p>\n<p>先要透过lsblk和blkid找到磁盘，然后利用part查看分区表类型，最后再确定使用的指令</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007223815647.png\" alt=\"image-20221007223815647\"></p>\n<blockquote>\n<p>gdisk中，p为查看分区情况，n为增加一个分区，d为删除一个分区，q为不保存退出，w为保存退出</p>\n<p>其中增加分区的n，在LastSector这里使用+500M或+2G这样的描述划分存储量</p>\n<p>分区后w保存，而后使用partprobe -s  更新分区表信息</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224251998.png\" alt=\"image-20221007224251998\"></p>\n<p><strong>磁盘格式化</strong></p>\n<blockquote>\n<p>使用mkfs.xxx指令对不同的文件系统进行格式化，例如将分区格式化为xfs格式，使用mkfs.xfs指令进行</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224433502.png\" alt=\"image-20221007224433502\"></p>\n<p><strong>文件系统检验</strong></p>\n<blockquote>\n<p>使用xfs_repair ，fsck.ext4 对错乱的文件系统进行整理修复</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224625761.png\" alt=\"image-20221007224625761\"></p>\n<p> <strong>文件系统挂载</strong></p>\n<blockquote>\n<p>使用mount进行挂载.</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007224832732.png\" alt=\"image-20221007224832732\"></p>\n<blockquote>\n<p>挂载CD或者DVD时，同样，一般将之挂在到根目录下的 /mnt目录查看</p>\n</blockquote>\n<blockquote>\n<p>重新挂载使用指令<code>mount -o remouont,rw,auto</code></p>\n</blockquote>\n<blockquote>\n<p>将某个目录挂载到另一个目录使用指令<code>mount --bind /var /data/var</code></p>\n</blockquote>\n<blockquote>\n<p>使用unmount指令卸出</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225559098.png\" alt=\"image-20221007225559098\"></p>\n<blockquote>\n<p>使用xfs_admin和tune2fs修改labelname和UUID</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007225756390.png\" alt=\"image-20221007225756390\"></p>\n<blockquote>\n<p>设定开机挂载 ，将记录写入etc/fstab，格式模仿上面的就是了</p>\n</blockquote>\n<blockquote>\n<p>可以使用dd制作空的大文件再挂载到某个目录下当分区用</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007230208670.png\" alt=\"image-20221007230208670\"></p>\n<blockquote>\n<p>建立swap分区，可以通过增加分区进行，<code>swapon</code>，也通过空大文件挂载进行</p>\n</blockquote>\n<blockquote>\n<p>挂载操作也可以使用parted实现，具体操作和gdisk相差不大</p>\n</blockquote>\n<h3 id=\"文件压缩和备份\"><a href=\"#文件压缩和备份\" class=\"headerlink\" title=\"文件压缩和备份\"></a>文件压缩和备份</h3><h4 id=\"常见的压缩指令\"><a href=\"#常见的压缩指令\" class=\"headerlink\" title=\"常见的压缩指令\"></a>常见的压缩指令</h4><blockquote>\n<p>压缩指令为透过一些运算方法去将原本的文件进行压缩，以减少文件所占用的磁盘容量。压缩前与压缩后的文件所占用的磁盘容量比值，就可以被称为是[压缩比」</p>\n</blockquote>\n<blockquote>\n<p>常见的压缩指令有gzip，bzip2和xz三种，他们的用法都差不多，zcat，bzcat和xzcat也是用于查看压缩文件内容，其使用方法也大多相同</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221342368.png\" alt=\"image-20221008221342368\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221751871.png\" alt=\"image-20221008221751871\"></p>\n<h4 id=\"打包指令\"><a href=\"#打包指令\" class=\"headerlink\" title=\"打包指令\"></a>打包指令</h4><blockquote>\n<p>使用tar指令对文件进行打包，tar指令的常用选项如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221926526.png\" alt=\"image-20221008221926526\"></p>\n<blockquote>\n<p>简而言之可以归纳为如下的指令 </p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008221935274.png\" alt=\"image-20221008221935274\"></p>\n<blockquote>\n<p>tar指令还可以对目录进行备份，加上-p参数保留原有权限，加上-v参数会显示作用中的文件名，-J参数会花更多时间。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222243419.png\" alt=\"image-20221008222243419\"></p>\n<blockquote>\n<p>解压时候，如果只需要解压单一文件，可以使用grep指令</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222408951.png\" alt=\"image-20221008222408951\"></p>\n<blockquote>\n<p>如果想排除某些文件可以使用exclude参数</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222540399.png\" alt=\"image-20221008222540399\"></p>\n<blockquote>\n<p>只备份比某个时间新的文件可以使用–newer-time参数</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008222708221.png\" alt=\"image-20221008222708221\"></p>\n<h4 id=\"文件系统备份\"><a href=\"#文件系统备份\" class=\"headerlink\" title=\"文件系统备份\"></a>文件系统备份</h4><blockquote>\n<p>xfs系统的备份可以使用xfs_dump指令进行，使用xfsrestore指令复原</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223119606.png\" alt=\"image-20221008223119606\"></p>\n<blockquote>\n<p>还可以 进行差异备份 </p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223533596.png\" alt=\"image-20221008223533596\"></p>\n<blockquote>\n<p>可以使用xfstore -I指令进行查看备份的数据内容以及label</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223642483.png\" alt=\"image-20221008223642483\"></p>\n<blockquote>\n<p>复原的时候也可以分部进行，按照label进行定位复原</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223718524.png\" alt=\"image-20221008223718524\"></p>\n<blockquote>\n<p>使用-i参数进入互动备份界面</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008223902471.png\" alt=\"image-20221008223902471\"></p>\n<h4 id=\"光盘写入工具\"><a href=\"#光盘写入工具\" class=\"headerlink\" title=\"光盘写入工具\"></a>光盘写入工具</h4><blockquote>\n<p>使用mkisofs指令建立映像档，储存需要的数据。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008224235226.png\" alt=\"image-20221008224235226\"></p>\n<blockquote>\n<p>这样操作会导致文件的混乱，所以我们使用-graft-point参数进行划分</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231311733.png\" alt=\"image-20221008231311733\"></p>\n<p><strong>制作可开机光盘映像</strong></p>\n<blockquote>\n<p>取得iso映像之后，使用isoinfo指令对iso文件进行查看</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231624761.png\" alt=\"image-20221008231624761\"></p>\n<blockquote>\n<p>将iso镜像挂载到/mnt目录，而后将所有数据完整到/srv/newed里面，使用rsync指令完整复制所有权限属性等数据，这样在/srv/newed里面就有了完整的映像档内容。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008231957898.png\" alt=\"image-20221008231957898\"></p>\n<blockquote>\n<p>按照需要对iso镜像进行修改后恢复其为iso镜像即可。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232147990.png\" alt=\"image-20221008232147990\"></p>\n<blockquote>\n<p>进行光盘刻录操作，centos是wdim指令，自己去查询自己所在的distribution中的光盘刻录指令，这里以wdim为例子</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232320530.png\" alt=\"image-20221008232320530\"></p>\n<blockquote>\n<p>先得找到刻录机的位置，一般都是/dev/sr0这样的文件名，QEMU是虚拟机的虚拟光驱，而ASUS是真实光驱</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232451568.png\" alt=\"image-20221008232451568\"></p>\n<blockquote>\n<p>最后使用iso进行刻录操作</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232622911.png\" alt=\"image-20221008232622911\"></p>\n<blockquote>\n<p>最后测试挂载一下，检验内容</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232714078.png\" alt=\"image-20221008232714078\"></p>\n<h4 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h4><blockquote>\n<p>我们上面建立空的大文件使用的dd指令也可以进行备份操作，其中有一个重要操作就是将刚才的刻录后的光盘进行一个备份</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008232844977.png\" alt=\"image-20221008232844977\"></p>\n<blockquote>\n<p>同样，这里也介绍了如何将iso镜像刻录到usb磁盘作为安装盘</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221008233105343.png\" alt=\"image-20221008233105343\"></p>\n<blockquote>\n<p>cpio指令也是一个备份指令，可以备份任何东西，但是要和find这类查询指令配合一起使用。使用&gt;&lt;进行数据流重定向，从而进行备份和还原。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220206332.png\" alt=\"image-20221009220206332\"></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009220535972.png\" alt=\"image-20221009220535972\"></p>\n<h3 id=\"Vim程序编辑器\"><a href=\"#Vim程序编辑器\" class=\"headerlink\" title=\"Vim程序编辑器\"></a>Vim程序编辑器</h3><h4 id=\"Vim的三种模式\"><a href=\"#Vim的三种模式\" class=\"headerlink\" title=\"Vim的三种模式\"></a>Vim的三种模式</h4><blockquote>\n<p>vi有三种模式，- -般指令模式可变换到编辑与指令列模式，但编辑模式与指令列模式不能互换;一般模式切换编辑模式，可以通过i，a，o等指令，按下<code>ESC</code>键切换到一般模式，一般模式切换到指令列模式输入：，/，？切换，同样按下<code>ESC</code>键回到一般模式。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222419976.png\" alt=\"image-20221009222419976\"></p>\n<h4 id=\"切换指令列模式\"><a href=\"#切换指令列模式\" class=\"headerlink\" title=\"切换指令列模式\"></a>切换指令列模式</h4><blockquote>\n<p>使用<code>:</code>切换至指令列模式，可以在此基础上进行退出<code>q</code>，储存<code>w</code>，读取<code>r</code>，临时跳出等操作<code>！</code></p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224809443.png\" alt=\"image-20221009224809443\"></p>\n<h4 id=\"移动指令\"><a href=\"#移动指令\" class=\"headerlink\" title=\"移动指令\"></a>移动指令</h4><blockquote>\n<p>按下<code>hjkl</code>四个键可以上下左右移动，同样移动到行首<code>0</code>，行尾<code>$</code>,文件头<code>gg</code>，文件末尾<code>G</code>，某一列<code>nG</code>，向下移动几列<code>5j</code>，都可以使用不同的指令进行，其他具体指令参考如下。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009222725370.png\" alt=\"image-20221009222725370\"></p>\n<p>​       </p>\n<h4 id=\"搜索与替代指令\"><a href=\"#搜索与替代指令\" class=\"headerlink\" title=\"搜索与替代指令\"></a>搜索与替代指令</h4><blockquote>\n<p><strong>搜索，</strong>使用<code>/word</code>和<code>？word</code>进行搜索，前者向下搜索，后者向上搜索，使用<code>n</code>和<code>N</code>指令移动到下一个匹配位置，</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223303496.png\" alt=\"image-20221009223303496\"></p>\n<blockquote>\n<p><strong>替代，</strong>使用<code>：n1,n2s/word1/word2/g</code>将匹配到的字符进行替换，其他使用方式如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223454878.png\" alt=\"image-20221009223454878\"></p>\n<h4 id=\"删除和复制指令\"><a href=\"#删除和复制指令\" class=\"headerlink\" title=\"删除和复制指令\"></a>删除和复制指令</h4><blockquote>\n<p><strong>删除</strong>，使用<code>x</code>删除光标位置字符，使用<code>dd</code>删除本行，使用<code>d1G</code>删除本行到文件末尾，其他使用如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223740393.png\" alt=\"image-20221009223740393\"></p>\n<blockquote>\n<p><strong>复制，</strong>使用yy复制本行，使用<code>y1G</code>复制本行到文件末尾，其他相似使用如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009223916781.png\" alt=\"image-20221009223916781\"></p>\n<blockquote>\n<p>粘贴，使用p和P将复制的数据贴在光标所指向的上一列或下一列</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224055037.png\" alt=\"image-20221009224055037\"></p>\n<blockquote>\n<p><strong>结合，</strong>使用<code>J</code>指令合并上下列</p>\n<p>使用<code>c</code>重复删除多个指令，这个实际上和<code>ndd</code>差不多</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224324625.png\" alt=\"image-20221009224324625\"></p>\n<blockquote>\n<p><strong>重复，</strong>使用<code>u</code>指令和<code>ctrl+r</code>指令，复原和重做上一个动作，使用.重复上一个操作</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221009224516362.png\" alt=\"image-20221009224516362\"></p>\n<h4 id=\"暂存与救援，警告\"><a href=\"#暂存与救援，警告\" class=\"headerlink\" title=\"暂存与救援，警告\"></a>暂存与救援，警告</h4><blockquote>\n<p>不正常中断Vim后，再打开文件会有六个可用按钮分别对应不同的还原模式</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220335279.png\" alt=\"image-20221010220335279\"></p>\n<h4 id=\"区块选择\"><a href=\"#区块选择\" class=\"headerlink\" title=\"区块选择\"></a>区块选择</h4><blockquote>\n<p>在一般模式下，长按v再左右上下移动，可以选中周边的区块，选中后可以使用不同的指令进行操作。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220618713.png\" alt=\"image-20221010220618713\"></p>\n<h4 id=\"多文件和多窗口\"><a href=\"#多文件和多窗口\" class=\"headerlink\" title=\"多文件和多窗口\"></a>多文件和多窗口</h4><blockquote>\n<p>在打开文件时候，可以同时打开多个文件，这样进行操作的时候就可以使用不同的指令进行切换，例如使用<code>vim hosts /etc/hosts</code>开启两个文件后就可以使用，<code>n</code>和<code>N</code>指令进行上下切换。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010220854275.png\" alt=\"image-20221010220854275\"></p>\n<blockquote>\n<p>在打开一个文件的时候，可以使用<code>:sp file.txt</code>打开另一个窗口，并启动另一个文件<code>file.txt</code></p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222456818.png\" alt=\"image-20221010222456818\"></p>\n<blockquote>\n<p>使用<code>w+j</code>向上切换，同理向下切换</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010222553234.png\" alt=\"image-20221010222553234\"></p>\n<h4 id=\"环境设定与记录\"><a href=\"#环境设定与记录\" class=\"headerlink\" title=\"环境设定与记录\"></a>环境设定与记录</h4><blockquote>\n<p>vim的环境设定参数能够提供vim启动的预设环境，常用的环境设定参数如下</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223135939.png\"></p>\n<blockquote>\n<p>当然，可以在进入vim编辑之后再设定，但是每次设定多少有点麻烦，vim的设定值放置在 ～/vimrc这个文件中，如果没有可以自己手动建立，而后将所希望的设定值写入。</p>\n</blockquote>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221010223413285.png\" alt=\"image-20221010223413285\"></p>\n<h4 id=\"一张图总结Vim\"><a href=\"#一张图总结Vim\" class=\"headerlink\" title=\"一张图总结Vim\"></a>一张图总结Vim</h4><p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221012223355695.png\" alt=\"image-20221012223355695\"></p>\n"},{"title":"Linux高级操作与管理","date":"2022-10-06T11:54:49.000Z","_content":"\n## Linux高级操作与管理\n\n#### 目录\n\n>操作环境bash\n>\n>正规表示与文件格式化\n>\n>shell脚本撰写与执行\n>\n>帐号管理与ACL权限设定\n>\n>磁盘配额与文件系统\n>\n>例行与工作排程\n>\n>进程管理与SELinux\n>\n>系统服务相关管理\n>\n>登录档分析\n>\n>模块管理与Loader\n>\n>基础设定与备份策略\n>\n>软件安装与Talball\n>\n>核心编译与管理\n\n\n\n***转为Effia记录模式***\n\n\n\n### 操作环境Bash\n\n\n\n### 正规表示与文件格式化\n\n\n\n### shell脚本撰写与执行\n\n\n\n### 账户管理与ACL权限\n\n- **GID与UID**\n\n   - **Linux 操作系统上面，关于账号与群组，其实记录的是UID/GID 的数字而已**\n\n   - **使用者的账号/群组与UID/GID的对应，参考/et/passwd 及/etc/group 两个文件**\n\n     ![image-20221022194809193](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221022194809193.png)\n\n   - **/etc/passwd文件结构以冒号隔开,共分为七个字段，分别是[账号名称、密码、UID、GID、全名、家目录、shell」**\n\n   - **账号的密码已经移动到/etc/shadow 文件中，该文件权限为仅有root 可以更动。该文件分为九个字段，内容为「账号名称、加密密码、密码更动日期、密码最小可变动日期、密码最大需变动日期、密码过期前警告日数、密码失效天数、账 号失效日、保留未使用」 **\n\n   - **uId 只有0与非为0两种，非为0则为一般账号。一般账号又分为系统账号 (1-999) 及可登入者账号(大于1000) **\n\n   -  **使用者可以支持多个群组，其中在新建文件时会影响新文件群组者，为有效群组。而写入/etc/passwd 的第四个字段者，称为初始群组。 **\n-  **建立，更改与删除账号和群组**\n   -  **与使用者建立、更改参数、删除有关的指令为: useradd, usermod, userdel等，密码建立则为passwd;与群组建立、修改、删除有关的指令为: groupadd, groupmod, groupdel等; **\n      -  User add  \n         -  -d   home dir\n         -  -s    shell\n         -  -c    注释\n         -  -g   init group\n         -  -G   other groups\n      -  User mod \n         -  同上\n      -  Userdel\n         -  -l   del dir\n   -  **群组的观察与有效群组的切换分别为: groups 及newgp指令; **\n   -  **useradd 指令作用参考的文件有: /etc/defaultuseradd, etclogin.defs, /et/skel/等等 **\n   -  **观察用户详细的密码参数，可以使用 chage -l 账号」来处理; **\n   -  **用户自行修改参数的指令有: chsh, chfn等，观察指令则有: id, finger **\n      -  chsh\n         -  xxxx\n-  **ACL权限管理**\n   -  **ACL的功能需要文件系统有支持，CentOS7 预设的XFS确实有支持ACL功能**\n   -  **ACL可进行单一个人或群组的权限管理，但ACL的启动需要有文件系统的支持; **\n   -  **ACL的设定可使用setfacl ，查阅则使用getfacl ; **\n      -  [Setfacl/Getfacl](http://c.biancheng.net/view/3132.html \"行行行\")\n   -  **身份切换可使用su，亦可使用sudo，但使用sudo者，必须先以visudo 设定可使用的指令; **\n      -  visudo\n         -  我们可以修改*/etc/sudoers*文件来设置用户的sudo权限，修改/etc/sudoers一定要使用visudo命令，它可以让我们比较安全的修改此文件。\n         -  visudo有以下特性：\n            -  锁定文件避免多个同时编\n            -  检查语法的完整性\n            -  检查解析错误，以避免用户错误输入\n            -  使用root的权限直接执行visudo，打开suders文件\n         -  $visudo\n            -  注意：这里不需要输入shduers文件的路径，默认为/etc/sudoers。可以使用-f指定sudoers文件。\n         -  设置sudo权限\n            -  语法格式\n               -  用户  主机=（用户身份） 命令列表\n                  -  用户：用户可以是直接用户名（如：root），也可以是以%开头表示的用户组（如：%wheel）。\n                  -  主机：使用Host\\_Alias定义主机的别名\n                  -  命令列表：使用Cmnd\\_Alias定义命令别名，多个命令使用逗号隔开\n            -  用法\n               -  找到下面这一行：                                            \n                  -  `root  ALL=(ALL)   ALL`\n               -  允许用户在所有主机上执行所有命令的权限：           \n                  -  `test   ALL=（ALL） ALL`\n               -  设置组执行所有命令的权限                                 \n                  -  `%mygroup  ALL= (ALL)  ALL`\n               -  设置组无需密码执行所有命令的权限                       \n                  -   `%mygroup    ALL=(ALL)   NOPASSWD: ALL`\n               -  wheel\n                  -  在Linux有一个特殊的组wheel，它允许此组的用户执行所有命令的权限。\n                  -  使用visudo打开sudoers文件，找到                  \n                     -   `%wheel ALL=(ALL)   ALL`\n                  -  如果此行被注释掉，把#去掉，然后把用户添加到此组即可。                                              \n                     -  `usermod -aG wheel myuser`\n   -  **PAM模块可进行某些程序的验证程序!与PAM模块有关的配置文件位于/etc/pam.d/****\\* 及/etc/security/ 系统上面账号登入情况的查询，可使用w, who, last, lastlog等; **\n   -  **在线与使用者交谈可使用write, wall,脱机状态下可使用mail 传送邮件! **\n\n","source":"_posts/Linux高级操作与管理.md","raw":"---\ntitle: Linux高级操作与管理\ndate: 2022-10-06 19:54:49\ntags:\n- Linux \n- 操作系统\n- 命令行\ncategories:\n- Linux/Unix\n---\n\n## Linux高级操作与管理\n\n#### 目录\n\n>操作环境bash\n>\n>正规表示与文件格式化\n>\n>shell脚本撰写与执行\n>\n>帐号管理与ACL权限设定\n>\n>磁盘配额与文件系统\n>\n>例行与工作排程\n>\n>进程管理与SELinux\n>\n>系统服务相关管理\n>\n>登录档分析\n>\n>模块管理与Loader\n>\n>基础设定与备份策略\n>\n>软件安装与Talball\n>\n>核心编译与管理\n\n\n\n***转为Effia记录模式***\n\n\n\n### 操作环境Bash\n\n\n\n### 正规表示与文件格式化\n\n\n\n### shell脚本撰写与执行\n\n\n\n### 账户管理与ACL权限\n\n- **GID与UID**\n\n   - **Linux 操作系统上面，关于账号与群组，其实记录的是UID/GID 的数字而已**\n\n   - **使用者的账号/群组与UID/GID的对应，参考/et/passwd 及/etc/group 两个文件**\n\n     ![image-20221022194809193](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221022194809193.png)\n\n   - **/etc/passwd文件结构以冒号隔开,共分为七个字段，分别是[账号名称、密码、UID、GID、全名、家目录、shell」**\n\n   - **账号的密码已经移动到/etc/shadow 文件中，该文件权限为仅有root 可以更动。该文件分为九个字段，内容为「账号名称、加密密码、密码更动日期、密码最小可变动日期、密码最大需变动日期、密码过期前警告日数、密码失效天数、账 号失效日、保留未使用」 **\n\n   - **uId 只有0与非为0两种，非为0则为一般账号。一般账号又分为系统账号 (1-999) 及可登入者账号(大于1000) **\n\n   -  **使用者可以支持多个群组，其中在新建文件时会影响新文件群组者，为有效群组。而写入/etc/passwd 的第四个字段者，称为初始群组。 **\n-  **建立，更改与删除账号和群组**\n   -  **与使用者建立、更改参数、删除有关的指令为: useradd, usermod, userdel等，密码建立则为passwd;与群组建立、修改、删除有关的指令为: groupadd, groupmod, groupdel等; **\n      -  User add  \n         -  -d   home dir\n         -  -s    shell\n         -  -c    注释\n         -  -g   init group\n         -  -G   other groups\n      -  User mod \n         -  同上\n      -  Userdel\n         -  -l   del dir\n   -  **群组的观察与有效群组的切换分别为: groups 及newgp指令; **\n   -  **useradd 指令作用参考的文件有: /etc/defaultuseradd, etclogin.defs, /et/skel/等等 **\n   -  **观察用户详细的密码参数，可以使用 chage -l 账号」来处理; **\n   -  **用户自行修改参数的指令有: chsh, chfn等，观察指令则有: id, finger **\n      -  chsh\n         -  xxxx\n-  **ACL权限管理**\n   -  **ACL的功能需要文件系统有支持，CentOS7 预设的XFS确实有支持ACL功能**\n   -  **ACL可进行单一个人或群组的权限管理，但ACL的启动需要有文件系统的支持; **\n   -  **ACL的设定可使用setfacl ，查阅则使用getfacl ; **\n      -  [Setfacl/Getfacl](http://c.biancheng.net/view/3132.html \"行行行\")\n   -  **身份切换可使用su，亦可使用sudo，但使用sudo者，必须先以visudo 设定可使用的指令; **\n      -  visudo\n         -  我们可以修改*/etc/sudoers*文件来设置用户的sudo权限，修改/etc/sudoers一定要使用visudo命令，它可以让我们比较安全的修改此文件。\n         -  visudo有以下特性：\n            -  锁定文件避免多个同时编\n            -  检查语法的完整性\n            -  检查解析错误，以避免用户错误输入\n            -  使用root的权限直接执行visudo，打开suders文件\n         -  $visudo\n            -  注意：这里不需要输入shduers文件的路径，默认为/etc/sudoers。可以使用-f指定sudoers文件。\n         -  设置sudo权限\n            -  语法格式\n               -  用户  主机=（用户身份） 命令列表\n                  -  用户：用户可以是直接用户名（如：root），也可以是以%开头表示的用户组（如：%wheel）。\n                  -  主机：使用Host\\_Alias定义主机的别名\n                  -  命令列表：使用Cmnd\\_Alias定义命令别名，多个命令使用逗号隔开\n            -  用法\n               -  找到下面这一行：                                            \n                  -  `root  ALL=(ALL)   ALL`\n               -  允许用户在所有主机上执行所有命令的权限：           \n                  -  `test   ALL=（ALL） ALL`\n               -  设置组执行所有命令的权限                                 \n                  -  `%mygroup  ALL= (ALL)  ALL`\n               -  设置组无需密码执行所有命令的权限                       \n                  -   `%mygroup    ALL=(ALL)   NOPASSWD: ALL`\n               -  wheel\n                  -  在Linux有一个特殊的组wheel，它允许此组的用户执行所有命令的权限。\n                  -  使用visudo打开sudoers文件，找到                  \n                     -   `%wheel ALL=(ALL)   ALL`\n                  -  如果此行被注释掉，把#去掉，然后把用户添加到此组即可。                                              \n                     -  `usermod -aG wheel myuser`\n   -  **PAM模块可进行某些程序的验证程序!与PAM模块有关的配置文件位于/etc/pam.d/****\\* 及/etc/security/ 系统上面账号登入情况的查询，可使用w, who, last, lastlog等; **\n   -  **在线与使用者交谈可使用write, wall,脱机状态下可使用mail 传送邮件! **\n\n","slug":"Linux高级操作与管理","published":1,"updated":"2023-02-11T11:17:55.948Z","_id":"cl8x13kpj0000k1rh1w3a8dsx","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Linux高级操作与管理\"><a href=\"#Linux高级操作与管理\" class=\"headerlink\" title=\"Linux高级操作与管理\"></a>Linux高级操作与管理</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>操作环境bash</p>\n<p>正规表示与文件格式化</p>\n<p>shell脚本撰写与执行</p>\n<p>帐号管理与ACL权限设定</p>\n<p>磁盘配额与文件系统</p>\n<p>例行与工作排程</p>\n<p>进程管理与SELinux</p>\n<p>系统服务相关管理</p>\n<p>登录档分析</p>\n<p>模块管理与Loader</p>\n<p>基础设定与备份策略</p>\n<p>软件安装与Talball</p>\n<p>核心编译与管理</p>\n</blockquote>\n<p><em><strong>转为Effia记录模式</strong></em></p>\n<h3 id=\"操作环境Bash\"><a href=\"#操作环境Bash\" class=\"headerlink\" title=\"操作环境Bash\"></a>操作环境Bash</h3><h3 id=\"正规表示与文件格式化\"><a href=\"#正规表示与文件格式化\" class=\"headerlink\" title=\"正规表示与文件格式化\"></a>正规表示与文件格式化</h3><h3 id=\"shell脚本撰写与执行\"><a href=\"#shell脚本撰写与执行\" class=\"headerlink\" title=\"shell脚本撰写与执行\"></a>shell脚本撰写与执行</h3><h3 id=\"账户管理与ACL权限\"><a href=\"#账户管理与ACL权限\" class=\"headerlink\" title=\"账户管理与ACL权限\"></a>账户管理与ACL权限</h3><ul>\n<li><p><strong>GID与UID</strong></p>\n<ul>\n<li><p><strong>Linux 操作系统上面，关于账号与群组，其实记录的是UID/GID 的数字而已</strong></p>\n</li>\n<li><p><strong>使用者的账号/群组与UID/GID的对应，参考/et/passwd 及/etc/group 两个文件</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221022194809193.png\" alt=\"image-20221022194809193\"></p>\n</li>\n<li><p><strong>/etc/passwd文件结构以冒号隔开,共分为七个字段，分别是[账号名称、密码、UID、GID、全名、家目录、shell」</strong></p>\n</li>\n<li><p>**账号的密码已经移动到/etc/shadow 文件中，该文件权限为仅有root 可以更动。该文件分为九个字段，内容为「账号名称、加密密码、密码更动日期、密码最小可变动日期、密码最大需变动日期、密码过期前警告日数、密码失效天数、账 号失效日、保留未使用」 **</p>\n</li>\n<li><p>**uId 只有0与非为0两种，非为0则为一般账号。一般账号又分为系统账号 (1-999) 及可登入者账号(大于1000) **</p>\n</li>\n<li><p> **使用者可以支持多个群组，其中在新建文件时会影响新文件群组者，为有效群组。而写入/etc/passwd 的第四个字段者，称为初始群组。 **</p>\n</li>\n</ul>\n</li>\n<li><p><strong>建立，更改与删除账号和群组</strong></p>\n<ul>\n<li>**与使用者建立、更改参数、删除有关的指令为: useradd, usermod, userdel等，密码建立则为passwd;与群组建立、修改、删除有关的指令为: groupadd, groupmod, groupdel等; **<ul>\n<li>User add  <ul>\n<li> -d   home dir</li>\n<li> -s    shell</li>\n<li> -c    注释</li>\n<li> -g   init group</li>\n<li> -G   other groups</li>\n</ul>\n</li>\n<li>User mod <ul>\n<li> 同上</li>\n</ul>\n</li>\n<li>Userdel<ul>\n<li> -l   del dir</li>\n</ul>\n</li>\n</ul>\n</li>\n<li> **群组的观察与有效群组的切换分别为: groups 及newgp指令; **</li>\n<li> **useradd 指令作用参考的文件有: /etc/defaultuseradd, etclogin.defs, /et/skel/等等 **</li>\n<li> **观察用户详细的密码参数，可以使用 chage -l 账号」来处理; **</li>\n<li>**用户自行修改参数的指令有: chsh, chfn等，观察指令则有: id, finger **<ul>\n<li>chsh<ul>\n<li> xxxx</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>ACL权限管理</strong></p>\n<ul>\n<li> <strong>ACL的功能需要文件系统有支持，CentOS7 预设的XFS确实有支持ACL功能</strong></li>\n<li> **ACL可进行单一个人或群组的权限管理，但ACL的启动需要有文件系统的支持; **</li>\n<li>**ACL的设定可使用setfacl ，查阅则使用getfacl ; **<ul>\n<li> <a href=\"http://c.biancheng.net/view/3132.html\" title=\"行行行\">Setfacl/Getfacl</a></li>\n</ul>\n</li>\n<li>**身份切换可使用su，亦可使用sudo，但使用sudo者，必须先以visudo 设定可使用的指令; **<ul>\n<li>visudo<ul>\n<li> 我们可以修改*/etc/sudoers*文件来设置用户的sudo权限，修改/etc/sudoers一定要使用visudo命令，它可以让我们比较安全的修改此文件。</li>\n<li>visudo有以下特性：<ul>\n<li> 锁定文件避免多个同时编</li>\n<li> 检查语法的完整性</li>\n<li> 检查解析错误，以避免用户错误输入</li>\n<li> 使用root的权限直接执行visudo，打开suders文件</li>\n</ul>\n</li>\n<li>$visudo<ul>\n<li> 注意：这里不需要输入shduers文件的路径，默认为/etc/sudoers。可以使用-f指定sudoers文件。</li>\n</ul>\n</li>\n<li>设置sudo权限<ul>\n<li>语法格式<ul>\n<li>用户  主机=（用户身份） 命令列表<ul>\n<li> 用户：用户可以是直接用户名（如：root），也可以是以%开头表示的用户组（如：%wheel）。</li>\n<li> 主机：使用Host_Alias定义主机的别名</li>\n<li> 命令列表：使用Cmnd_Alias定义命令别名，多个命令使用逗号隔开</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用法<ul>\n<li>找到下面这一行：                                            <ul>\n<li> <code>root  ALL=(ALL)   ALL</code></li>\n</ul>\n</li>\n<li>允许用户在所有主机上执行所有命令的权限：           <ul>\n<li> <code>test   ALL=（ALL） ALL</code></li>\n</ul>\n</li>\n<li>设置组执行所有命令的权限                                 <ul>\n<li> <code>%mygroup  ALL= (ALL)  ALL</code></li>\n</ul>\n</li>\n<li>设置组无需密码执行所有命令的权限                       <ul>\n<li>  <code>%mygroup    ALL=(ALL)   NOPASSWD: ALL</code></li>\n</ul>\n</li>\n<li>wheel<ul>\n<li> 在Linux有一个特殊的组wheel，它允许此组的用户执行所有命令的权限。</li>\n<li>使用visudo打开sudoers文件，找到                  <ul>\n<li>  <code>%wheel ALL=(ALL)   ALL</code></li>\n</ul>\n</li>\n<li>如果此行被注释掉，把#去掉，然后把用户添加到此组即可。                                              <ul>\n<li> <code>usermod -aG wheel myuser</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li> *<em>PAM模块可进行某些程序的验证程序!与PAM模块有关的配置文件位于/etc/pam.d/</em>**** 及/etc/security/ 系统上面账号登入情况的查询，可使用w, who, last, lastlog等; **</li>\n<li> **在线与使用者交谈可使用write, wall,脱机状态下可使用mail 传送邮件! **</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"cover":"/img/cover.jpg","length":1942,"excerpt":"","more":"<h2 id=\"Linux高级操作与管理\"><a href=\"#Linux高级操作与管理\" class=\"headerlink\" title=\"Linux高级操作与管理\"></a>Linux高级操作与管理</h2><h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<p>操作环境bash</p>\n<p>正规表示与文件格式化</p>\n<p>shell脚本撰写与执行</p>\n<p>帐号管理与ACL权限设定</p>\n<p>磁盘配额与文件系统</p>\n<p>例行与工作排程</p>\n<p>进程管理与SELinux</p>\n<p>系统服务相关管理</p>\n<p>登录档分析</p>\n<p>模块管理与Loader</p>\n<p>基础设定与备份策略</p>\n<p>软件安装与Talball</p>\n<p>核心编译与管理</p>\n</blockquote>\n<p><em><strong>转为Effia记录模式</strong></em></p>\n<h3 id=\"操作环境Bash\"><a href=\"#操作环境Bash\" class=\"headerlink\" title=\"操作环境Bash\"></a>操作环境Bash</h3><h3 id=\"正规表示与文件格式化\"><a href=\"#正规表示与文件格式化\" class=\"headerlink\" title=\"正规表示与文件格式化\"></a>正规表示与文件格式化</h3><h3 id=\"shell脚本撰写与执行\"><a href=\"#shell脚本撰写与执行\" class=\"headerlink\" title=\"shell脚本撰写与执行\"></a>shell脚本撰写与执行</h3><h3 id=\"账户管理与ACL权限\"><a href=\"#账户管理与ACL权限\" class=\"headerlink\" title=\"账户管理与ACL权限\"></a>账户管理与ACL权限</h3><ul>\n<li><p><strong>GID与UID</strong></p>\n<ul>\n<li><p><strong>Linux 操作系统上面，关于账号与群组，其实记录的是UID/GID 的数字而已</strong></p>\n</li>\n<li><p><strong>使用者的账号/群组与UID/GID的对应，参考/et/passwd 及/etc/group 两个文件</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221022194809193.png\" alt=\"image-20221022194809193\"></p>\n</li>\n<li><p><strong>/etc/passwd文件结构以冒号隔开,共分为七个字段，分别是[账号名称、密码、UID、GID、全名、家目录、shell」</strong></p>\n</li>\n<li><p>**账号的密码已经移动到/etc/shadow 文件中，该文件权限为仅有root 可以更动。该文件分为九个字段，内容为「账号名称、加密密码、密码更动日期、密码最小可变动日期、密码最大需变动日期、密码过期前警告日数、密码失效天数、账 号失效日、保留未使用」 **</p>\n</li>\n<li><p>**uId 只有0与非为0两种，非为0则为一般账号。一般账号又分为系统账号 (1-999) 及可登入者账号(大于1000) **</p>\n</li>\n<li><p> **使用者可以支持多个群组，其中在新建文件时会影响新文件群组者，为有效群组。而写入/etc/passwd 的第四个字段者，称为初始群组。 **</p>\n</li>\n</ul>\n</li>\n<li><p><strong>建立，更改与删除账号和群组</strong></p>\n<ul>\n<li>**与使用者建立、更改参数、删除有关的指令为: useradd, usermod, userdel等，密码建立则为passwd;与群组建立、修改、删除有关的指令为: groupadd, groupmod, groupdel等; **<ul>\n<li>User add  <ul>\n<li> -d   home dir</li>\n<li> -s    shell</li>\n<li> -c    注释</li>\n<li> -g   init group</li>\n<li> -G   other groups</li>\n</ul>\n</li>\n<li>User mod <ul>\n<li> 同上</li>\n</ul>\n</li>\n<li>Userdel<ul>\n<li> -l   del dir</li>\n</ul>\n</li>\n</ul>\n</li>\n<li> **群组的观察与有效群组的切换分别为: groups 及newgp指令; **</li>\n<li> **useradd 指令作用参考的文件有: /etc/defaultuseradd, etclogin.defs, /et/skel/等等 **</li>\n<li> **观察用户详细的密码参数，可以使用 chage -l 账号」来处理; **</li>\n<li>**用户自行修改参数的指令有: chsh, chfn等，观察指令则有: id, finger **<ul>\n<li>chsh<ul>\n<li> xxxx</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>ACL权限管理</strong></p>\n<ul>\n<li> <strong>ACL的功能需要文件系统有支持，CentOS7 预设的XFS确实有支持ACL功能</strong></li>\n<li> **ACL可进行单一个人或群组的权限管理，但ACL的启动需要有文件系统的支持; **</li>\n<li>**ACL的设定可使用setfacl ，查阅则使用getfacl ; **<ul>\n<li> <a href=\"http://c.biancheng.net/view/3132.html\" title=\"行行行\">Setfacl/Getfacl</a></li>\n</ul>\n</li>\n<li>**身份切换可使用su，亦可使用sudo，但使用sudo者，必须先以visudo 设定可使用的指令; **<ul>\n<li>visudo<ul>\n<li> 我们可以修改*/etc/sudoers*文件来设置用户的sudo权限，修改/etc/sudoers一定要使用visudo命令，它可以让我们比较安全的修改此文件。</li>\n<li>visudo有以下特性：<ul>\n<li> 锁定文件避免多个同时编</li>\n<li> 检查语法的完整性</li>\n<li> 检查解析错误，以避免用户错误输入</li>\n<li> 使用root的权限直接执行visudo，打开suders文件</li>\n</ul>\n</li>\n<li>$visudo<ul>\n<li> 注意：这里不需要输入shduers文件的路径，默认为/etc/sudoers。可以使用-f指定sudoers文件。</li>\n</ul>\n</li>\n<li>设置sudo权限<ul>\n<li>语法格式<ul>\n<li>用户  主机=（用户身份） 命令列表<ul>\n<li> 用户：用户可以是直接用户名（如：root），也可以是以%开头表示的用户组（如：%wheel）。</li>\n<li> 主机：使用Host_Alias定义主机的别名</li>\n<li> 命令列表：使用Cmnd_Alias定义命令别名，多个命令使用逗号隔开</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用法<ul>\n<li>找到下面这一行：                                            <ul>\n<li> <code>root  ALL=(ALL)   ALL</code></li>\n</ul>\n</li>\n<li>允许用户在所有主机上执行所有命令的权限：           <ul>\n<li> <code>test   ALL=（ALL） ALL</code></li>\n</ul>\n</li>\n<li>设置组执行所有命令的权限                                 <ul>\n<li> <code>%mygroup  ALL= (ALL)  ALL</code></li>\n</ul>\n</li>\n<li>设置组无需密码执行所有命令的权限                       <ul>\n<li>  <code>%mygroup    ALL=(ALL)   NOPASSWD: ALL</code></li>\n</ul>\n</li>\n<li>wheel<ul>\n<li> 在Linux有一个特殊的组wheel，它允许此组的用户执行所有命令的权限。</li>\n<li>使用visudo打开sudoers文件，找到                  <ul>\n<li>  <code>%wheel ALL=(ALL)   ALL</code></li>\n</ul>\n</li>\n<li>如果此行被注释掉，把#去掉，然后把用户添加到此组即可。                                              <ul>\n<li> <code>usermod -aG wheel myuser</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li> *<em>PAM模块可进行某些程序的验证程序!与PAM模块有关的配置文件位于/etc/pam.d/</em>**** 及/etc/security/ 系统上面账号登入情况的查询，可使用w, who, last, lastlog等; **</li>\n<li> **在线与使用者交谈可使用write, wall,脱机状态下可使用mail 传送邮件! **</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Typora+picgo+oss快速搭建hexo博客图床","date":"2022-10-07T00:41:43.000Z","_content":"\n\n\n\n\n### 目录\n\n>准备工作\n>\n>* Picgo下载\n>* OSS对象储存服务开通\n>\n>图床配置\n>\n>* Typora配置\n>* Picgo配置\n>\n>测试上传情况\n\n很长一段时间没有更新博客了，听说Typora收费了，幸好我的版本从来没更新过哈哈哈哈\n\n![image-20221007103457780](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007103457780.png)\n\n------------------\n\n但是呢，这次又遇到了一个问题，之前搭建的smms图床不能用了，怎么调试都没办法，之前崩了之后只要更新下API  key 就行了，这次怎么更新都没有用，可能是smms也开始收费了。\n\n当你上传时候出现这个问题的时候，那就说明你的图床崩了。\n\n![image-20221007085519282](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007085519282.png)\n\n打开`文件`—`偏好设置`-`图片`，我们会看到这个选项。\n\n![image-20221007090126052](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007090126052.png)\n\n点击`验证个图片上传选项`，验证一下图片上传。\n\n```shell\n[PicGo INFO]: Before transform\n[PicGo INFO]: Transforming...\n[PicGo INFO]: Before upload\n[PicGo INFO]: Uploading...\n[PicGo WARN]: failed\n[PicGo ERROR]: RequestError: Error: connect ECONNREFUSED 104.21.83.45:443\n```\n\n恩。。确实是崩了。\n\n接下来我们就利用picgo+oss搭建一个图床供typora使用。\n\n\n\n### 准备工作\n\n\n\n#### picgo下载\n\n首先我们前往Github主页下载picgo最新版本  \n\n[Picgo](https://github.com/Molunerfinn/PicGo/releases)\n\n![image-20221007104038135](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104038135.png)\n\n\n\n如果不会科学上网的这里还有一个腾讯COS的下载链接\n\n[Picgo-TecentCOS](https://picgo-1251750343.cos.ap-chengdu.myqcloud.com/2.3.1-beta.6/PicGo-2.3.1-beta.6.AppImage)\n\n\n\n下载好之后执行以下指令\n\n```shell\nsudo chmod a+x PicGo-2.3.1-beta.6.AppImage   #权限\nsudo mv PicGo-2.3.1-beta.6.AppImage picgo#重命名\nsudo mv picgo /usr/bin #该目录已包含于环境变量，可直接通过picgo指令打开\n```\n\n\n\n打开之后它是这样的\n\n![image-20221007104113254](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104113254.png)\n\n你得右键打开主界面\n\n![image-20221007104134513](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104134513.png)\n\n\n\n#### OSS云对象储存服务\n\n**打开阿里云** \n\n[阿里云]: https://cn.aliyun.com\n\n\n\n**搜索对象储存oss**\n\n![image-20221007104246741](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104246741.png)\n\n\n\n**切换至概况一栏**\n\n![image-20221007104334529](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104334529.png)\n\n**点击建立bucket**\n\n![image-20221007104441930](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104441930.png)\n\n**# 上图源自CSDN，本人懒**\n\n\n\n**切换至bucket概览，记录下你的地域节点** \n\n![image-20221007104523311](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104523311.png)我这里是广州，所以是`oss-cn-guangzhou`\n\n\n\n**右上角点击你的头像选择AccessKey管理**\n\n![image-20221007104545235](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104545235.png)\n\n这个不用管他，继续使用\n\n![image-20221007101544965](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101544965.png)\n\n\n\n**创建一个新的Access key，然后记住你的ID和Secret**\n\n![image-20221007101612928](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101612928.png)\n\n\n\n到这里oss服务就配置完成了，接下来我们就可以开始在本级搭建图床了。\n\n\n\n### 图床配置\n\n\n\n#### Picgo配置\n\n**打开picgo主界面，点击`图床设置 `- `阿里云oss`**\n\n![image-20221007102114993](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102114993.png)\n\n这里的keyID和keySecret填写刚才我们建立AccessKey时候得到的两串代码，Bucket填写你建立的bucket名字，储存区域就填写刚才的地域节点，储存路径这个，随便写一个就行了。\n\n\n\n#### Typora配置\n\n同样，打开`文件`-`偏好设置`-`图片`\n\n![image-20221007102515260](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102515260.png)\n\n将上传服务由Picgo-commandline改为Picgo-app，而后Picgo路径填写我们刚刚移动Picgo\n\n到达的位置`/usr/bin/picgo`\n\n\n\n### 测试上传情况\n\n点击验证图片上传情况\n\n```shell\n{\"success\":true,\"result\":[\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/typora-icon2.png\",\"https://xxx.oss-cn-guangzhou.aliyuncs.com/image/typora-icon.png\"]}\n```\n\n成功。","source":"_posts/Typora-picgo-oss搭建hexo博客图床.md","raw":"---\ntitle: Typora+picgo+oss快速搭建hexo博客图床\ndate: 2022-10-07 08:41:43\ntags:\n- 踩过的坑\n- typora\n- picgo\n- oss\ncategories:\n- Tutorial/Error/Fix\n---\n\n\n\n\n\n### 目录\n\n>准备工作\n>\n>* Picgo下载\n>* OSS对象储存服务开通\n>\n>图床配置\n>\n>* Typora配置\n>* Picgo配置\n>\n>测试上传情况\n\n很长一段时间没有更新博客了，听说Typora收费了，幸好我的版本从来没更新过哈哈哈哈\n\n![image-20221007103457780](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007103457780.png)\n\n------------------\n\n但是呢，这次又遇到了一个问题，之前搭建的smms图床不能用了，怎么调试都没办法，之前崩了之后只要更新下API  key 就行了，这次怎么更新都没有用，可能是smms也开始收费了。\n\n当你上传时候出现这个问题的时候，那就说明你的图床崩了。\n\n![image-20221007085519282](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007085519282.png)\n\n打开`文件`—`偏好设置`-`图片`，我们会看到这个选项。\n\n![image-20221007090126052](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007090126052.png)\n\n点击`验证个图片上传选项`，验证一下图片上传。\n\n```shell\n[PicGo INFO]: Before transform\n[PicGo INFO]: Transforming...\n[PicGo INFO]: Before upload\n[PicGo INFO]: Uploading...\n[PicGo WARN]: failed\n[PicGo ERROR]: RequestError: Error: connect ECONNREFUSED 104.21.83.45:443\n```\n\n恩。。确实是崩了。\n\n接下来我们就利用picgo+oss搭建一个图床供typora使用。\n\n\n\n### 准备工作\n\n\n\n#### picgo下载\n\n首先我们前往Github主页下载picgo最新版本  \n\n[Picgo](https://github.com/Molunerfinn/PicGo/releases)\n\n![image-20221007104038135](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104038135.png)\n\n\n\n如果不会科学上网的这里还有一个腾讯COS的下载链接\n\n[Picgo-TecentCOS](https://picgo-1251750343.cos.ap-chengdu.myqcloud.com/2.3.1-beta.6/PicGo-2.3.1-beta.6.AppImage)\n\n\n\n下载好之后执行以下指令\n\n```shell\nsudo chmod a+x PicGo-2.3.1-beta.6.AppImage   #权限\nsudo mv PicGo-2.3.1-beta.6.AppImage picgo#重命名\nsudo mv picgo /usr/bin #该目录已包含于环境变量，可直接通过picgo指令打开\n```\n\n\n\n打开之后它是这样的\n\n![image-20221007104113254](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104113254.png)\n\n你得右键打开主界面\n\n![image-20221007104134513](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104134513.png)\n\n\n\n#### OSS云对象储存服务\n\n**打开阿里云** \n\n[阿里云]: https://cn.aliyun.com\n\n\n\n**搜索对象储存oss**\n\n![image-20221007104246741](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104246741.png)\n\n\n\n**切换至概况一栏**\n\n![image-20221007104334529](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104334529.png)\n\n**点击建立bucket**\n\n![image-20221007104441930](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104441930.png)\n\n**# 上图源自CSDN，本人懒**\n\n\n\n**切换至bucket概览，记录下你的地域节点** \n\n![image-20221007104523311](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104523311.png)我这里是广州，所以是`oss-cn-guangzhou`\n\n\n\n**右上角点击你的头像选择AccessKey管理**\n\n![image-20221007104545235](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104545235.png)\n\n这个不用管他，继续使用\n\n![image-20221007101544965](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101544965.png)\n\n\n\n**创建一个新的Access key，然后记住你的ID和Secret**\n\n![image-20221007101612928](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101612928.png)\n\n\n\n到这里oss服务就配置完成了，接下来我们就可以开始在本级搭建图床了。\n\n\n\n### 图床配置\n\n\n\n#### Picgo配置\n\n**打开picgo主界面，点击`图床设置 `- `阿里云oss`**\n\n![image-20221007102114993](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102114993.png)\n\n这里的keyID和keySecret填写刚才我们建立AccessKey时候得到的两串代码，Bucket填写你建立的bucket名字，储存区域就填写刚才的地域节点，储存路径这个，随便写一个就行了。\n\n\n\n#### Typora配置\n\n同样，打开`文件`-`偏好设置`-`图片`\n\n![image-20221007102515260](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102515260.png)\n\n将上传服务由Picgo-commandline改为Picgo-app，而后Picgo路径填写我们刚刚移动Picgo\n\n到达的位置`/usr/bin/picgo`\n\n\n\n### 测试上传情况\n\n点击验证图片上传情况\n\n```shell\n{\"success\":true,\"result\":[\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/typora-icon2.png\",\"https://xxx.oss-cn-guangzhou.aliyuncs.com/image/typora-icon.png\"]}\n```\n\n成功。","slug":"Typora-picgo-oss搭建hexo博客图床","published":1,"updated":"2023-02-11T11:30:24.170Z","_id":"cl8xvcrp90000cwrh3d2m0vcn","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><blockquote>\n<p>准备工作</p>\n<ul>\n<li>Picgo下载</li>\n<li>OSS对象储存服务开通</li>\n</ul>\n<p>图床配置</p>\n<ul>\n<li>Typora配置</li>\n<li>Picgo配置</li>\n</ul>\n<p>测试上传情况</p>\n</blockquote>\n<p>很长一段时间没有更新博客了，听说Typora收费了，幸好我的版本从来没更新过哈哈哈哈</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007103457780.png\" alt=\"image-20221007103457780\"></p>\n<hr>\n<p>但是呢，这次又遇到了一个问题，之前搭建的smms图床不能用了，怎么调试都没办法，之前崩了之后只要更新下API  key 就行了，这次怎么更新都没有用，可能是smms也开始收费了。</p>\n<p>当你上传时候出现这个问题的时候，那就说明你的图床崩了。</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007085519282.png\" alt=\"image-20221007085519282\"></p>\n<p>打开<code>文件</code>—<code>偏好设置</code>-<code>图片</code>，我们会看到这个选项。</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007090126052.png\" alt=\"image-20221007090126052\"></p>\n<p>点击<code>验证个图片上传选项</code>，验证一下图片上传。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PicGo INFO]: Before transform</span><br><span class=\"line\">[PicGo INFO]: Transforming...</span><br><span class=\"line\">[PicGo INFO]: Before upload</span><br><span class=\"line\">[PicGo INFO]: Uploading...</span><br><span class=\"line\">[PicGo WARN]: failed</span><br><span class=\"line\">[PicGo ERROR]: RequestError: Error: connect ECONNREFUSED 104.21.83.45:443</span><br></pre></td></tr></table></figure>\n\n<p>恩。。确实是崩了。</p>\n<p>接下来我们就利用picgo+oss搭建一个图床供typora使用。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"picgo下载\"><a href=\"#picgo下载\" class=\"headerlink\" title=\"picgo下载\"></a>picgo下载</h4><p>首先我们前往Github主页下载picgo最新版本  </p>\n<p><a href=\"https://github.com/Molunerfinn/PicGo/releases\">Picgo</a></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104038135.png\" alt=\"image-20221007104038135\"></p>\n<p>如果不会科学上网的这里还有一个腾讯COS的下载链接</p>\n<p><a href=\"https://picgo-1251750343.cos.ap-chengdu.myqcloud.com/2.3.1-beta.6/PicGo-2.3.1-beta.6.AppImage\">Picgo-TecentCOS</a></p>\n<p>下载好之后执行以下指令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod a+x PicGo-2.3.1-beta.6.AppImage   #权限</span><br><span class=\"line\">sudo mv PicGo-2.3.1-beta.6.AppImage picgo#重命名</span><br><span class=\"line\">sudo mv picgo /usr/bin #该目录已包含于环境变量，可直接通过picgo指令打开</span><br></pre></td></tr></table></figure>\n\n\n\n<p>打开之后它是这样的</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104113254.png\" alt=\"image-20221007104113254\"></p>\n<p>你得右键打开主界面</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104134513.png\" alt=\"image-20221007104134513\"></p>\n<h4 id=\"OSS云对象储存服务\"><a href=\"#OSS云对象储存服务\" class=\"headerlink\" title=\"OSS云对象储存服务\"></a>OSS云对象储存服务</h4><p><strong>打开阿里云</strong> </p>\n<p><strong>搜索对象储存oss</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104246741.png\" alt=\"image-20221007104246741\"></p>\n<p><strong>切换至概况一栏</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104334529.png\" alt=\"image-20221007104334529\"></p>\n<p><strong>点击建立bucket</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104441930.png\" alt=\"image-20221007104441930\"></p>\n<p><strong># 上图源自CSDN，本人懒</strong></p>\n<p><strong>切换至bucket概览，记录下你的地域节点</strong> </p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104523311.png\" alt=\"image-20221007104523311\">我这里是广州，所以是<code>oss-cn-guangzhou</code></p>\n<p><strong>右上角点击你的头像选择AccessKey管理</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104545235.png\" alt=\"image-20221007104545235\"></p>\n<p>这个不用管他，继续使用</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101544965.png\" alt=\"image-20221007101544965\"></p>\n<p><strong>创建一个新的Access key，然后记住你的ID和Secret</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101612928.png\" alt=\"image-20221007101612928\"></p>\n<p>到这里oss服务就配置完成了，接下来我们就可以开始在本级搭建图床了。</p>\n<h3 id=\"图床配置\"><a href=\"#图床配置\" class=\"headerlink\" title=\"图床配置\"></a>图床配置</h3><h4 id=\"Picgo配置\"><a href=\"#Picgo配置\" class=\"headerlink\" title=\"Picgo配置\"></a>Picgo配置</h4><p><strong>打开picgo主界面，点击<code>图床设置 </code>- <code>阿里云oss</code></strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102114993.png\" alt=\"image-20221007102114993\"></p>\n<p>这里的keyID和keySecret填写刚才我们建立AccessKey时候得到的两串代码，Bucket填写你建立的bucket名字，储存区域就填写刚才的地域节点，储存路径这个，随便写一个就行了。</p>\n<h4 id=\"Typora配置\"><a href=\"#Typora配置\" class=\"headerlink\" title=\"Typora配置\"></a>Typora配置</h4><p>同样，打开<code>文件</code>-<code>偏好设置</code>-<code>图片</code></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102515260.png\" alt=\"image-20221007102515260\"></p>\n<p>将上传服务由Picgo-commandline改为Picgo-app，而后Picgo路径填写我们刚刚移动Picgo</p>\n<p>到达的位置<code>/usr/bin/picgo</code></p>\n<h3 id=\"测试上传情况\"><a href=\"#测试上传情况\" class=\"headerlink\" title=\"测试上传情况\"></a>测试上传情况</h3><p>点击验证图片上传情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;success&quot;:true,&quot;result&quot;:[&quot;https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/typora-icon2.png&quot;,&quot;https://xxx.oss-cn-guangzhou.aliyuncs.com/image/typora-icon.png&quot;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>成功。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"cover":"/img/cover.jpg","length":1389,"excerpt":"","more":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><blockquote>\n<p>准备工作</p>\n<ul>\n<li>Picgo下载</li>\n<li>OSS对象储存服务开通</li>\n</ul>\n<p>图床配置</p>\n<ul>\n<li>Typora配置</li>\n<li>Picgo配置</li>\n</ul>\n<p>测试上传情况</p>\n</blockquote>\n<p>很长一段时间没有更新博客了，听说Typora收费了，幸好我的版本从来没更新过哈哈哈哈</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007103457780.png\" alt=\"image-20221007103457780\"></p>\n<hr>\n<p>但是呢，这次又遇到了一个问题，之前搭建的smms图床不能用了，怎么调试都没办法，之前崩了之后只要更新下API  key 就行了，这次怎么更新都没有用，可能是smms也开始收费了。</p>\n<p>当你上传时候出现这个问题的时候，那就说明你的图床崩了。</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007085519282.png\" alt=\"image-20221007085519282\"></p>\n<p>打开<code>文件</code>—<code>偏好设置</code>-<code>图片</code>，我们会看到这个选项。</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007090126052.png\" alt=\"image-20221007090126052\"></p>\n<p>点击<code>验证个图片上传选项</code>，验证一下图片上传。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PicGo INFO]: Before transform</span><br><span class=\"line\">[PicGo INFO]: Transforming...</span><br><span class=\"line\">[PicGo INFO]: Before upload</span><br><span class=\"line\">[PicGo INFO]: Uploading...</span><br><span class=\"line\">[PicGo WARN]: failed</span><br><span class=\"line\">[PicGo ERROR]: RequestError: Error: connect ECONNREFUSED 104.21.83.45:443</span><br></pre></td></tr></table></figure>\n\n<p>恩。。确实是崩了。</p>\n<p>接下来我们就利用picgo+oss搭建一个图床供typora使用。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"picgo下载\"><a href=\"#picgo下载\" class=\"headerlink\" title=\"picgo下载\"></a>picgo下载</h4><p>首先我们前往Github主页下载picgo最新版本  </p>\n<p><a href=\"https://github.com/Molunerfinn/PicGo/releases\">Picgo</a></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104038135.png\" alt=\"image-20221007104038135\"></p>\n<p>如果不会科学上网的这里还有一个腾讯COS的下载链接</p>\n<p><a href=\"https://picgo-1251750343.cos.ap-chengdu.myqcloud.com/2.3.1-beta.6/PicGo-2.3.1-beta.6.AppImage\">Picgo-TecentCOS</a></p>\n<p>下载好之后执行以下指令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod a+x PicGo-2.3.1-beta.6.AppImage   #权限</span><br><span class=\"line\">sudo mv PicGo-2.3.1-beta.6.AppImage picgo#重命名</span><br><span class=\"line\">sudo mv picgo /usr/bin #该目录已包含于环境变量，可直接通过picgo指令打开</span><br></pre></td></tr></table></figure>\n\n\n\n<p>打开之后它是这样的</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104113254.png\" alt=\"image-20221007104113254\"></p>\n<p>你得右键打开主界面</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104134513.png\" alt=\"image-20221007104134513\"></p>\n<h4 id=\"OSS云对象储存服务\"><a href=\"#OSS云对象储存服务\" class=\"headerlink\" title=\"OSS云对象储存服务\"></a>OSS云对象储存服务</h4><p><strong>打开阿里云</strong> </p>\n<p><strong>搜索对象储存oss</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104246741.png\" alt=\"image-20221007104246741\"></p>\n<p><strong>切换至概况一栏</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104334529.png\" alt=\"image-20221007104334529\"></p>\n<p><strong>点击建立bucket</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104441930.png\" alt=\"image-20221007104441930\"></p>\n<p><strong># 上图源自CSDN，本人懒</strong></p>\n<p><strong>切换至bucket概览，记录下你的地域节点</strong> </p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104523311.png\" alt=\"image-20221007104523311\">我这里是广州，所以是<code>oss-cn-guangzhou</code></p>\n<p><strong>右上角点击你的头像选择AccessKey管理</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007104545235.png\" alt=\"image-20221007104545235\"></p>\n<p>这个不用管他，继续使用</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101544965.png\" alt=\"image-20221007101544965\"></p>\n<p><strong>创建一个新的Access key，然后记住你的ID和Secret</strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007101612928.png\" alt=\"image-20221007101612928\"></p>\n<p>到这里oss服务就配置完成了，接下来我们就可以开始在本级搭建图床了。</p>\n<h3 id=\"图床配置\"><a href=\"#图床配置\" class=\"headerlink\" title=\"图床配置\"></a>图床配置</h3><h4 id=\"Picgo配置\"><a href=\"#Picgo配置\" class=\"headerlink\" title=\"Picgo配置\"></a>Picgo配置</h4><p><strong>打开picgo主界面，点击<code>图床设置 </code>- <code>阿里云oss</code></strong></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102114993.png\" alt=\"image-20221007102114993\"></p>\n<p>这里的keyID和keySecret填写刚才我们建立AccessKey时候得到的两串代码，Bucket填写你建立的bucket名字，储存区域就填写刚才的地域节点，储存路径这个，随便写一个就行了。</p>\n<h4 id=\"Typora配置\"><a href=\"#Typora配置\" class=\"headerlink\" title=\"Typora配置\"></a>Typora配置</h4><p>同样，打开<code>文件</code>-<code>偏好设置</code>-<code>图片</code></p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/image-20221007102515260.png\" alt=\"image-20221007102515260\"></p>\n<p>将上传服务由Picgo-commandline改为Picgo-app，而后Picgo路径填写我们刚刚移动Picgo</p>\n<p>到达的位置<code>/usr/bin/picgo</code></p>\n<h3 id=\"测试上传情况\"><a href=\"#测试上传情况\" class=\"headerlink\" title=\"测试上传情况\"></a>测试上传情况</h3><p>点击验证图片上传情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;success&quot;:true,&quot;result&quot;:[&quot;https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/typora-icon2.png&quot;,&quot;https://xxx.oss-cn-guangzhou.aliyuncs.com/image/typora-icon.png&quot;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>成功。</p>\n"},{"title":"《国境以南，太阳以西》人海茫茫，哪来那么多的不期而遇","date":"2023-02-11T11:04:31.000Z","cover":"/myimage/guojingyinan_cover.jpg","_content":"\n\n\n“追求得到之日即其终止之时，寻觅的过程亦即失却的过程。”\n\n每个男人心中都有一个岛本，可大多数男人終其一生也没有拥她入怀的机会，故事终究是故事，现实中一个人离开，如果不再联系，就真的再也不见了。\n\n人海茫茫，哪来那么多不期而遇。\n\n情窦初开之时，最怕沉溺，你蜷缩在黑暗中，瑟瑟发抖时，有一束光照在你的身上，你就会记一辈子。\n\n你追逐那束光，跑完了整个青春，回头一看，整个青春都是自己一人的兵荒马乱。\n\n当光芒散去，你呆呆的停留在原地，感觉心中空落落的，怅然若失，你不知道失去了什么，但却感觉整个世界都丢了。\n\n她再也没出现过。\n\n后来你遇见了很多人，也经历了几段感情，但总感觉缺了什么，你觉得你的生命，有一种残缺感。\n\n你遇见心仪的女孩，你们相谈甚欢，一步一步靠近，就在你们即将灵魂交融的一刻，你突然停住了脚步，就这样静静的站立，女孩开始变得着急，但碍于面子，她也不愿迈出最后一步，你们就这样静静的站在相距十步的路口，时间的车流从你们的眼前缓缓穿过，最后，女孩转身走了。\n\n“然而我无法拥抱这百分之百的幸福感。自己好比一座失去台基的塔，越是想登高远眺，心越是剧烈地摇摆不已。 ”\n\n后来，你终于跨过了那道坎，但你不断的恋爱又分手，恋爱又分手，伤害了很多人。你还记得最后一个女孩，她临走时甩下一句话，“如果不爱我，你当初为什么要告白。”\n\n你也不知道，或许你只是想证明，她的离开不是你的过错，你终究还是拥有被选择的能力，你是不服，你也是对自己的无力感到悲哀。\n\n你们相互交融，似乎相爱的唯一愿景就是将自己的身体融入对方，无论汗水，泪水还是其他混杂的液体，你不断暗示自己，我是爱她的，可心却始终静寂。\n\n“但我那时还不懂，不懂自己可能迟早要伤害一个人，给她以无法愈合的重创。在某种情况下，一个人的存在本身就要伤害另一个人。”\n\n你不断追求自己的理想，把自己打造的越来越优秀，向着梦想阔步前行，但是却不愿意参与身边人的团体，你觉得他们都太幸福了，只有你一人活在浑浑噩噩的虚无中。\n\n“然而最终我想我哪里也未能抵达，无论如何我只能是我。我怀有的缺憾无论如何都依然如故。无论周围景物怎样变化，无论人们搭话的声音怎样不同，我也只能是一个不完整的人。我身上存在着永远一成不变的致命的缺憾，那缺憾带给我强烈的饥饿和干渴。”\n\n仅一夜之间，我的心判若两人，她自人山人海中来，原来只为我一场空欢喜，你来时携风带雨，我无处可避，你走时乱了四季，我久病难医。\n\n我不知道会不会在二十七岁的街头碰见穿着红衣的你，我只知道，如果还能再重新遇见你，我一定会像害了“西伯利亚癔病”一样，朝着太阳以西追逐你，直到倒地死去。\n\n![48zz2k](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/48zz2k.jpg)\n","source":"_posts/《国境以南，太阳以西》人海茫茫，哪来那么多的不期而遇.md","raw":"---\ntitle: 《国境以南，太阳以西》人海茫茫，哪来那么多的不期而遇\ndate: 2023-02-11 19:04:31\ntags:\n- 村上春树\ncategories: \n- Read\ncover: /myimage/guojingyinan_cover.jpg\n---\n\n\n\n“追求得到之日即其终止之时，寻觅的过程亦即失却的过程。”\n\n每个男人心中都有一个岛本，可大多数男人終其一生也没有拥她入怀的机会，故事终究是故事，现实中一个人离开，如果不再联系，就真的再也不见了。\n\n人海茫茫，哪来那么多不期而遇。\n\n情窦初开之时，最怕沉溺，你蜷缩在黑暗中，瑟瑟发抖时，有一束光照在你的身上，你就会记一辈子。\n\n你追逐那束光，跑完了整个青春，回头一看，整个青春都是自己一人的兵荒马乱。\n\n当光芒散去，你呆呆的停留在原地，感觉心中空落落的，怅然若失，你不知道失去了什么，但却感觉整个世界都丢了。\n\n她再也没出现过。\n\n后来你遇见了很多人，也经历了几段感情，但总感觉缺了什么，你觉得你的生命，有一种残缺感。\n\n你遇见心仪的女孩，你们相谈甚欢，一步一步靠近，就在你们即将灵魂交融的一刻，你突然停住了脚步，就这样静静的站立，女孩开始变得着急，但碍于面子，她也不愿迈出最后一步，你们就这样静静的站在相距十步的路口，时间的车流从你们的眼前缓缓穿过，最后，女孩转身走了。\n\n“然而我无法拥抱这百分之百的幸福感。自己好比一座失去台基的塔，越是想登高远眺，心越是剧烈地摇摆不已。 ”\n\n后来，你终于跨过了那道坎，但你不断的恋爱又分手，恋爱又分手，伤害了很多人。你还记得最后一个女孩，她临走时甩下一句话，“如果不爱我，你当初为什么要告白。”\n\n你也不知道，或许你只是想证明，她的离开不是你的过错，你终究还是拥有被选择的能力，你是不服，你也是对自己的无力感到悲哀。\n\n你们相互交融，似乎相爱的唯一愿景就是将自己的身体融入对方，无论汗水，泪水还是其他混杂的液体，你不断暗示自己，我是爱她的，可心却始终静寂。\n\n“但我那时还不懂，不懂自己可能迟早要伤害一个人，给她以无法愈合的重创。在某种情况下，一个人的存在本身就要伤害另一个人。”\n\n你不断追求自己的理想，把自己打造的越来越优秀，向着梦想阔步前行，但是却不愿意参与身边人的团体，你觉得他们都太幸福了，只有你一人活在浑浑噩噩的虚无中。\n\n“然而最终我想我哪里也未能抵达，无论如何我只能是我。我怀有的缺憾无论如何都依然如故。无论周围景物怎样变化，无论人们搭话的声音怎样不同，我也只能是一个不完整的人。我身上存在着永远一成不变的致命的缺憾，那缺憾带给我强烈的饥饿和干渴。”\n\n仅一夜之间，我的心判若两人，她自人山人海中来，原来只为我一场空欢喜，你来时携风带雨，我无处可避，你走时乱了四季，我久病难医。\n\n我不知道会不会在二十七岁的街头碰见穿着红衣的你，我只知道，如果还能再重新遇见你，我一定会像害了“西伯利亚癔病”一样，朝着太阳以西追逐你，直到倒地死去。\n\n![48zz2k](https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/48zz2k.jpg)\n","slug":"《国境以南，太阳以西》人海茫茫，哪来那么多的不期而遇","published":1,"updated":"2023-02-11T12:07:08.327Z","_id":"cldzvwhn8000b2irheay0e2no","comments":1,"layout":"post","photos":[],"link":"","content":"<p>“追求得到之日即其终止之时，寻觅的过程亦即失却的过程。”</p>\n<p>每个男人心中都有一个岛本，可大多数男人終其一生也没有拥她入怀的机会，故事终究是故事，现实中一个人离开，如果不再联系，就真的再也不见了。</p>\n<p>人海茫茫，哪来那么多不期而遇。</p>\n<p>情窦初开之时，最怕沉溺，你蜷缩在黑暗中，瑟瑟发抖时，有一束光照在你的身上，你就会记一辈子。</p>\n<p>你追逐那束光，跑完了整个青春，回头一看，整个青春都是自己一人的兵荒马乱。</p>\n<p>当光芒散去，你呆呆的停留在原地，感觉心中空落落的，怅然若失，你不知道失去了什么，但却感觉整个世界都丢了。</p>\n<p>她再也没出现过。</p>\n<p>后来你遇见了很多人，也经历了几段感情，但总感觉缺了什么，你觉得你的生命，有一种残缺感。</p>\n<p>你遇见心仪的女孩，你们相谈甚欢，一步一步靠近，就在你们即将灵魂交融的一刻，你突然停住了脚步，就这样静静的站立，女孩开始变得着急，但碍于面子，她也不愿迈出最后一步，你们就这样静静的站在相距十步的路口，时间的车流从你们的眼前缓缓穿过，最后，女孩转身走了。</p>\n<p>“然而我无法拥抱这百分之百的幸福感。自己好比一座失去台基的塔，越是想登高远眺，心越是剧烈地摇摆不已。 ”</p>\n<p>后来，你终于跨过了那道坎，但你不断的恋爱又分手，恋爱又分手，伤害了很多人。你还记得最后一个女孩，她临走时甩下一句话，“如果不爱我，你当初为什么要告白。”</p>\n<p>你也不知道，或许你只是想证明，她的离开不是你的过错，你终究还是拥有被选择的能力，你是不服，你也是对自己的无力感到悲哀。</p>\n<p>你们相互交融，似乎相爱的唯一愿景就是将自己的身体融入对方，无论汗水，泪水还是其他混杂的液体，你不断暗示自己，我是爱她的，可心却始终静寂。</p>\n<p>“但我那时还不懂，不懂自己可能迟早要伤害一个人，给她以无法愈合的重创。在某种情况下，一个人的存在本身就要伤害另一个人。”</p>\n<p>你不断追求自己的理想，把自己打造的越来越优秀，向着梦想阔步前行，但是却不愿意参与身边人的团体，你觉得他们都太幸福了，只有你一人活在浑浑噩噩的虚无中。</p>\n<p>“然而最终我想我哪里也未能抵达，无论如何我只能是我。我怀有的缺憾无论如何都依然如故。无论周围景物怎样变化，无论人们搭话的声音怎样不同，我也只能是一个不完整的人。我身上存在着永远一成不变的致命的缺憾，那缺憾带给我强烈的饥饿和干渴。”</p>\n<p>仅一夜之间，我的心判若两人，她自人山人海中来，原来只为我一场空欢喜，你来时携风带雨，我无处可避，你走时乱了四季，我久病难医。</p>\n<p>我不知道会不会在二十七岁的街头碰见穿着红衣的你，我只知道，如果还能再重新遇见你，我一定会像害了“西伯利亚癔病”一样，朝着太阳以西追逐你，直到倒地死去。</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/48zz2k.jpg\" alt=\"48zz2k\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"值得推荐的博客","link_list":[{"name":"阮一峰","link":"https://www.ruanyifeng.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"阮一峰的个人博客"},{"name":"静觅","link":"https://cuiqingcai.com/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"崔庆才的个人博客"},{"name":"riusksk","link":"http://riusksk.me/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"林桠泉的个人博客"}]},{"class_name":"学习强国2.0","class_desc":"我觉得你还不够了解你的电脑","link_list":[{"name":"Nand2Tetris","link":"https://www.nand2tetris.org/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机组成与结构"},{"name":"MIT S081","link":"https://pdos.csail.mit.edu/6.828/2020/index.html","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"操作系统导论"},{"name":"CS 144","link":"https://cs144.github.io/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"计算机网络"}]}]}},"length":1059,"excerpt":"","more":"<p>“追求得到之日即其终止之时，寻觅的过程亦即失却的过程。”</p>\n<p>每个男人心中都有一个岛本，可大多数男人終其一生也没有拥她入怀的机会，故事终究是故事，现实中一个人离开，如果不再联系，就真的再也不见了。</p>\n<p>人海茫茫，哪来那么多不期而遇。</p>\n<p>情窦初开之时，最怕沉溺，你蜷缩在黑暗中，瑟瑟发抖时，有一束光照在你的身上，你就会记一辈子。</p>\n<p>你追逐那束光，跑完了整个青春，回头一看，整个青春都是自己一人的兵荒马乱。</p>\n<p>当光芒散去，你呆呆的停留在原地，感觉心中空落落的，怅然若失，你不知道失去了什么，但却感觉整个世界都丢了。</p>\n<p>她再也没出现过。</p>\n<p>后来你遇见了很多人，也经历了几段感情，但总感觉缺了什么，你觉得你的生命，有一种残缺感。</p>\n<p>你遇见心仪的女孩，你们相谈甚欢，一步一步靠近，就在你们即将灵魂交融的一刻，你突然停住了脚步，就这样静静的站立，女孩开始变得着急，但碍于面子，她也不愿迈出最后一步，你们就这样静静的站在相距十步的路口，时间的车流从你们的眼前缓缓穿过，最后，女孩转身走了。</p>\n<p>“然而我无法拥抱这百分之百的幸福感。自己好比一座失去台基的塔，越是想登高远眺，心越是剧烈地摇摆不已。 ”</p>\n<p>后来，你终于跨过了那道坎，但你不断的恋爱又分手，恋爱又分手，伤害了很多人。你还记得最后一个女孩，她临走时甩下一句话，“如果不爱我，你当初为什么要告白。”</p>\n<p>你也不知道，或许你只是想证明，她的离开不是你的过错，你终究还是拥有被选择的能力，你是不服，你也是对自己的无力感到悲哀。</p>\n<p>你们相互交融，似乎相爱的唯一愿景就是将自己的身体融入对方，无论汗水，泪水还是其他混杂的液体，你不断暗示自己，我是爱她的，可心却始终静寂。</p>\n<p>“但我那时还不懂，不懂自己可能迟早要伤害一个人，给她以无法愈合的重创。在某种情况下，一个人的存在本身就要伤害另一个人。”</p>\n<p>你不断追求自己的理想，把自己打造的越来越优秀，向着梦想阔步前行，但是却不愿意参与身边人的团体，你觉得他们都太幸福了，只有你一人活在浑浑噩噩的虚无中。</p>\n<p>“然而最终我想我哪里也未能抵达，无论如何我只能是我。我怀有的缺憾无论如何都依然如故。无论周围景物怎样变化，无论人们搭话的声音怎样不同，我也只能是一个不完整的人。我身上存在着永远一成不变的致命的缺憾，那缺憾带给我强烈的饥饿和干渴。”</p>\n<p>仅一夜之间，我的心判若两人，她自人山人海中来，原来只为我一场空欢喜，你来时携风带雨，我无处可避，你走时乱了四季，我久病难医。</p>\n<p>我不知道会不会在二十七岁的街头碰见穿着红衣的你，我只知道，如果还能再重新遇见你，我一定会像害了“西伯利亚癔病”一样，朝着太阳以西追逐你，直到倒地死去。</p>\n<p><img src=\"https://blogqc.oss-cn-guangzhou.aliyuncs.com/image/48zz2k.jpg\" alt=\"48zz2k\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl40x3tit00011erhfttxevjc","category_id":"cl8wzj7wm000fharh2rb8dogk","_id":"cl8wzj7wn000kharh4e9badtl"},{"post_id":"cl411w4jh00002nrh29dc6w18","category_id":"cl8wzj7wm000fharh2rb8dogk","_id":"cl8wzj7wo000lharh8k2ke9up"},{"post_id":"ckpwpwd070000qfrhdxjx5jnr","category_id":"cldzvwhml00002irhc3dh41yl","_id":"cldzvwhmu00032irhgbvld00w"},{"post_id":"cl3qvw1650000fkrh4pfv31i9","category_id":"cl8wzj7wm000fharh2rb8dogk","_id":"cldzvwhmu00042irh33n9fycq"},{"post_id":"ckng69t8o0000e4rh5kz3b781","category_id":"cldzvwhml00002irhc3dh41yl","_id":"cldzvwhmv00062irh8wllgxex"},{"post_id":"cl8x13kpj0000k1rh1w3a8dsx","category_id":"cldzvwhmu00022irh01iu43h9","_id":"cldzvwhmw00082irh2zf31jre"},{"post_id":"ckncr32gd0000l8rhhz07cxn5","category_id":"cldzvwhmv00052irhcxnq7xy9","_id":"cldzvwhmw00092irhbebsbnb2"},{"post_id":"cl8xvcrp90000cwrh3d2m0vcn","category_id":"cldzvwhmv00072irhcd8k3kxx","_id":"cldzvwhmw000a2irha0e2dfqf"},{"post_id":"cks4bvdqb00046prhaiheadmu","category_id":"cldzvwhml00002irhc3dh41yl","_id":"cldzvwhnb000e2irhcgnh5tdm"},{"post_id":"ckqj7afay0000ydrh8uk999x0","category_id":"cldzvwhml00002irhc3dh41yl","_id":"cldzvwhnc000g2irhfdxgg5u5"},{"post_id":"ckpwpsg3n0000jgrh87z2bjun","category_id":"cldzvwhml00002irhc3dh41yl","_id":"cldzvwhnc000h2irhc8pd3fw0"},{"post_id":"cldzvwhn8000b2irheay0e2no","category_id":"cldzvwhn9000c2irh00scc01o","_id":"cldzvwhnc000i2irh07o23kr9"},{"post_id":"cks4bvdpz00006prh4ivt2shg","category_id":"cldzvwhml00002irhc3dh41yl","_id":"cldzvwhnh000j2irhfy7s1xem"},{"post_id":"cl8wzj7we0001harh5laug34y","category_id":"cldzvwhmu00022irh01iu43h9","_id":"cldzvwhnh000k2irh7u1906st"},{"post_id":"ckp7s7zru0000hjrh9lrc508u","category_id":"cldzvwhmv00052irhcxnq7xy9","_id":"cldzw3xyd0000errh4jap84nr"}],"PostTag":[{"post_id":"ckncr32gd0000l8rhhz07cxn5","tag_id":"ckncr32gi0001l8rh1cq3a1e7","_id":"ckncr32gl0002l8rh60xt53m0"},{"post_id":"ckng69t8o0000e4rh5kz3b781","tag_id":"ckng69t8t0001e4rhdydi54b0","_id":"ckng69t8w0004e4rhgwp3dxwf"},{"post_id":"ckng69t8o0000e4rh5kz3b781","tag_id":"ckng69t8v0003e4rhhg315on3","_id":"ckng69t8w0005e4rhdzwc63dp"},{"post_id":"ckp7s7zru0000hjrh9lrc508u","tag_id":"ckp7s7zs90001hjrh94df6362","_id":"ckp7s7zse0003hjrhgmib2r31"},{"post_id":"ckpwpsg3n0000jgrh87z2bjun","tag_id":"ckpwpsg4j0002jgrh36212xlv","_id":"ckpwpsg4r0006jgrh7x40cqc3"},{"post_id":"ckpwpsg3n0000jgrh87z2bjun","tag_id":"ckpwpsg4m0003jgrh8hjz0f1e","_id":"ckpwpsg4r0007jgrhc05a2tp4"},{"post_id":"ckpwpsg3n0000jgrh87z2bjun","tag_id":"ckpwpsg4p0005jgrhg1rv3035","_id":"ckpwpsg4r0008jgrh6v8pfa39"},{"post_id":"ckpwpwd070000qfrhdxjx5jnr","tag_id":"ckpwpsg4j0002jgrh36212xlv","_id":"ckpwpwd0q0001qfrhf9hf7i3k"},{"post_id":"ckpwpwd070000qfrhdxjx5jnr","tag_id":"ckpwpsg4m0003jgrh8hjz0f1e","_id":"ckpwpwd0r0002qfrh77ys835k"},{"post_id":"ckpwpwd070000qfrhdxjx5jnr","tag_id":"ckpwpsg4p0005jgrhg1rv3035","_id":"ckpwpwd0s0004qfrhfbl7f9z7"},{"post_id":"ckqj7afay0000ydrh8uk999x0","tag_id":"ckpwpsg4j0002jgrh36212xlv","_id":"ckqj7afbh0001ydrh22di48g9"},{"post_id":"ckqj7afay0000ydrh8uk999x0","tag_id":"ckpwpsg4m0003jgrh8hjz0f1e","_id":"ckqj7afbh0002ydrhezxg05uh"},{"post_id":"ckqj7afay0000ydrh8uk999x0","tag_id":"ckpwpsg4p0005jgrhg1rv3035","_id":"ckqj7afbi0004ydrheg05g21h"},{"post_id":"cks4bvdqb00046prhaiheadmu","tag_id":"ckpwpsg4j0002jgrh36212xlv","_id":"cks4bvdqd00056prhcz5c2esw"},{"post_id":"cks4bvdqb00046prhaiheadmu","tag_id":"ckpwpsg4m0003jgrh8hjz0f1e","_id":"cks4bvdqd00066prh0db231vm"},{"post_id":"cks4bvdqb00046prhaiheadmu","tag_id":"ckpwpsg4p0005jgrhg1rv3035","_id":"cks4bvdqe00086prh7qpa9xe4"},{"post_id":"cks4bvdpz00006prh4ivt2shg","tag_id":"ckpwpsg4j0002jgrh36212xlv","_id":"cks5kgk8k0000v1rh1rsc4k7h"},{"post_id":"cks4bvdpz00006prh4ivt2shg","tag_id":"ckpwpsg4m0003jgrh8hjz0f1e","_id":"cks5kgk8l0001v1rhd17b49rp"},{"post_id":"cks4bvdpz00006prh4ivt2shg","tag_id":"ckpwpsg4p0005jgrhg1rv3035","_id":"cks5kgk8l0003v1rh7hp7bbam"},{"post_id":"cl3qvw1650000fkrh4pfv31i9","tag_id":"ckt3vfzsf0002xgrh0z2o9ls8","_id":"cl3qvw1690001fkrh0vjz8d2y"},{"post_id":"cl40x3tit00011erhfttxevjc","tag_id":"cl40x3tiw00031erh7a026nlp","_id":"cl40x3tiy00081erhgurw8jku"},{"post_id":"cl40x3tit00011erhfttxevjc","tag_id":"cl40x3tix00061erh66t42ys7","_id":"cl40x3tiy000a1erhf7dwhguv"},{"post_id":"cl411w4jh00002nrh29dc6w18","tag_id":"cl40x3tiw00031erh7a026nlp","_id":"cl411w4jr00022nrh09bn912l"},{"post_id":"cl411w4jh00002nrh29dc6w18","tag_id":"cl40x3tix00061erh66t42ys7","_id":"cl411w4jt00032nrh9qoj3736"},{"post_id":"cl8wzj7we0001harh5laug34y","tag_id":"cknazwu1q0002vbrhfedc5y15","_id":"cl8wzj7wm000charhdp4tbd7n"},{"post_id":"cl8wzj7we0001harh5laug34y","tag_id":"cl8wzj7wh0003harhfkmp9ymm","_id":"cl8wzj7wm000dharh5gr34hiq"},{"post_id":"cl8wzj7we0001harh5laug34y","tag_id":"cl8wzj7wk0007harh05mjc1g2","_id":"cl8wzj7wm000gharhe89pfdhm"},{"post_id":"cl8x13kpj0000k1rh1w3a8dsx","tag_id":"cknazwu1q0002vbrhfedc5y15","_id":"cl8x13kpm0001k1rh0izwa3gv"},{"post_id":"cl8x13kpj0000k1rh1w3a8dsx","tag_id":"cl8wzj7wh0003harhfkmp9ymm","_id":"cl8x13kpm0002k1rh1zdfgd5x"},{"post_id":"cl8x13kpj0000k1rh1w3a8dsx","tag_id":"cl8wzj7wk0007harh05mjc1g2","_id":"cl8x13kpm0004k1rhgwl052el"},{"post_id":"cl8xvcrp90000cwrh3d2m0vcn","tag_id":"cl8xvcrpg0002cwrhce3san9u","_id":"cl8xvcrpi0007cwrhhy3v5808"},{"post_id":"cl8xvcrp90000cwrh3d2m0vcn","tag_id":"cl8xvcrph0003cwrh4rtl9mza","_id":"cl8xvcrpi0008cwrh6jon1uee"},{"post_id":"cl8xvcrp90000cwrh3d2m0vcn","tag_id":"cl8xvcrph0005cwrh6eul8542","_id":"cl8xvcrpi0009cwrha9l69z6q"},{"post_id":"cl8xvcrp90000cwrh3d2m0vcn","tag_id":"cl8xvcrph0006cwrh3j6m7zpv","_id":"cl8xvcrpi000acwrhhxac7zir"},{"post_id":"cldzvwhn8000b2irheay0e2no","tag_id":"cldzvwhn9000d2irh77i90l3s","_id":"cldzvwhnc000f2irh6dhogujy"}],"Tag":[{"name":"Python","_id":"cknaz41do0000qtrh12a5f5hu"},{"name":"jQuery","_id":"cknazjh3r0001knrhhknyfl1y"},{"name":"表格","_id":"cknazjh3s0002knrh6w7g87tj"},{"name":"表单验证","_id":"cknazjh3t0004knrhepc5hj2l"},{"name":"研招信息","_id":"cknazrpqg00021xrh2b2ebe29"},{"name":"Linux","_id":"cknazwu1q0002vbrhfedc5y15"},{"name":"权限控制","_id":"cknazwu1q0003vbrh5g1j8oki"},{"name":"沉思录","_id":"cknb0lvb0000241rhddoh19jm"},{"name":"Markdown","_id":"ckncr32gi0001l8rh1cq3a1e7"},{"name":"学习路线","_id":"ckng69t8t0001e4rhdydi54b0"},{"name":"计算机课程","_id":"ckng69t8v0003e4rhhg315on3"},{"name":"好吃的","_id":"ckngxqqjw0002itrhg0ro4wbo"},{"name":"人生","_id":"cknjtk0ns0001ptrh79bpciny"},{"name":"纪传","_id":"cknnddld800014drhb45d837s"},{"name":"Git","_id":"ckp7s7zs90001hjrh94df6362"},{"name":"程序结构","_id":"ckpwpsg4j0002jgrh36212xlv"},{"name":"CS61","_id":"ckpwpsg4m0003jgrh8hjz0f1e"},{"name":"CS61A","_id":"ckpwpsg4p0005jgrhg1rv3035"},{"name":"Years","_id":"ckt3vfzsf0002xgrh0z2o9ls8"},{"name":"Java","_id":"cktqnxlf700035arhg1ko0wqs"},{"name":"CS61B","_id":"cktqnxlfa00065arhhaq17t84"},{"name":"故事","_id":"cl40x3tiw00031erh7a026nlp"},{"name":"文章","_id":"cl40x3tix00061erh66t42ys7"},{"name":"MIT","_id":"cl8vpk7fg0005dzrh4km0cqcx"},{"name":"MissingSemaster","_id":"cl8vpk7fh0008dzrhf5xffi2n"},{"name":"编程素养","_id":"cl8vpk7fi000adzrh6wmug6wu"},{"name":"操作系统","_id":"cl8wzj7wh0003harhfkmp9ymm"},{"name":"命令行","_id":"cl8wzj7wk0007harh05mjc1g2"},{"name":"踩过的坑","_id":"cl8xvcrpg0002cwrhce3san9u"},{"name":"typora","_id":"cl8xvcrph0003cwrh4rtl9mza"},{"name":"picgo","_id":"cl8xvcrph0005cwrh6eul8542"},{"name":"oss","_id":"cl8xvcrph0006cwrh3j6m7zpv"},{"name":"村上春树","_id":"cldzvwhn9000d2irh77i90l3s"}]}}
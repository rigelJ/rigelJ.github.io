<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"Mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Donnie&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Donnie&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Donnie">
<meta property="article:tag" content="Python,GO，C++，爬虫，软件安全，漏洞分析">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Donnie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Donnie's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Donnie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">少年才背剑，转眼便江湖</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/About/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RigeJ" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/28/CS61A-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/28/CS61A-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/" class="post-title-link" itemprop="url">CS61A-数据抽象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-28 11:25:57" itemprop="dateCreated datePublished" datetime="2021-06-28T11:25:57+08:00">2021-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-30 16:11:03" itemprop="dateModified" datetime="2021-06-30T16:11:03+08:00">2021-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS61x/" itemprop="url" rel="index"><span itemprop="name">CS61x</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CS61A-数据抽象"><a href="#CS61A-数据抽象" class="headerlink" title="CS61A 数据抽象"></a>CS61A 数据抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>数据抽象导引</p>
<ul>
<li>构造器与选择器</li>
<li>序对的表示</li>
<li>抽象屏障与序对的过程性表示</li>
</ul>
<p>层次性数据和闭包性质</p>
<ul>
<li>序列的表示形式</li>
<li>可变数据与可变函数</li>
<li>层次性结构</li>
<li>迭代器与生成器</li>
</ul>
</blockquote>
<p><strong>带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。</strong></p>
<h3 id="数据抽象导引"><a href="#数据抽象导引" class="headerlink" title="数据抽象导引"></a>数据抽象导引</h3><hr>
<p>在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。</p>
<p><strong>数据抽象就是指将数据对象组合起来，构成复合数据的形式。</strong></p>
<p>这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adder_without</span>(<span class="params">a,b,c,d</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (ad+bc)//bd</span><br><span class="line"></span><br><span class="line">如果我们要计算<span class="number">1</span>/<span class="number">3</span>+<span class="number">4</span>/<span class="number">5</span>，那么我们就得这样传入参数</span><br><span class="line"></span><br><span class="line">&gt;&gt;adder_without(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">17</span>/<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。</p>
<p>但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？</p>
<p>答案就是构建构造函数与选择函数。</p>
<h4 id="构造器与选择器"><a href="#构造器与选择器" class="headerlink" title="构造器与选择器"></a>构造器与选择器</h4><p>接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">up,down</span>)：</span></span><br><span class="line">    return [up,down]</span><br><span class="line"></span><br><span class="line">于是我们可以利用分子分母构建有理数a和b</span><br><span class="line"></span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>/<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">build</span> up down) (<span class="name"><span class="builtin-name">cons</span></span> up down)</span><br></pre></td></tr></table></figure>

<p>而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_up</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_down</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">于是我们就可以使用以上两个函数提取数据</span><br><span class="line"></span><br><span class="line">a_up = get_up(a)</span><br><span class="line">b_down = get_down(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用构造器与选择器重写加法函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)</span><br><span class="line"></span><br><span class="line">使用构造函数</span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">new = add(a,b)</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立<code>sub</code>,<code>mul</code>,<code>pow</code>等运算函数。</p>
<h4 id="序对的表示"><a href="#序对的表示" class="headerlink" title="序对的表示"></a>序对的表示</h4><p>其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   <span class="type">List</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="type">Tuple</span></span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125; <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line">Python中万物皆对象，所以提取数据的方式非常简单</span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line">b[<span class="number">1</span>]</span><br><span class="line">c[<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>在scheme语言中，序对表示为cons，但是cons只能有两个数据：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> <span class="number">2</span>)   #相当于x = [<span class="name">1</span>,<span class="number">2</span>],但是scheme没有python高级，实现序列需要cons函数</span><br><span class="line">  </span><br><span class="line">使用 car 和 cdr 提取数据</span><br><span class="line">(<span class="name"><span class="builtin-name">car</span></span> x)</span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> x)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="抽象屏障与序对的过程性表示"><a href="#抽象屏障与序对的过程性表示" class="headerlink" title="抽象屏障与序对的过程性表示"></a>抽象屏障与序对的过程性表示</h4><p>抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最高层： 使用有理数运算函数的过程</span><br><span class="line"></span><br><span class="line">第一层： 有理数运算函数 add() sub() mul() </span><br><span class="line"></span><br><span class="line">第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）</span><br><span class="line">                                             </span><br><span class="line">第三层： 作为序对的有理数 cons() car()  cdr()  &#x2F;list[]  tuple[]</span><br></pre></td></tr></table></figure>

<p>这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。</p>
<p>例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">up,down</span>):</span> </span><br><span class="line">    g = gcd(up,down)</span><br><span class="line">    <span class="keyword">return</span> [up/g,down/g]</span><br></pre></td></tr></table></figure>

<p>这样就完成了约分有理数的过程。</p>
<p>一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">cons</span></span> x y))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> m))</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">=</span></span> m <span class="number">0</span>) x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">=</span></span> m <span class="number">1</span>) y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span>))</span><br><span class="line">    dispatch)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">car</span></span> z) (<span class="name">z</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> z) (<span class="name">z</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>由此我们可以看出，序对的概念实际上也可以解释为，由<code>(cons x y)</code>返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。</p>
<p>SICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？</p>
<p>答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(f(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上<code>one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x) </code>),把这个结构抽象出来就得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们要实现 two = successor(one)</span><br><span class="line">所以 two = <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(one(f)(x))</span><br><span class="line">令one = n 则有</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(n(f)(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def church_to_int(n):</span><br><span class="line">    return n(lambda x:x+1)(0)</span><br><span class="line"></span><br><span class="line">这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;church_to_int(one)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt;church_to_int(three)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>同样也可以对church对象进行加法运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_church</span>(<span class="params">m, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; church_to_int(add_church(two, three))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#church_to_int() if return 5 then five return five(f)</span></span><br><span class="line">    <span class="comment">#so we have to make add_church(two,three) like five(f)</span></span><br><span class="line">    <span class="comment">#five(f) return lambda x:f(f(f(f(f(x)))))  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(f)(x) +m(f)(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SICP中有church计数的scheme实现过程，大体类似。</p>
<h3 id="层次性数据和闭包性质"><a href="#层次性数据和闭包性质" class="headerlink" title="层次性数据和闭包性质"></a>层次性数据和闭包性质</h3><p>我们可以建立元素本身也是序对/序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。</p>
<h4 id="序列的表示形式"><a href="#序列的表示形式" class="headerlink" title="序列的表示形式"></a>序列的表示形式</h4><p>在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> </span><br><span class="line">   (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">2</span> </span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> nil)))</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">list(1,2,3)</span><br><span class="line"></span><br><span class="line">def lists (list(1,2,3)):</span><br></pre></td></tr></table></figure>

<p>通过上面的方式构建起<code>lists</code>这个表对象，而后使用cdr和car对表对象包含的数据进行调用</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">car</span></span> lists)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> lists)</span><br><span class="line">(<span class="name">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">car</span></span>(<span class="name"><span class="builtin-name">cdr</span></span> lists))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>我们也可以构建函数返回表中的第n个项：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">list-n</span> list n))</span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">car</span></span> list)</span><br><span class="line">      (<span class="name">list-n</span> (<span class="name"><span class="builtin-name">cdr</span></span> items) (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">于是对lists对象使用</span><br><span class="line">    </span><br><span class="line">(<span class="name">list-n</span> lists <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>scheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样的过程只需要</span><br><span class="line"></span><br><span class="line">lists = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">调用返回第n项也只需要</span><br><span class="line"></span><br><span class="line">a = lists[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>



<h4 id="可变数据与可变函数"><a href="#可变数据与可变函数" class="headerlink" title="可变数据与可变函数"></a>可变数据与可变函数</h4><p>由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&lt;stat&gt;)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">min</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,key=)</span><br><span class="line"><span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">any</span>()</span><br><span class="line"><span class="built_in">bool</span>()</span><br></pre></td></tr></table></figure>

<p>以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于<strong>可变序列</strong>，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可变序列：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].append(<span class="string">&#x27;a&#x27;</span>)   </span><br><span class="line">dicts[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">不可变序列</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.append(<span class="string">&#x27;a&#x27;</span>)    Error</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>).append(<span class="string">&#x27;a&#x27;</span>)   Error</span><br></pre></td></tr></table></figure>

<p>具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表<code>list1 = [1,2,3,4]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    list1.append(x)</span><br><span class="line">    list1.append(x)</span><br><span class="line"></span><br><span class="line">执行func(<span class="number">3</span>)后list1会改变吗？</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;func(<span class="number">3</span>)</span><br><span class="line">&lt;&lt;&lt;list1</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。</span><br></pre></td></tr></table></figure>

<p>有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_money</span>(<span class="params">my_money</span>):</span></span><br><span class="line">     my_money -=<span class="number">20</span></span><br><span class="line">     <span class="keyword">return</span> my_money</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;my_money = <span class="number">100</span></span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money</span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>我们会发现这种方式很麻烦，因为要不断返回和重新赋值给<code>my_money</code>变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？</p>
<p>有的，那就是<strong>可变函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_draw</span>(<span class="params">balance</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_draw</span>(<span class="params">acount</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            balance = balance - acount</span><br><span class="line">            <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里出现了一个新的类型<code>nonlocal</code>，意思是非本地，也就是说，定义为<code>nonlocal</code>的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 <code>nonlocal</code>必须满足以下几个条件才能使用：</p>
<blockquote>
<p>1.nonlocal 声明的变量必须存在于父框架</p>
<p>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。</p>
</blockquote>
<p>我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？</p>
<p>答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于<code>balance=balance-accont</code>这个表达式判断balance是本地变量，而后在<code>if account &gt; balance</code>中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）</p>
<p>有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_draw</span>(<span class="params">balance</span>):</span></span><br><span class="line">    b= []</span><br><span class="line">    b[<span class="number">0</span>] = balance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_draw</span>(<span class="params">acount</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b[<span class="number">0</span>] = b[<span class="number">0</span>] - acount</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。</p>
<h4 id="层次性结构"><a href="#层次性结构" class="headerlink" title="层次性结构"></a>层次性结构</h4><p>序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span>(<span class="params">label, branches=[]</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">label</span>(<span class="params">tree</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> branches(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> is_tree(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="params">tree</span>) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(<span class="params">tree</span>) &lt; <span class="number">1</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(<span class="params">branch</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">return</span> <span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="literal">True</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> is_leaf(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    otherwise.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="keyword">not</span> branches(<span class="params">tree</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> print_tree(<span class="params">t, indent=<span class="number">0</span></span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    indented by two spaces times its depth from the root.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; print_tree(tree(1))</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; print_tree(numbers)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      3</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        4</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        5</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      6</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        7</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">print</span>(<span class="params"><span class="string">&#x27;  &#x27;</span> * indent + <span class="built_in">str</span>(<span class="params">label(<span class="params">t</span>)</span>)</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(<span class="params">t</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">        print_tree(<span class="params">b, indent + <span class="number">1</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br></pre></td></tr></table></figure>

<p>以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。</p>
<p>递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。</p>
<p>我们来看几个关于树结构的问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">问题一：替换具有指定数据的树节点</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_leaf</span>(<span class="params">t, old, new</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to old has</span></span><br><span class="line"><span class="string">    been replaced with new.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,</span></span><br><span class="line"><span class="string">    ...                  [tree(&#x27;balder&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;freya&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;frigg&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;sif&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))</span></span><br><span class="line"><span class="string">    odin</span></span><br><span class="line"><span class="string">      balder</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      frigg</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      thor</span></span><br><span class="line"><span class="string">        sif</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      freya</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">if</span> label(t)==old:</span><br><span class="line">            <span class="keyword">return</span> tree(new)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tree(label(t))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_leaf(b,old,new) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line">可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">问题二：在每个叶节点上插入新子树</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sprout_leaves</span>(<span class="params">t, vals</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in vals at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">          6</span></span><br><span class="line"><span class="string">          1</span></span><br><span class="line"><span class="string">          2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(s) <span class="keyword">for</span> s <span class="keyword">in</span> vals ])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        lsb = []</span></span><br><span class="line"><span class="string">        for b in branches(t):</span></span><br><span class="line"><span class="string">            lsb += sprout_leaves(b,vals)</span></span><br><span class="line"><span class="string">        return [tree(label(t),lsb)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[sprout_leaves(b,vals) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure>

<p>下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">问题三：对应树的相加</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_trees</span>(<span class="params">t1, t2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; numbers = tree(1,</span></span><br><span class="line"><span class="string">    ...                [tree(2,</span></span><br><span class="line"><span class="string">    ...                      [tree(3),</span></span><br><span class="line"><span class="string">    ...                       tree(4)]),</span></span><br><span class="line"><span class="string">    ...                 tree(5,</span></span><br><span class="line"><span class="string">    ...                      [tree(6,</span></span><br><span class="line"><span class="string">    ...                            [tree(7)]),</span></span><br><span class="line"><span class="string">    ...                       tree(8)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(numbers, numbers))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">        6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">      10</span></span><br><span class="line"><span class="string">        12</span></span><br><span class="line"><span class="string">          14</span></span><br><span class="line"><span class="string">        16</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \</span></span><br><span class="line"><span class="string">    tree(2, [tree(3, [tree(4)]), tree(5)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t1) <span class="keyword">and</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span>(tree(label(t1)+label(t2)))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t1):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t2))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lsp = []</span><br><span class="line">        node = label(t1)+label(t2)</span><br><span class="line">        zips = <span class="built_in">list</span>(<span class="built_in">zip</span>(branches(t1),branches(t2)))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t1)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t2)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t2)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t1)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里所用到的zip函数请自行查阅python指南，解答过程如上。</p>
<h4 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h4><p>Python和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。</p>
<p>迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   迭代值</span><br><span class="line">iters = <span class="built_in">iter</span>(prime)  迭代器</span><br></pre></td></tr></table></figure>

<p>利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line">StopIteration </span><br></pre></td></tr></table></figure>

<p>当到达处理序列末尾后再次调用<code>next</code>方法将会引发StopIteration异常，说明序列已经迭代完毕。</p>
<p>两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  =  <span class="built_in">range</span> ( <span class="number">3</span> ,  <span class="number">13</span> ) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第一个迭代器s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第二个迭代器t </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u  =  <span class="built_in">iter</span>(t)  <span class="comment"># 第二个迭代器的替代名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>这里有一个利用迭代器计算斐波纳契数列的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_iter</span>(<span class="params">n</span>):</span></span><br><span class="line">    prev,curr=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="built_in">list</span> = [prev,curr]</span><br><span class="line">    index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        prev,curr = curr,prev+curr</span><br><span class="line">        <span class="built_in">list</span> +=[curr]</span><br><span class="line">        index ++</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。</p>
<p>生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素</p>
<p>生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letters_generator</span>():</span></span><br><span class="line">    current = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> current &lt;=<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">yield</span> current</span><br><span class="line">        current =<span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;letters = letters_generator()</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(letters)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>再复杂一点可以这样使用生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">natural</span>():</span></span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">        x+<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;ns1,ns2=natural(),natural()</span><br><span class="line">&gt;&gt;&gt;[<span class="built_in">next</span>(ns1)*<span class="built_in">next</span>(ns2) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/12/CS61A-%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/12/CS61A-%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/" class="post-title-link" itemprop="url">CS61A-过程抽象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-12 15:15:32" itemprop="dateCreated datePublished" datetime="2021-06-12T15:15:32+08:00">2021-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 22:33:17" itemprop="dateModified" datetime="2021-06-14T22:33:17+08:00">2021-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS61x/" itemprop="url" rel="index"><span itemprop="name">CS61x</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CS61A-过程抽象"><a href="#CS61A-过程抽象" class="headerlink" title="CS61A 过程抽象"></a>CS61A 过程抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<p>程序设计的基本元素</p>
<ul>
<li>表达式</li>
<li>变量与环境</li>
<li>复合过程与函数</li>
<li>条件表达式与判定符号</li>
<li>过程作为黑箱抽象</li>
</ul>
<p>过程产生的计算</p>
<ul>
<li>线性递归与迭代</li>
<li>树形递归</li>
</ul>
<p>高阶函数抽象</p>
<ul>
<li>过程作为参数</li>
<li>过程作为一般性的方法</li>
<li>过程作为返回值</li>
<li>使用匿名函数构造过程</li>
</ul>
</blockquote>
<h3 id="程序设计的基本元素"><a href="#程序设计的基本元素" class="headerlink" title="程序设计的基本元素"></a>程序设计的基本元素</h3><hr>
<p>一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：</p>
<p>一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int(‘s’),这叫做复合表达式，表达式是语言最简单的个体。</p>
<p>二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素</p>
<p>三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用</p>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;s&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过将基本表达式进行组合，我们可以得到组合式</p>
<blockquote>
<p>3-1</p>
<p>‘s’ + ‘e’</p>
</blockquote>
<p>组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>+(<span class="number">4</span>*<span class="number">6</span>))*(<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p> 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。</p>
<p><img src="https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png" alt="image-20210612194156857"></p>
<h4 id="变量与环境"><a href="#变量与环境" class="headerlink" title="变量与环境"></a>变量与环境</h4><p>我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用<code>pi*(2**2)</code>进行计算，当我们想要计算的半径变为3时，我们又得写表达<code>pi*(3**2)</code>,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用<code>pi*(r**2)</code>就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。</p>
<p>不同语言定义变量的方式不同</p>
<p>Lisp</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> r <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。</p>
<h4 id="复合过程与函数"><a href="#复合过程与函数" class="headerlink" title="复合过程与函数"></a>复合过程与函数</h4><p>由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象</p>
<p>那么如果我们要对过程进行抽象该怎么办呢？</p>
<p>过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，<strong>为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。</strong></p>
<p>例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square</p>
<p>不同语言定义函数/复合过程名称的方式不同</p>
<p><em>Lisp</em></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x) (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure>

<p><em>Python</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>定义好之后就可以使用square进行调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(sqare <span class="number">21</span>)</span><br><span class="line">square(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以利用已定义好的函数去构建其他过程，以python为例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_sq</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> square(x) + square(y)</span><br></pre></td></tr></table></figure>

<p>还可以利用sum_sq去构造其他过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sum_aq(a,a)</span><br></pre></td></tr></table></figure>

<h4 id="条件表达式与符号"><a href="#条件表达式与符号" class="headerlink" title="条件表达式与符号"></a>条件表达式与符号</h4><p>至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式</p>
<p>不同的语言中条件表达式不同</p>
<p><em>Lisp</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</span><br><span class="line">     (<span class="name">cond</span>  (<span class="name">&gt;</span> x <span class="number">0</span>)x)</span><br><span class="line">            (<span class="name">=</span> x <span class="number">0</span>)<span class="number">0</span>)</span><br><span class="line">            (&lt; x 0)(-x))</span><br><span class="line">     )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Python没有switch语句，可以用if..elif…替代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> x = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> x &lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p>if是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。</p>
<p>除了&gt;&lt;=之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。</p>
<p>例如Lisp中</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">and</span>(<span class="name">&gt;</span> x <span class="number">5</span>)(<span class="name">&lt;</span> x <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h4 id="函数作为黑箱抽象"><a href="#函数作为黑箱抽象" class="headerlink" title="函数作为黑箱抽象"></a>函数作为黑箱抽象</h4><p>sqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的</p>
<p><img src="https://i.loli.net/2021/06/12/u4zixB95rycdopg.png" alt="image-20210612202953454"></p>
<p>这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。</p>
<h5 id="内部定义与块结构"><a href="#内部定义与块结构" class="headerlink" title="内部定义与块结构"></a>内部定义与块结构</h5><p>为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。</p>
<h3 id="函数产生的计算"><a href="#函数产生的计算" class="headerlink" title="函数产生的计算"></a>函数产生的计算</h3><hr>
<h4 id="线性递归与迭代"><a href="#线性递归与迭代" class="headerlink" title="线性递归与迭代"></a>线性递归与迭代</h4><p>我们以函数的阶乘为例，讲解函数的递归和迭代。</p>
<p>首先，我们使用递归来计算阶乘</p>
<p>考虑阶乘函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n! = n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>)..<span class="number">.1</span></span><br><span class="line">(n-<span class="number">1</span>)! = (n-<span class="number">1</span>)*(n-<span class="number">2</span>)..<span class="number">.1</span></span><br><span class="line">n! = n*(n-<span class="number">1</span>)! </span><br></pre></td></tr></table></figure>

<p>这样，我们就能通过算出(n-1)!，i进而计算出n！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">     <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这个过程如图所示</p>
<p><img src="https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png" alt="image-20210612215413983"></p>
<p>于是我们总结出迭代所需要的三个要素：</p>
<p><em>一是base_case也就是迭代终止条件</em></p>
<p>*二是可迭代拆分的结构，比如<code>factorial(n)</code>的结果就可以分解成为<code>n * factorial(n-1)</code></p>
<p><em>三是可以连续传递</em>，验证n与n-1的规则是否通用。</p>
<p>但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如</p>
<blockquote>
<p>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：</p>
<p>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,</p>
<p>def pingpong(n): ?</p>
</blockquote>
<p>这里的<code>pingpong(n)</code>和<code>pingpong(n-1)</code>无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pingpong</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">itera</span>(<span class="params">out,index=<span class="number">1</span>,adder=<span class="number">1</span></span>)</span></span><br><span class="line">        if index == n:</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">        <span class="keyword">if</span> index%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> itera(out+adder,index+<span class="number">1</span>,adder=-adder)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> itera(out+adder,index+<span class="number">1</span>,adder=adder)</span><br><span class="line">    out = itera(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> out </span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<p>这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。</p>
<p>而后，我们再使用迭代对阶乘进行计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a = a*i</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。</p>
<p>迭代的表示如下：</p>
<p><img src="https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png" alt="image-20210613110228758"></p>
<p>迭代和递归是两种最常见的循环过程，其主要不同点在于：</p>
<p>一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。</p>
<p>迭代：</p>
<p><img src="https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png" alt="image-20210613110437725"></p>
<p>递归：</p>
<p><img src="https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png" alt="image-20210613110636563"></p>
<p>二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。</p>
<h4 id="树形递归"><a href="#树形递归" class="headerlink" title="树形递归"></a>树形递归</h4><p>树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。</p>
<p>首先我们以递归的思路来考虑</p>
<p><code>feb(n)</code>和<code>feb(n-1)</code>有什么关系？</p>
<p>貌似没有关系，但是我们知道<code>feb(n)=feb(n-1)+feb(n-2)</code></p>
<p>因此我们可以这样设计递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feb</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：</p>
<p><img src="https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png" alt="image-20210613112437233"></p>
<p>树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题</p>
<blockquote>
<p>Q7：河内塔<br>一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。</p>
<p><img src="https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png" alt="image-20210613154038670"></p>
<p>拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：</p>
<p>一次只能移动一个磁盘。<br>每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。<br>任何磁盘都不能放置在较小磁盘的顶部。<br>完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。</p>
<p>题目给出了两个内置函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_move</span>(<span class="params">origin, destination</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print instructions to move a disk.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Move the top disk from rod&quot;</span>, origin, <span class="string">&quot;to rod&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_stack</span>(<span class="params">n, start, end</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print the moves required to move n disks on the start pole to the end</span></span><br><span class="line"><span class="string">    pole without violating the rules of Towers of Hanoi.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该<code>move_stack(3,1,3)</code>,而<code>move_stack(3,1,3)</code>这个过程可以分解为</p>
<p>一.先将上面两层移动至2,即<code>move_stack(2,1,2)</code></p>
<p>二.将底层移动到3,即<code>move_stack(1,1,3)</code></p>
<p>三.将在2的两层移至3,即<code>move_stack(2,2,3)</code></p>
<p>我们会发现实际上<code>move_stack(n,a,c)</code>可以分解为<code>move_stack(n-1,a,b)</code>，<code>move_stack(1,a,c)</code>,<code>move_stack(n-1,b,c)</code></p>
<p>因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。</p>
<p>具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_stack</span>(<span class="params">n,start,end</span>):</span></span><br><span class="line">        bars = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        print_move(start,end)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c=[bar <span class="keyword">for</span> bar <span class="keyword">in</span> bars <span class="keyword">if</span> bar <span class="keyword">not</span> <span class="keyword">in</span> [start,end] ]</span><br><span class="line">        c = c[<span class="number">0</span>]</span><br><span class="line">        a = start</span><br><span class="line">        b = end </span><br><span class="line">        move_stack(n-<span class="number">1</span>,a,c)</span><br><span class="line">        move_stack(<span class="number">1</span>,a,b)</span><br><span class="line">        move_stack(n-<span class="number">1</span>,c,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的base_case就是n==1。</p>
<h3 id="高阶函数抽象"><a href="#高阶函数抽象" class="headerlink" title="高阶函数抽象"></a>高阶函数抽象</h3><hr>
<h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>思考一下以下两个函数</p>
<p>第一个 sum_naturals函数计算最大为n的自然数之和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_naturals</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + [k], k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个sum_pi计算系列中的项的总和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi_sum</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + [<span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>))], k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xx</span> (<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">n,term</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">natural</span>(<span class="params">k</span>):</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi</span>(<span class="params">k</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。</p>
<h4 id="函数作为一般性方法"><a href="#函数作为一般性方法" class="headerlink" title="函数作为一般性方法"></a>函数作为一般性方法</h4><p>刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>	<span class="function"><span class="keyword">def</span> <span class="title">improve</span>(<span class="params">update, close, guess=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="number">2</span>	    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line"><span class="number">3</span>	        guess = update(guess)</span><br><span class="line"><span class="number">4</span>	    <span class="keyword">return</span> guess</span><br><span class="line"><span class="number">5</span>	</span><br><span class="line"><span class="number">6</span>	<span class="function"><span class="keyword">def</span> <span class="title">golden_update</span>(<span class="params">guess</span>):</span></span><br><span class="line"><span class="number">7</span>	    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"><span class="number">8</span>	</span><br><span class="line"><span class="number">9</span>	<span class="function"><span class="keyword">def</span> <span class="title">square_close_to_successor</span>(<span class="params">guess</span>):</span></span><br><span class="line"><span class="number">10</span>	    <span class="keyword">return</span> approx_eq(guess * guess,</span><br><span class="line"><span class="number">11</span>	                     guess + <span class="number">1</span>)</span><br><span class="line"><span class="number">12</span>	</span><br><span class="line"><span class="number">13</span>	<span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span></span><br><span class="line"><span class="number">14</span>	    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line"><span class="number">15</span>	</span><br><span class="line"><span class="number">16</span>	phi = improve(golden_update,</span><br><span class="line"><span class="number">17</span>	              square_close_to_successor)</span><br></pre></td></tr></table></figure>

<p>我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve</span>(<span class="params">guess=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">golden_update</span>(<span class="params">guess</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square_close_to_successor</span>(<span class="params">guess</span>):</span></span><br><span class="line">           <span class="keyword">return</span> approx_eq(guess * guess,guess + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span> <span class="keyword">not</span> square_close_to_successor(guess):</span><br><span class="line">        guess = golden_update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line">phi = improve()</span><br></pre></td></tr></table></figure>

<p>这样一来整体的函数结构就清晰多了。</p>
<h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。</p>
<p>一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用现有工具定义函数组合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose1</span>(<span class="params">f, g</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="keyword">return</span> f(g(x))</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>

<p>这时候返回的函数就是f(g(x))</p>
<p>函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。</p>
<p>柯里化的具体实现过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curi_pow</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x,y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当调用<code>curi_pow(2)(3)</code>时，首先计算curi_pow(2),返回的函数实际上就是 <code>lambda  x: pow(2,x)</code>，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此<code>curi_pow(2)（3）</code>实际上是<code>lambda x:pow(2,x)(3)</code>也就是pow(2,3)</p>
<p>我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curi</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">y</span>):</span></span><br><span class="line">            <span class="keyword">return</span> f(x,y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure>

<p>具体推导过程 如下：</p>
<p>要使得  s(x)(y) = f(x,y)，则s = lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。</p>
<p>柯里化也可以反向进行，具体实现过程为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uncuri</span>(<span class="params">g</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">x,y</span>):</span></span><br><span class="line">            <span class="keyword">return</span> g(x)(y)</span><br><span class="line">     <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>

<p>同理，要使得 f(x,y) = g(x)(y)，则 f = lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。</p>
<h4 id="使用匿名函数构造过程"><a href="#使用匿名函数构造过程" class="headerlink" title="使用匿名函数构造过程"></a>使用匿名函数构造过程</h4><p>到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。</p>
<p>lambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">lambda</span> x:x*x</span><br><span class="line">s(<span class="number">2</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。</p>
<p>一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose1=<span class="keyword">lambda</span> f,g:<span class="keyword">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure>

<p>匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。</p>
<p>我们知道，使用递归来进行阶乘的计算如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么如果使用匿名函数来进行递归，结构又该是什么样的呢？</p>
<p>我们先来看一个简单一点的方案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fact = <span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> n*fact(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> n,f:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> n*f(n-<span class="number">1</span>,f) </span><br></pre></td></tr></table></figure>

<p>于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact= lambda n,f:1 if n==1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。</p>
<p>解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。</p>
<p>fact = lambda n:(lambda g:g(n,f))(lambda n,f:1 if n==1 else n*f(n-1,f))</p>
<p>这个结构的原理是这样的，fact(3)首先等于<code>(lambda f:f(3,f))</code>，然而由于后i面还有一个<code>(lambda n,f:1 if n==1 else n*f(n-1,f))</code>因此f函数的值被填充为匿名函数，成为f(3,f) 其中 <code>f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/12/CS61A-%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/12/CS61A-%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">CS61A-综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-12 15:04:18" itemprop="dateCreated datePublished" datetime="2021-06-12T15:04:18+08:00">2021-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 22:38:34" itemprop="dateModified" datetime="2021-06-14T22:38:34+08:00">2021-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS61x/" itemprop="url" rel="index"><span itemprop="name">CS61x</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>946</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CS61A-综述"><a href="#CS61A-综述" class="headerlink" title="CS61A 综述"></a>CS61A 综述</h2><p>简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。</p>
<p>首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。</p>
<p>而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。</p>
<p>最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。</p>
<p>本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。</p>
<p>但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。</p>
<p>从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。</p>
<p>从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/27/%E7%AE%80%E6%98%8EGit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/27/%E7%AE%80%E6%98%8EGit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">简明Git使用方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-27 15:37:40" itemprop="dateCreated datePublished" datetime="2021-05-27T15:37:40+08:00">2021-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-28 16:56:36" itemprop="dateModified" datetime="2021-05-28T16:56:36+08:00">2021-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">软件文档</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>版本库的创建</p>
<ul>
<li> Git的安装</li>
<li> 版本库的创建</li>
</ul>
<p>版本库的操作</p>
<ul>
<li> 文件操作</li>
<li> 版本回退</li>
<li> 修改撤销 </li>
</ul>
<p>远程库连接</p>
<ul>
<li>远程库添加与解除</li>
<li>从远程库克隆</li>
</ul>
<p>分支管理</p>
<ul>
<li>创建与合并分支</li>
<li>多人协作</li>
</ul>
<p>标签管理</p>
<ul>
<li>创建标签</li>
<li>操作标签</li>
</ul>
</blockquote>
<h2 id="版本库的创建"><a href="#版本库的创建" class="headerlink" title="版本库的创建"></a>版本库的创建</h2><hr>
<h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><p>在Ubuntu Linux上使用apt软件包管理工具进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>在windows上直接进入<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">Git官网</a>下载安装程序，而后按照默认选项安装即可</p>
<h3 id="版本库的创建-1"><a href="#版本库的创建-1" class="headerlink" title="版本库的创建"></a>版本库的创建</h3><p>选择一个合适的位置利用mkdir指令创建一个空目录，而后进入后输入指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>于是该目录就变成了Git可以管理的仓库，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<h2 id="版本库的操作"><a href="#版本库的操作" class="headerlink" title="版本库的操作"></a>版本库的操作</h2><hr>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在文件操作之前首先明确几个概念</p>
<p><strong>工作区</strong></p>
<p>就是电脑中能直接看见的目录</p>
<p><img src="https://i.loli.net/2021/05/28/Vc1mn4w6MZIaRSB.png" alt="working-dir"></p>
<p><strong>版本库</strong></p>
<p>工作区目录中有一个隐藏目录.git。这个是Git的版本库，版本库主要由两个部分组成，stage暂存区和分支区。</p>
<p><img src="https://i.loli.net/2021/05/28/nzqcBheNH58kMAG.jpg" alt="git-repo"></p>
<p> <strong>将文件添加至Git版本库中时，有三个步骤：</strong></p>
<p><strong>首先</strong>在工作区创建一个文件Read.txt</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim/typora Read.txt</span><br></pre></td></tr></table></figure>

<p>将文件修改添加至暂存区，在添加至暂存区前，我们首先看一下git的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">	Read.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Git清楚的告诉我们，有一个文件出现了，而<code>Read.txt</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p><strong>而后</strong>我们创建文件这次操作添加至暂存区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add Read.txt</span><br></pre></td></tr></table></figure>

<p><em>如果添加的是文件夹可以使用</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add vs/*</span><br></pre></td></tr></table></figure>

<p>如果想删除文件可以用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm Read.txt</span><br></pre></td></tr></table></figure>

<p>再次查看git的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">	new file:   Read.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Changes to be committed</code>我们发现git已经识别了这个文件，可见这个文件已经被添加到了暂存区。</p>
<p><strong>最后</strong>我们将文件创建这次操作提交至仓库的master分支（分支的概念后面会讲到）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit Read.txt -m <span class="string">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure>

<p><em>如果想提交全部文件的操作可以用</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的-m参数是对这次提交进行文字说明</p>
<p>再次查看git的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见此时暂存区为空，修改已提交至仓库</p>
<p>我们可以将创建文件并提交至仓库的过程用流程图表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[在工作区创建文件]&#x3D;&#x3D;&#x3D;&gt;B[将修改&#x2F;创建&#x2F;删除操作添加至暂存区]&#x3D;&#x3D;&#x3D;&#x3D;&gt;C[将操作提交至仓库]</span><br></pre></td></tr></table></figure>

<p>估计很多人都有疑问，为什么这里写的是操作，而不是将文件添加至暂存区，因为Git管理的是修改而不是文件，我们用一个例子来说明这个问题。</p>
<p>首先，我们在Read.txt中添加一段文字<code>hello me</code>，而后将这次操作添加到暂存区，我们查看此时的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">	modified:   Read.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见此次修改已经添加到了暂存区，而后我们再对文件进行修改，增加一行<code>hello you</code>，不将此次修改添加至暂存区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">	modified:   Read.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">	modified:   Read.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们执行提交指令将修改提交至仓库，而后查看git状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 8 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">	modified:   Read.txt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现，未添加至暂存区的修改并未提交至仓库，我们查看一下工作区和最新版本库的区别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git diff -- Read.txt</span><br><span class="line">diff --git a/Read.txt b/Read.txt</span><br><span class="line">index 1f8eec4..12ee40e 100644</span><br><span class="line">--- a/Read.txt</span><br><span class="line">+++ b/Read.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> hello world</span><br><span class="line"> hello me</span><br><span class="line">+hello you</span><br></pre></td></tr></table></figure>

<p>如果Git管理的是文件本身，那么文件在提交时是什么样，提交的文件就是什么样，然而经过对比发现，版本库的文件和工作区的文件是不一样，我们每次添加到暂存区的是对文件的操作步骤，比如创建删除文件，添加几行，删除几行，由于刚才添加<code>hello you</code>这一行文字的修改操作并未添加至暂存区，提交时只提交暂存区有的操作，因此该操作未提交至仓库。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>上面i讲到，Git管理的是修改，如果我们在进行修改提交的过程中，不小心删除了最后一行<code>hello me</code> ，而我们又需要这行文字该怎么办呢？</p>
<p>这时候就需要利用版本回退的功能了。</p>
<p>在Git中，我们可以查看每次操作的记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">aa03a474011bcb97e9f596d3b5c9a1b517726d05 (HEAD -&gt; master) delete a line</span><br><span class="line">05491fda20edff579daf14f24b7afed61d591842 add a line</span><br><span class="line">a58d42838b1284034c4a9d52f0d2780ad251bda2 a</span><br><span class="line">f67db85d1deeb3d7ca0020a332ac4e07bccf12b0 all</span><br><span class="line">b96112ab41f972a9949e213347d7403dd2f8a03b 1</span><br></pre></td></tr></table></figure>

<p>我们要将版本回退到<code>delete a line</code>操作前，因此我们使用<code>reset</code>指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 05491fd add a line</span><br></pre></td></tr></table></figure>

<p>这里的HEAD^表示上一个版本，如果上两个版本则为^^,以此类推。</p>
<p>但是问题来了，如果我们现在又想回到<code>delete a line</code>版本该怎么办呢？版本已经回退了。</p>
<p>git有一个命令记录了你的每次命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git reflog</span><br><span class="line">05491fd (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">aa03a47 HEAD@&#123;1&#125;: commit: delete a line</span><br><span class="line">05491fd (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add a line</span><br></pre></td></tr></table></figure>

<p>于是我们就可以利用<code>aa03a47</code>这个id来回到原来版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard aa03a47</span><br><span class="line">HEAD is now at aa03a47 delete a line</span><br></pre></td></tr></table></figure>

<p>于是，版本又回来了。</p>
<h3 id="修改撤销"><a href="#修改撤销" class="headerlink" title="修改撤销"></a>修改撤销</h3><p>有的时候我们会因为手抖写错代码，比如我们在Read.txt（.sh）文件中添加一行‘rm -rf’，懂点Linux都知道这是个致命操作。</p>
<p><strong>如果你还没有将这次文件修改提交到暂存区</strong>，那么很简单，直接修改就好了，或者也可以使用指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- Read.txt</span><br></pre></td></tr></table></figure>

<p>工作区的修改就被丢弃了，工作区文件的内容和版本库文件的内容相同。</p>
<p><strong>如果你已经将文件修改添加到了暂存区</strong>，那么我们需要使用另一个指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD Read.txt</span><br></pre></td></tr></table></figure>

<p>reset指令不仅可以回退版本，当HEAD不^时，reset指令也可以将暂存区的修改操作移除，而后再利用<code>checkout</code>指令同步版本库和工作区内容。</p>
<p><strong>如果你已经将修改提交到了版本库</strong>，那么按照版本回退的方式进行即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>如果你已经将版本库内的内容推送到远程库，比如Github，那就只能听天由命了，谁运行，谁遭殃。</p>
<h2 id="远程库连接"><a href="#远程库连接" class="headerlink" title="远程库连接"></a>远程库连接</h2><hr>
<h3 id="远程库添加-解除"><a href="#远程库添加-解除" class="headerlink" title="远程库添加/解除"></a>远程库添加/解除</h3><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>
<p>（图借的廖雪峰大L的）：</p>
<p><img src="https://i.loli.net/2021/05/28/HYRADbO3nfjtW9T.png" alt="github-create-repo-1"></p>
<p>在Repository name填入<code>Read</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="https://i.loli.net/2021/05/28/P62pheNWtkZSVcB.png" alt="github-create-repo-2"></p>
<p>而后，我们在本地运行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxx/Read.git</span><br></pre></td></tr></table></figure>

<p>xxx处为你自己的Github账户名，就可以将本地的版本库和远程的库连接起来了。</p>
<p>将本地库所有内容推送至Github远程库的master分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push （-u） origin master</span><br></pre></td></tr></table></figure>

<p>加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令，不许需要加入-u参数。</p>
<p><strong>SSH警告</strong></p>
<p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>

<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a target="_blank" rel="noopener" href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>
<p><strong>解除远程库与本地库的关联关系</strong></p>
<p>如果我们需要解除本地库与远程库的关联关系，可以使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>



<h3 id="远程库克隆"><a href="#远程库克隆" class="headerlink" title="远程库克隆"></a>远程库克隆</h3><p>我们有时需要把远程库从Github克隆下来，为了借鉴代码或是进行分布式工作，使用以下指令将远程库克隆至本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xxx/Read.git</span><br></pre></td></tr></table></figure>



<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr>
<h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p><img src="https://i.loli.net/2021/05/28/X69umbEgxRBfh3w.png" alt="git-br-initial"></p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p>
<p><img src="https://i.loli.net/2021/05/28/EXNTRAfMmV2B63a.png" alt="git-br-create"></p>
<p>我们建立一个新分支<code>dev</code>并切换至新分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev    /   git switch -c dev</span><br></pre></td></tr></table></figure>

<p><em>如果切换至已有分支则</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev    /    git switch dev</span><br></pre></td></tr></table></figure>

<p>如果只是创建分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure>

<p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="https://i.loli.net/2021/05/28/dQuX31cxi6RTeDO.png" alt="git-br-ff-merge"></p>
<p>我们切换至主分支，而后将dev分支合并至主分支master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p>而后我们可以保留分支，也可以删除分支，如果删除分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>



<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="https://i.loli.net/2021/05/28/tWO9ydfr5miY3EP.png" alt="git-br-policy"></p>
<p><strong>远程库克隆</strong></p>
<p>团队合作的过程中首先要将远程库克隆至本地，具体方式见前文远程库克隆一节</p>
<p>完成克隆后，Git自动把本地的master分支和远程的master分支对应起来了，默认远程仓库的名称为origin</p>
<p>查看远程库的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git remote -v</span><br><span class="line">origin	git@github.com:x/CS61A.git (fetch)</span><br><span class="line">origin	git@github.com:x/CS61A.git (push)</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<p><strong>分支的推送</strong></p>
<p>分支的推送有很多种模式，这里只介绍最简单的模式，假设，我们已经将远程库的master分支克隆到了本地，而后我们创建了一个新的分支dev，在新的分支进行工作，工作完毕后我们将dev分支合并至master分支，而后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>就将该分支推送到了远程库</p>
<p><strong>分支的抓取</strong></p>
<p>在多人协作时可能会出现一些问题，比如有一天，你的小伙伴已经向origin/master分支推送了他的提交，而你碰巧也对同样的文件进行了修改，并试图推送，这时候你会发现，git提示推送失败，因为你的小伙伴的最新提交和你的提交有冲突。</p>
<p>因此我们要在推送前先将master最新情况从远程抓下来，然后在本地进行合并和解决冲突。</p>
<p>解决冲突的方法如下</p>
<p>我们知道当我们把远程的master分支抓取下来后，我们本地的dev分支和远程pull下来的master分支存在冲突</p>
<p><img src="https://i.loli.net/2021/05/28/ve3HlyfWtqB7bYN.png" alt="git-br-feature1"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并会有冲突，我们查看 一下git的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   Read.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Git告诉我们，Read.txt文件存在冲突，我们可以直接查看文件内容</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>

<p>再提交修改给master分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>

<p>Git告诉我们冲突被解决了，于是我们将dev分支合并至master，而后执行push</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:x/Read.git</span><br><span class="line">   7a5e5dd..57c53ab  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>成功。</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>为什么需要标签？</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，而后敲击tag就可以打一个标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure>

<p>利用<code>git tag</code>查看所有标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br><span class="line">v2.1</span><br></pre></td></tr></table></figure>

<p>如果要对历史commit打标签，那就通过git log找到commit号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 f287d34</span><br></pre></td></tr></table></figure>

<p>查看每个标签的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后按照版本回退一节的方法使用<code>reset</code>指令回退至对应版本打包即可。</p>
<p>注意，标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag <span class="string">&#x27;v0.1&#x27;</span> (was f15b0dd)</span><br></pre></td></tr></table></figure>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或使用<code>git push origin --tags</code>推送所有标签。</p>
<p>如果要删除远程标签则先从本地删除标签，而后向远程同步删除指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:x/Read.gi0t</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程Git</a></p>
<p>2.<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p>
<p>3.<a target="_blank" rel="noopener" href="https://git-scm.com/">Git官方网站</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B2%BE%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B2%BE%E8%A6%81/" class="post-title-link" itemprop="url">Python数据分析精要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 18:53:01" itemprop="dateCreated datePublished" datetime="2021-05-24T18:53:01+08:00">2021-05-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/Python%E7%88%AC%E8%99%AB%E7%B2%BE%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/Python%E7%88%AC%E8%99%AB%E7%B2%BE%E8%A6%81/" class="post-title-link" itemprop="url">Python爬虫精要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 18:52:26" itemprop="dateCreated datePublished" datetime="2021-05-24T18:52:26+08:00">2021-05-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/16/%E6%88%91%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%92%8C%E9%AB%98%E5%B1%B1%E7%9A%84%E9%9B%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/%E6%88%91%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%92%8C%E9%AB%98%E5%B1%B1%E7%9A%84%E9%9B%AA/" class="post-title-link" itemprop="url">我走的路和高山的雪</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-16 12:15:52 / 修改时间：14:55:54" itemprop="dateCreated datePublished" datetime="2021-04-16T12:15:52+08:00">2021-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B2%89%E6%80%9D%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">沉思录</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>152</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>劫后余生，才知命运无常。</p>
<p>三场大火，烧光了所有希望，我站在熊熊烈焰面前，只一步就万劫不复，人类的悲欢从不相通，我只觉得他们吵闹，他们呼喊着，投来同情的目光，却只能远远的望着。这一刻我才发现，很多事情，除了自己咬着牙硬抗，没人能帮的了你。不怪朋友袖手旁观，也不怪父母相对无言，有些事情，你懂，他们未必也明白。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/13/CS%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/13/CS%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90/" class="post-title-link" itemprop="url">CS自学路线与课程推荐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-13 20:30:38 / 修改时间：23:33:43" itemprop="dateCreated datePublished" datetime="2021-04-13T20:30:38+08:00">2021-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94%E4%B9%8B%E8%B7%AF/" itemprop="url" rel="index"><span itemprop="name">考研之路</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CS基础课程自学路线与课程推荐"><a href="#CS基础课程自学路线与课程推荐" class="headerlink" title="CS基础课程自学路线与课程推荐"></a>CS基础课程自学路线与课程推荐</h1><p>简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考</p>
<p>注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。</p>
<hr>
<h3 id="计算机入门"><a href="#计算机入门" class="headerlink" title="计算机入门"></a>计算机入门</h3><h5 id="公开课程："><a href="#公开课程：" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><strong>哈佛大学 CS50</strong>   </li>
<li>斯坦福大学 CS101</li>
<li>麻省理工学院 6.00.1</li>
</ul>
<h5 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>《编码》： 一本讲清编码原理的书</li>
</ul>
<hr>
<h3 id="计算机程序结构与抽象"><a href="#计算机程序结构与抽象" class="headerlink" title="计算机程序结构与抽象"></a>计算机程序结构与抽象</h3><h5 id="公开课程：-1"><a href="#公开课程：-1" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><p><strong>加州大学伯克利分校  CS61A</strong></p>
</li>
<li><p>斯坦福大学 CS106A  [Python]  </p>
</li>
<li><p>卡内基梅隆大学 CMU 15-122 </p>
</li>
</ul>
<h5 id="书籍推荐：-1"><a href="#书籍推荐：-1" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><p>《计算机程序的构造和解释》</p>
<blockquote>
<p>SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。</p>
</blockquote>
<hr>
<h3 id="计算机系统架构与体系"><a href="#计算机系统架构与体系" class="headerlink" title="计算机系统架构与体系"></a>计算机系统架构与体系</h3><p>对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。</p>
<h5 id="公开课程：-2"><a href="#公开课程：-2" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><strong>计算机系统要素  Nand2Tetris</strong>    </li>
</ul>
<blockquote>
<p>这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I/O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。</p>
</blockquote>
<h5 id="书籍推荐：-2"><a href="#书籍推荐：-2" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>计算机系统要素  Nand2Tetris的原书</li>
</ul>
<hr>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。</p>
<h5 id="公开课程：-3"><a href="#公开课程：-3" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li><strong>加州大学伯克利分校  CS61B</strong></li>
</ul>
<blockquote>
<p>cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。</p>
</blockquote>
<ul>
<li>斯坦福 CS106B</li>
<li>卡内基梅隆大学 CMU 15-210</li>
</ul>
<h5 id="书籍推荐：-3"><a href="#书籍推荐：-3" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>算法导论  </li>
</ul>
<blockquote>
<p>老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。</p>
</blockquote>
<ul>
<li>大话数据结构</li>
</ul>
<blockquote>
<p>深入浅出的讲解数据结构，作为入门当小说看看挺好的。</p>
</blockquote>
<ul>
<li>算法图解</li>
</ul>
<blockquote>
<p>同样是入门书籍，看看培养兴趣挺好的。</p>
</blockquote>
<hr>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。</p>
<h5 id="公开课程：-4"><a href="#公开课程：-4" class="headerlink" title="公开课程："></a>公开课程：</h5><ul>
<li>斯坦福大学 CS144</li>
<li>网易云课堂 《计算机网络》</li>
</ul>
<h5 id="书籍推荐：-4"><a href="#书籍推荐：-4" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li><strong>计算机网络自顶而下</strong>  </li>
</ul>
<blockquote>
<p>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。</p>
</blockquote>
<ul>
<li>计算机网络(谢希仁版)</li>
</ul>
<blockquote>
<p>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。</p>
</blockquote>
<hr>
<h3 id="计算机系统与运行"><a href="#计算机系统与运行" class="headerlink" title="计算机系统与运行"></a>计算机系统与运行</h3><p>学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。</p>
<h5 id="公开课程"><a href="#公开课程" class="headerlink" title="公开课程:"></a>公开课程:</h5><ul>
<li><strong>卡内基梅隆大学 CSAPP 配套课程  （B站有）</strong></li>
<li>卡内基梅隆大学 CMU 15-213</li>
<li>加州大学伯克利大学 CS61C</li>
<li>斯坦福大学 CS107 </li>
</ul>
<h5 id="书籍推荐：-5"><a href="#书籍推荐：-5" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul>
<li>深入理解计算机系统 CSAPP </li>
</ul>
<blockquote>
<p>计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。</p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>知乎文章《计算机名校路线课程》</li>
<li>网易云课堂  顶尖大学中文计算机课程</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/11/Markdown%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/11/Markdown%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Markdown使用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-11 10:31:39 / 修改时间：21:26:53" itemprop="dateCreated datePublished" datetime="2021-04-11T10:31:39+08:00">2021-04-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">软件文档</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Markdown使用-指南"><a href="#Markdown使用-指南" class="headerlink" title="Markdown使用 指南"></a><strong>Markdown使用 指南</strong></h1><hr>
<h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><hr>
<h3 id="使用-标记多级标题"><a href="#使用-标记多级标题" class="headerlink" title="使用#标记多级标题"></a>使用#标记多级标题</h3><blockquote>
<p>一级标题用#号来标记</p>
<p>二级标题用##号来标记</p>
<p>….. 依次类推</p>
</blockquote>
<h3 id="使用-和-标记一级和二级标题（部分支持）"><a href="#使用-和-标记一级和二级标题（部分支持）" class="headerlink" title="使用=和-标记一级和二级标题（部分支持）"></a>使用=和-标记一级和二级标题（部分支持）</h3><blockquote>
<p>一级标题用=======来标注</p>
<p>二级标题用————来标注</p>
</blockquote>
<hr>
<h2 id="Markdown段落格式"><a href="#Markdown段落格式" class="headerlink" title="Markdown段落格式"></a>Markdown段落格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p><em>斜体</em>   * *</p>
<p><strong>粗体</strong>  ** **</p>
<p><em><strong>斜粗体</strong></em>   * * *  * * *</p>
</blockquote>
<h3 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h3><blockquote>
<p>分割线 *********</p>
<p><del>删除线</del>  ~~ ~~</p>
<p><u>下划线</u>  <u> </u></p>
<p>脚注  <a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8">^脚注</a></p>
</blockquote>
<hr>
<h2 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h2><ul>
<li><p>第一项</p>
<ul>
<li><p>第一个元素</p>
<ul>
<li>第二个元素</li>
</ul>
</li>
</ul>
</li>
<li><p>第二项</p>
<ul>
<li>第一个元素</li>
<li>第二个元素 </li>
</ul>
</li>
</ul>
<hr>
<h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><h3 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h3><blockquote>
<p>区块引用符 &gt;</p>
<blockquote>
<p>第一层嵌套 &gt;&gt;</p>
</blockquote>
<blockquote>
<blockquote>
<p>第二层嵌套 &gt;&gt;&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><blockquote>
<ul>
<li>第一项<ul>
<li>1.1</li>
<li>1.2</li>
</ul>
</li>
<li>第二项<ul>
<li>2.1</li>
<li>2.2</li>
</ul>
</li>
<li>第三项</li>
</ul>
</blockquote>
<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><ul>
<li><p>第一项</p>
<blockquote>
<p>学技术不仅是技术，而是梦想</p>
</blockquote>
</li>
<li><p>第二项 </p>
<blockquote>
<p>我们的目标是星辰大海。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><h3 id="单个片段代码"><a href="#单个片段代码" class="headerlink" title="单个片段代码"></a>单个片段代码</h3><blockquote>
<p><code>printf()</code>函数</p>
</blockquote>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码块使用三个反引号建立，以下是部分语言的实例代码：</p>
<blockquote>
<p><strong>Python实例</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Javascript实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;RUNO&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>PHP实例</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>链接使用<a target="_blank" rel="noopener" href="http://www.baidu.com/">链接名称</a>建立，格式为<a href=""></a> ，也可以用变量设置来建立一个链接，赋值在文档末尾进行</p>
<blockquote>
<p>这个链接用 1 作为网址变量 [Google][1]</p>
</blockquote>
<hr>
<h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><h3 id="通过markdown语法插入图片"><a href="#通过markdown语法插入图片" class="headerlink" title="通过markdown语法插入图片"></a>通过markdown语法插入图片</h3><p>Markdown 插入图片的语法格式如下：</p>
<blockquote>
<p><img src="" alt="属性文本"></p>
</blockquote>
<h3 id="通过Typora直接插入图片-编辑器必须是Typora编辑器"><a href="#通过Typora直接插入图片-编辑器必须是Typora编辑器" class="headerlink" title="通过Typora直接插入图片 (编辑器必须是Typora编辑器)"></a>通过Typora直接插入图片 (编辑器必须是Typora编辑器)</h3><blockquote>
<p>格式–&gt;图像–&gt;插入图片</p>
</blockquote>
<hr>
<h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown表格格式如下：</p>
<blockquote>
<p>| |为分割单元格，-表示长度，：：为中央对齐</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据统计表</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文字</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">图标</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">0</td>
</tr>
</tbody></table>
<hr>
<h2 id="Markdown-拓展技巧"><a href="#Markdown-拓展技巧" class="headerlink" title="Markdown 拓展技巧"></a>Markdown 拓展技巧</h2><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的HTML元素有：</p>
<blockquote>
<p>&lt;kbd&gt;元素：使用<kbd>Shift</kbd> +<kbd>W</kbd> 执行操作</p>
<p>&lt;b&gt;元素：<b>123</b>    </p>
<p>&lt;i&gt;元素：<i>admin</i></p>
<p>&lt;em&gt;元素：<em>admin</em></p>
<p>&lt;sup&gt;元素：A<sup>1</sup></p>
<p>&lt;br&gt; 元素：换行</p>
</blockquote>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字，Markdown 使用反斜杠转义特殊字符：</p>
<blockquote>
<p>\ * \ * 转义文本加粗</p>
</blockquote>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如输入：</p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$&#123;$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>会显示如下公式：</p>
<p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p>1.菜鸟教程 <u><a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></u></p>
<p>2.知乎专栏 <u><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67153848">https://zhuanlan.zhihu.com/p/67153848</a></u></p>
<p>[1] : <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/10/%E4%B8%96%E7%95%8C%E5%BE%88%E5%A4%A7%EF%BC%8C%E4%BA%BA%E5%BF%83%E5%BE%88%E5%B0%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="Donnie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Donnie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E4%B8%96%E7%95%8C%E5%BE%88%E5%A4%A7%EF%BC%8C%E4%BA%BA%E5%BF%83%E5%BE%88%E5%B0%8F/" class="post-title-link" itemprop="url">世界很大，人心很小</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-10 08:42:43 / 修改时间：08:43:43" itemprop="dateCreated datePublished" datetime="2021-04-10T08:42:43+08:00">2021-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B2%89%E6%80%9D%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">沉思录</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Donnie"
      src="/images/ava.png">
  <p class="site-author-name" itemprop="name">Donnie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rigelJ" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rigelJ" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/rigelhunting@gmail.com" title="E-Mail → rigelhunting@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Donnie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">35k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">32 分钟</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

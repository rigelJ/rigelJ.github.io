<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Donnie&#39;s Blog</title>
  
  <subtitle>少年才背剑，转眼便江湖</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-09T07:42:49.919Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Donnie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS61A-对象抽象</title>
    <link href="http://example.com/2021/08/08/CS61A-%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1/"/>
    <id>http://example.com/2021/08/08/CS61A-%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1/</id>
    <published>2021-08-08T07:56:30.000Z</published>
    <updated>2021-08-09T07:42:49.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS61A-对象抽象"><a href="#CS61A-对象抽象" class="headerlink" title="CS61A 对象抽象"></a>CS61A 对象抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><p>面向对象编程（OOP）</p><ul><li>对象和类</li><li>类属性与实例属性</li><li>消息传递与点表达式</li><li>类方法</li></ul><p>继承与方法</p><ul><li>继承与方法重写</li><li>多重继承</li><li>特殊方法</li></ul><p>递归对象的实现</p><ul><li>链表类</li><li>树类</li></ul></blockquote><p>在课程的第一章当中我们提到了使用函数进行抽象，这种方式可以很好的对数据进行处理，然而仅仅只考虑函数式编程往往会产生很多问题，举个例子，假设一家银行仅仅使用变量和函数来对人员的账户进行管理，他们使用xx_money ,xx_name来进行人员账户的登记，利用<code>transfrom()</code>函数进行转账操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tom_money = <span class="number">100</span></span><br><span class="line">Bob_money = <span class="number">200</span></span><br><span class="line">Jef_money = <span class="number">400</span></span><br><span class="line">David_money = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">from_account,to_account,number</span>):</span></span><br><span class="line">    from_account -= number</span><br><span class="line">    to_account +- number</span><br></pre></td></tr></table></figure><p>突然有一天，银行的i系统在调试过程中被某个程序员整崩溃了，重新找回数据的时候变成了这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">￥&amp;×.money = <span class="number">100</span></span><br><span class="line">%^&amp;.money = <span class="number">200</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>银行傻眼了，这下怎么区分金额属于谁啊，他们只能重新寻找曾经顾客注册登记用的纸质材料，费了好大的功夫才好不容易将数据恢复了回去，经过这次事件，银行的工作人员开始思考，是不是应该换一种方式对数据进行记录，经过长时间的研究讨论，他们决定使用面向对象的编程方式重新组织和记录数据，从此以后，再也没有出现过类似的事情。</p><p>面向对象OOP，究竟强大在何处？</p><p>接下来我们将对OOP进行深入分析，为大家揭开这个谜底。</p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h4><p>上面我们讲到，利用面向对象的思考方式，我们可以解决银行账户的问题，那么为什么呢？原因就在于，之前银行储存数据时，没有考虑到数据与数据之间的关联性，仅仅只采用了很弱的关系，统一变量名来进行关联，而利用面向对象的思考方式，是将一个账户看做一个对象，每一个变量都是其对象的对象属性。</p><p>什么是对象？对象就是具有同一特征的一类元素，比如，一个人就是一个对象，每个人都有鼻子眼睛嘴巴，而且都能行走和思考，这些具有的同一特征就被称作一个类，类就好像上帝在造人的时候使用的模板。再比如一支笔，无论他是钢笔还是水笔，毛笔，都具有写字这个功能，因此同属于笔这个类，而每一支笔都是一个独立的对象。</p><p>下面我们通过一个例子来具体讲解类和对象，Lab8的这个例子很好，我就直接借用了。</p><p>Tiffany 迟到了，需要在讲座开始前从旧金山赶到伯克利。她会乘坐 BART，但这会花费太长时间。要是有车就好了 一辆巨型卡车会是最好的。</p><p>我们要为Tiffany造一辆汽车，我们首先要创建一个汽车类，用户定义的类是由class语句创建的，它由单个子句组成。class 语句定义类名称，然后包含一组语句来定义类的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">car</span>：</span></span><br></pre></td></tr></table></figure><p>接下来我们要对这个类增加一些属性，一辆车有哪些属性呢？品牌，型号，颜色，轮子数，汽油量，那么我们要对这个类附加属性，类的构造函数是一个函数，它创建类所概述的对象的实例或单个实例。在 Python 中，构造函数方法名为init，在Car类的构造函数如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">car</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model</span>):</span></span><br><span class="line">    self.make = make</span><br><span class="line">    self.model = model</span><br><span class="line">    self.color = <span class="string">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class="line">    self.wheels = Car.num_wheels</span><br><span class="line">    self.gas = Car.gas</span><br></pre></td></tr></table></figure><p>该<strong>init</strong>有三个参数。第一个参数self，自动绑定到新创建的Car对象。第二个和第三个参数make和model绑定到传递给构造函数的参数，这意味着当我们创建一个Car对象时，我们必须提供两个参数。</p><p>于是，汽车这个类我们就构造完毕了，让我们开始造我们的车。蒂芙尼想开一辆特斯拉 Model S 去上课。所以我们可以构造一个厂家为“Tesla”，型号为“Model S”的汽车实例，Python 允许我们通过类的名称来创建类的实例，而不是显式调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car = Car(<span class="string">&#x27;Tesla&#x27;</span>, <span class="string">&#x27;Model S&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这里，’Tesla’作为 make传入，“Model S”作为model传入， 请注意，我们没有传递参数self，因为它的值始终是正在创建的对象，一个对象是类的一个实例。在这种情况下， tiffanys_car现在绑定到一个Car对象，或者换句话说，绑定到Car类的一个实例。</p><p>这样，我们就创建了一个Car类，并且通过Car类创建了一个tiffanys_car的实例对象。</p><h4 id="实例属性与类属性"><a href="#实例属性与类属性" class="headerlink" title="实例属性与类属性"></a>实例属性与类属性</h4><p>我们继续来看我们上面创建的Car类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    num_wheels = <span class="number">4</span></span><br><span class="line">    gas = <span class="number">30</span></span><br><span class="line">    headlights = <span class="number">2</span></span><br><span class="line">    size = <span class="string">&#x27;Tiny&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model</span>):</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = <span class="string">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class="line">        self.wheels = Car.num_wheels</span><br><span class="line">        self.gas = Car.gas</span><br></pre></td></tr></table></figure><p>我们会发现，诶，除了我们刚刚利用构造函数所创建的属性，上面怎么还多了几行？</p><p>这里就涉及到实例属性和类属性两个概念了，什么是类属性？类属性就是同属于一个类的对象所共有的属性 ，比如，只要是汽车，肯定都是四个轮子，两个头灯，一个后备箱，这些是所有汽车共有的属性，所以被称作类属性。而不同的汽车有不同的型号，品牌，颜色和汽油量，因此这些属性就被称作实例属性。每创建一个实例对象，都会自动将类属性附加给该实例。</p><h4 id="消息传递与点表达式"><a href="#消息传递与点表达式" class="headerlink" title="消息传递与点表达式"></a>消息传递与点表达式</h4><p>上面，我们为tiffany造了一辆车，但如果有一天，tiffany说，我不想开Tesla了，我想换辆Benz开开，那该怎么办呢？我们当然可以重新利用Car类创造一个新的实例对象，但这太麻烦了，有没有什么办法可以对已有的车辆属性进行改变呢？</p><p>有的，利用点符号就可以。</p><p>例如，我们可以访问Car类的类属性size</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Car.size</span><br><span class="line"><span class="string">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure><p>同样也可以对Car类的属性进行改变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Car.size = <span class="string">&#x27;Big&#x27;</span></span><br><span class="line"><span class="string">&#x27;Tiny&#x27;</span></span><br></pre></td></tr></table></figure><p>对实例属性的改变也是同样如此，在以下行中，我们访问tiffanys_car的make属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; tiffanys_car.make </span><br><span class="line"><span class="string">&#x27;Tesla&#x27;</span></span><br></pre></td></tr></table></figure><p>而后我们将make属性修改为‘Benz’:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car.make = <span class="string">&#x27;Benz&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，我们就成功改造了tiffany的车子，是不是很简单呢？</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>让我们再为Car类增加一些东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    num_wheels = <span class="number">4</span></span><br><span class="line">    gas = <span class="number">30</span></span><br><span class="line">    headlights = <span class="number">2</span></span><br><span class="line">    size = <span class="string">&#x27;Tiny&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model</span>):</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.color = <span class="string">&#x27;No color yet. You need to paint me.&#x27;</span></span><br><span class="line">        self.wheels = Car.num_wheels</span><br><span class="line">        self.gas = Car.gas</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">self, color</span>):</span></span><br><span class="line">        self.color = color</span><br><span class="line">        <span class="keyword">return</span> self.make + <span class="string">&#x27; &#x27;</span> + self.model + <span class="string">&#x27; is now &#x27;</span> + color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drive</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.wheels &lt; Car.num_wheels <span class="keyword">or</span> self.gas &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Cannot drive!&#x27;</span></span><br><span class="line">        self.gas -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> self.make + <span class="string">&#x27; &#x27;</span> + self.model + <span class="string">&#x27; goes vroom!&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_tire</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.wheels &gt; <span class="number">0</span>:</span><br><span class="line">            self.wheels -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.gas += <span class="number">20</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Gas level: &#x27;</span> + <span class="built_in">str</span>(self.gas)</span><br></pre></td></tr></table></figure><p>这些def叫做类的方法，他们可以调用类的属性，并且输出给外界。方法是特定于类的函数，只有类的一个实例可以使用它们，那么，我们如何在实例上调用方法？你猜对了，点符号！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car.paint(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Tesla Model S is now black&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tiffanys_car.color</span><br><span class="line"><span class="string">&#x27;black&#x27;</span></span><br></pre></td></tr></table></figure><p>上面是一个调用paint方法的过程，我们仔细看一下这个方法，它需要两个参数，那么为什么我们不需要传递两个参数呢？就好像我们在init构造函数中看到的那样，一个类的所有方法都有一个self参数，python会自动将调用该方法的实例绑定到该参数，在这里，self绑定到tiffanys_car这个实例，并调用paint函数改变实例属性</p><p>您还可以使用类名和点符号来调用方法；例如，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Car.paint(tiffanys_car, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Tesla Model S is now red&#x27;</span></span><br></pre></td></tr></table></figure><p>请注意，与我们将 Tiffany 的汽车漆成黑色不同，这次我们必须传入两个参数：一个 self和一个 color。这是因为当您使用点表示法从实例调用方法时，Python 知道要自动绑定到哪个实例self。但是，当您使用类中的点表示法调用方法时，Python 不知道Car我们要绘制哪个实例 ，因此我们也要将实例作为参数传入。</p><h3 id="继承与方法重写"><a href="#继承与方法重写" class="headerlink" title="继承与方法重写"></a>继承与方法重写</h3><p>61A讲继承的时候举了一个很有意思的例子，大家小时候都玩过宝可梦吧，让我们来创建一个宝可梦的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span>:</span></span><br><span class="line">    basic_attack = <span class="string">&#x27;tackle&#x27;</span></span><br><span class="line">    damage = <span class="number">40</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, trainer</span>):</span></span><br><span class="line">        self.name, self.trainer = name, trainer</span><br><span class="line">        self.level, self.hp = <span class="number">1</span>, <span class="number">50</span></span><br><span class="line">        self.paralyzed = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.paralyzed:</span><br><span class="line">            self.speak()</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&#x27;used&#x27;</span>, self.basic_attack, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">            other.receive_damage(self.damage)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_damage</span>(<span class="params">self, damage</span>):</span></span><br><span class="line">        self.hp = <span class="built_in">max</span>(<span class="number">0</span>, self.hp - damage)</span><br><span class="line">        <span class="keyword">if</span> self.hp == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure><p>噢我们可以看见，一个宝可梦类有类属性damage，basic_attack，有实例属性name，level，paralyzed，还有一些类方法。</p><p>现在我们再来创建一个电属性的宝可梦类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricType</span>:</span></span><br><span class="line">    basic_attack = <span class="string">&#x27;thunder shock&#x27;</span></span><br><span class="line">    damage = <span class="number">40</span></span><br><span class="line">    prob = <span class="number">0.1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, trainer</span>):</span></span><br><span class="line">          self.name, self.trainer = name, trainer</span><br><span class="line">          self.level, self.hp = <span class="number">1</span>, <span class="number">50</span></span><br><span class="line">          self.paralyzed = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        self.speak()</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;used&#x27;</span>, self.basic_attack, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        other.receive_damage(self.damage)</span><br><span class="line">        <span class="keyword">if</span> random() &lt; self.prob <span class="keyword">and</span> <span class="built_in">type</span>(other) != ElectricType:</span><br><span class="line">            other.paralyzed = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(other.name, <span class="string">&#x27;is paralyzed!&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_damage</span>(<span class="params">self, damage</span>):</span></span><br><span class="line">        self.hp = <span class="built_in">max</span>(<span class="number">0</span>, self.hp - damage)</span><br><span class="line">        <span class="keyword">if</span> self.hp == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&#x27;fainted!&#x27;</span>)   </span><br></pre></td></tr></table></figure><p>有些人会说好麻烦，为什么不直接在原来的基础上修改，说的好，这就是继承的概念，我们会发现电属性宝可梦类和宝可梦类只有</p><p>类属性部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prob &#x3D; 0.1</span><br></pre></td></tr></table></figure><p>attack方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        self.speak()</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;used&#x27;</span>, self.basic_attack, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        other.receive_damage(self.damage)</span><br><span class="line">        <span class="keyword">if</span> random() &lt; self.prob <span class="keyword">and</span> <span class="built_in">type</span>(other) != ElectricType:</span><br><span class="line">            other.paralyzed = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(other.name, <span class="string">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这两个模块是不同的，其他都是相同的，所以我们可以这样来写电属性宝可梦类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricType</span>(<span class="params">Pokemon</span>):</span></span><br><span class="line">    basic_attack = <span class="string">&#x27;thunder shock&#x27;</span></span><br><span class="line">    prob = <span class="number">0.1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        Pokemon.attack(self, other)</span><br><span class="line">        <span class="keyword">if</span> random() &lt; self.prob <span class="keyword">and</span> <span class="built_in">type</span>(other) != ElectricType:</span><br><span class="line">            other.paralyzed = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(other.name, <span class="string">&#x27;is paralyzed!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里的<code>class &lt;Class Name&gt;(&lt;Superclass Name&gt;):</code>结构就是继承，通过继承，我们可以在新创建的类中保留下原有的类属性和实例属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pica = ElectricType(<span class="string">&#x27;pica&#x27;</span>,<span class="string">&#x27;me&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pica.hp</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>可以看得出，新类所创建的实例拥有和被继承类相同的实例属性。</p><p>我们还可以看到，attack方法被重写了，原来attack的方法被覆盖了，这种情况叫做方法重写，新类可以创建与被继承类相同名称的方法，将会覆盖原有方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;Pica.attack(Yib)</span><br><span class="line"><span class="string">&#x27;Yib is paralyzed!&#x27;</span></span><br></pre></td></tr></table></figure><p>这时候有人会问，那如果需要增加或删除实例属性项，是不是要重写一遍构造函数？</p><p>当然，重写固然没有问题，但是还有更简便的方法。</p><p>我们举一个61A Project ant的例子</p><p>假设我们有一个昆虫类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;An Insect, the base class of Ant and Bee, has armor and a Place.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    is_ant = <span class="literal">False</span></span><br><span class="line">    damage = <span class="number">0</span></span><br><span class="line">    is_watersafe = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, armor, place=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create an Insect with an ARMOR amount and a starting PLACE.&quot;&quot;&quot;</span></span><br><span class="line">        self.armor = armor</span><br><span class="line">        self.armor = armor</span><br><span class="line">        self.place = place  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reduce_armor</span>(<span class="params">self, amount</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Reduce armor by AMOUNT, and remove the insect from its place if it</span></span><br><span class="line"><span class="string">        has no armor remaining.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; test_insect = Insect(5)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; test_insect.reduce_armor(2)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; test_insect.armor</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.armor -= amount</span><br><span class="line">        <span class="keyword">if</span> self.armor &lt;= <span class="number">0</span>:</span><br><span class="line">            self.place.remove_insect(self)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们要创建一个新的Ant类，这个Ant类是Insert类的一个子类，它继承了Insert类的一些方法和属性，不同的是，我们要修改一下Ant类当中amor属性的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ant</span>(<span class="params">Insect</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;An Ant occupies a place and does work for the colony.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    is_ant = <span class="literal">True</span></span><br><span class="line">    implemented = <span class="literal">False</span>  <span class="comment"># Only implemented Ant classes should be instantiated</span></span><br><span class="line">    food_cost = <span class="number">0</span></span><br><span class="line">    blocks_path = <span class="literal">True</span></span><br><span class="line">    is_container = <span class="literal">False</span></span><br><span class="line">    is_double = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># ADD CLASS ATTRIBUTES HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, armor=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create an Ant with an ARMOR quantity.&quot;&quot;&quot;</span></span><br><span class="line">        Insect.__init__(self, armor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_contain</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们使用了<code>Insert.__init__(self,armor=1)</code>来修改父类的构造函数</p><p>我们再以Ant为父类，创建一个名为HungryAnt的子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungryAnt</span>(<span class="params">Ant</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;HungryAnt will take three turns to digest a Bee in its place.</span></span><br><span class="line"><span class="string">    While digesting, the HungryAnt can&#x27;t eat another Bee.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = <span class="string">&#x27;Hungry&#x27;</span></span><br><span class="line">    food_cost = <span class="number">4</span></span><br><span class="line">    time_to_digest = <span class="number">3</span></span><br><span class="line">    <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">    implemented = <span class="literal">True</span>  <span class="comment"># Change to True to view in the GUI</span></span><br><span class="line">    <span class="comment"># END Problem 6</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, armor=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">        Ant.__init__(self, armor)</span><br><span class="line">        self.digesting = <span class="number">0</span></span><br><span class="line">        <span class="comment"># END Problem 6</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat_bee</span>(<span class="params">self, bee</span>):</span></span><br><span class="line">        <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">        bee.armor = <span class="number">0</span></span><br><span class="line">        self.place.remove_insect(bee)</span><br><span class="line">        self.digesting = self.time_to_digest</span><br><span class="line">        <span class="comment"># END Problem 6</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self, colony</span>):</span></span><br><span class="line">        <span class="comment"># BEGIN Problem 6</span></span><br><span class="line">        <span class="keyword">if</span> self.digesting == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> random_or_none(self.place.bees) !=<span class="literal">None</span>:</span><br><span class="line">                self.eat_bee(random_or_none(self.place.bees))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.digesting -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># END Problem 6</span></span><br></pre></td></tr></table></figure><p>我们看到，这里我们使用<code>Insert.__init__(self,armor)</code>继承了父类的所有实例属性，并且在这基础上又增加了一个digesting属性作为该类独有的实例属性。</p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>多重继承顾名思义，就是从多个父类继承的子类，比如，作为你父母的孩子，你既继承了你父亲的身高智慧，又继承了你母亲的高鼻梁大眼睛，因此在你这个类当中，既有父亲传给你的属性，又有母亲传给你的属性。</p><p>Python 支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。</p><p>恩，突然一下子想不出什么特别好的例子，大家可以在CS61A的一些习题当中找一些例子来看。</p><h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><p>在 Python 中，某些特殊名称会在特殊情况下由 Python 解释器调用。例如，每当构造对象时，都会自动调用类的<strong>init</strong>方法。每当打印对象时会自动调用<strong>str</strong>方法，在交互式会话到显示值会调用repr方法。</p><p>假设我们有一个类A</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,number</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.number = number</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span> + self.name + <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><p>那么我们在打印A类所构造的实例对象时，就会自动调用<strong>str</strong>函数打印，交互式对话输入自动调用repr</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="string">&#x27;alien&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">&lt;alien&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">alien</span><br></pre></td></tr></table></figure><p>我们用Link对象举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A linked list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Link(1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.first</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest is Link.empty</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.first = 5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest.first = 6</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest.rest = Link.empty</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)</span></span><br><span class="line"><span class="string">    Link(5, Link(6))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Link(5, Link(7, Link(Link(8, Link(9)))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(s)                             # Prints str(s)</span></span><br><span class="line"><span class="string">    &lt;5 7 &lt;8 9&gt;&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    empty = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, first, rest=empty</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">        self.first = first</span><br><span class="line">        self.rest = rest</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            rest_repr = <span class="string">&#x27;, &#x27;</span> + <span class="built_in">repr</span>(self.rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest_repr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#x27;</span> + <span class="built_in">repr</span>(self.first) + rest_repr + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        string = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            string += <span class="built_in">str</span>(self.first) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">            self = self.rest</span><br><span class="line">        <span class="keyword">return</span> string + <span class="built_in">str</span>(self.first) + <span class="string">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>虽然我们还没有讲到链表类，但是我们可以看到，Link类也重写了str和repr方法，因此Link类实现 方法的实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s = Link(<span class="number">2</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>)))</span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>)))</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(s)</span><br><span class="line">&lt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><p>除了最基本的str和repr特殊方法之外，python也支持对其他特殊方法进行修改，我们这里以contain特殊方法为例进行介绍,contain特殊方会在对实例使用in指令时自动调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.first == x：</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> self.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">in</span> self.rest</span><br></pre></td></tr></table></figure><p>这样我们就改写了contain特殊方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;l=Link(<span class="number">1</span>,Link(<span class="number">2</span>,Link(<span class="number">3</span>)))</span><br><span class="line">&gt;&gt;&gt;<span class="number">2</span> <span class="keyword">in</span> l</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">4</span> <span class="keyword">in</span> l</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>下面是一些常见的特殊方法，大家可以对其进行改写试一试。</p><p><img src="https://i.loli.net/2021/08/09/eG2QDp4y7vlIH9a.png" alt="image-20210809105526287"></p><h3 id="递归对象的实现"><a href="#递归对象的实现" class="headerlink" title="递归对象的实现"></a>递归对象的实现</h3><p>对象可以有其他对象作为属性值。当某个类的对象具有同一个类的属性值时，它就是递归对象。</p><p>常见的递归对象有链表类和树类两种</p><h4 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h4><p>本章前面已经提前给出Link类的概念，我们再次回顾一下，链表由第一个元素和列表的其余部分组成，链表的其余部分只能是一个链表，链表是一个序列，它的长度是有限的，并且支持按索引选择元素。</p><p>我们可以实现一个Link类，表示一个链表对象。每个Link实例都有两个实例属性，first和rest。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">    empty = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, first, rest=empty</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">        self.first = first</span><br><span class="line">        self.rest = rest</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            rest_repr = <span class="string">&#x27;, &#x27;</span> + <span class="built_in">repr</span>(self.rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest_repr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#x27;</span> + <span class="built_in">repr</span>(self.first) + rest_repr + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        string = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self.rest <span class="keyword">is</span> <span class="keyword">not</span> Link.empty:</span><br><span class="line">            string += <span class="built_in">str</span>(self.first) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">            self = self.rest</span><br><span class="line">        <span class="keyword">return</span> string + <span class="built_in">str</span>(self.first) + <span class="string">&#x27;&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们可以看出，链表第一个元素没有限制，但是第二个元素只能是一个链表或空链表，由于每个链表的第二个元素都是链表，所以链表是一个递归对象</p><p>让我们通过一个例子来进一步加深印象，这道题是61A的题目。</p><blockquote><p>编写一个函数store_digits，接收一个整数n并返回一个链表，其中链表的每个元素都是 的一个数字n。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store_digits</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Stores the digits of a positive number n in a linked list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = store_digits(1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">    Link(1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; store_digits(2345)</span></span><br><span class="line"><span class="string">    Link(2, Link(3, Link(4, Link(5))))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; store_digits(876)</span></span><br><span class="line"><span class="string">    Link(8, Link(7, Link(6)))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># In iteration</span></span><br><span class="line">    new_link = Link.empty</span><br><span class="line">    <span class="keyword">while</span> n !=<span class="number">0</span>:</span><br><span class="line">        new_link = Link(n%<span class="number">10</span>,new_link)</span><br><span class="line">        n = n//<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> new_link</span><br></pre></td></tr></table></figure><p>这道题目就利用了Link递归的特性，通过递归过程对不断加长拓展链表，最终构成一个单一数字的链表。</p><h4 id="树类"><a href="#树类" class="headerlink" title="树类"></a>树类</h4><p>回想一下，树是一种递归抽象数据类型，它具有label（存储在树根中的值）和branches（根正下方的树列表）两种不同类型的值，在数据抽象一章中，我们曾经使用将树视为列表的构造函数和选择器函数实现过树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tree ADT</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span>(<span class="params">label, branches=[]</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">label</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">branches</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_tree</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leaf</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span><br><span class="line"><span class="string">    otherwise.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">t, indent=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span><br><span class="line"><span class="string">    indented by two spaces times its depth from the root.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(tree(1))</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(numbers)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">        7</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;  &#x27;</span> * indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_tree</span>(<span class="params">t</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a copy of t. Only for testing purposes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(5)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; copy = copy_tree(t)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(6)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(copy)</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> tree(label(t), [copy_tree(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><p>但是我们会发现使用这种方式创建的树是不可更改的，因为我们无法为调用表达式赋值，为了能够实现对树的修改，我们将构造器的功能用树类实现，而将选择器的功能用访问实例属性的点表达式实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t.label</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t.branches[0].label</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t.branches[1].is_leaf()</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, label, branches=[]</span>):</span></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches:</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, Tree)</span><br><span class="line">        self.label = label</span><br><span class="line">        self.branches = <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_leaf</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.branches</span><br></pre></td></tr></table></figure><p>这样一来，我们就可以方便的创建树对象和修改树对象的label和branches属性，而不需要通过调用函数来获得树对象的各项属性，同时我们还可以在树类中任意增加各种方法，同样也只需要对实例进行方法调用即可。</p><p>此外，使用构造选择函数和列表实现的树ADT与使用类与对象实现的树ADT还有如下的区别</p><p><img src="https://i.loli.net/2021/08/09/q6QKxZFmIGuWihL.png" alt="image-20210809154119551"></p><p>总的来说，利用类实现的树ADT具有可变的特点，因此使用起来要比函数式的ADT更加便捷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CS61A-对象抽象&quot;&gt;&lt;a href=&quot;#CS61A-对象抽象&quot; class=&quot;headerlink&quot; title=&quot;CS61A 对象抽象&quot;&gt;&lt;/a&gt;CS61A 对象抽象&lt;/h2&gt;&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CS61A" scheme="http://example.com/categories/CS61A/"/>
    
    
    <category term="程序结构" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    <category term="CS61" scheme="http://example.com/tags/CS61/"/>
    
    <category term="CS61A" scheme="http://example.com/tags/CS61A/"/>
    
  </entry>
  
  <entry>
    <title>CS61A-元语言抽象</title>
    <link href="http://example.com/2021/08/08/CS61A-%E5%85%83%E8%AF%AD%E8%A8%80%E6%8A%BD%E8%B1%A1/"/>
    <id>http://example.com/2021/08/08/CS61A-%E5%85%83%E8%AF%AD%E8%A8%80%E6%8A%BD%E8%B1%A1/</id>
    <published>2021-08-08T07:56:30.000Z</published>
    <updated>2021-08-10T04:31:00.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS61A-元语言抽象"><a href="#CS61A-元语言抽象" class="headerlink" title="CS61A 元语言抽象"></a>CS61A 元语言抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><p>Scheme语言</p><ul><li>表达式</li><li>控制结构与列表</li><li>定义变量与函数</li><li>匿名过程</li></ul><p>Scheme语言特性</p><ul><li>宏</li><li>流</li></ul><p>抽象语言的解释器</p><ul><li>解释器的实现</li><li>读取过程</li><li>评估过程</li><li>输出过程</li></ul></blockquote><p>在之前的章节中，我们都是基于一门语言去研究程序的抽象形式，而本 书的最后一个部分直接跳出了语言，讲解一门语言是怎么样抽象的，也就是说，这一章，是在教你如何实现一门语言，我们这里所说的语言是脚本语言，接下来，我们就要以Scheme语言为例，讲解Scheme语言是怎么样一步一步构造出来的。</p><h3 id="Scheme语言"><a href="#Scheme语言" class="headerlink" title="Scheme语言"></a>Scheme语言</h3><p>首先我们从使用者的角度了解一下Scheme的语法。</p><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>最基础的表达式可以是数字，布尔值或者符号，这里的符号是我们在Python语言中唯一没有遇到的类型，具体来说，Scheme中的符号也是一种值。</p><h5 id="原子表达式"><a href="#原子表达式" class="headerlink" title="原子表达式"></a>原子表达式</h5><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; 1234    ; integer</span><br><span class="line"><span class="number">1234</span></span><br><span class="line">scm&gt; 123.4   ; real number</span><br><span class="line"><span class="number">123.4</span></span><br></pre></td></tr></table></figure><h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; #t</span><br><span class="line">#t</span><br><span class="line">scm&gt; #f</span><br><span class="line">#f</span><br></pre></td></tr></table></figure><p>在 Scheme 中，除了特殊的布尔值#f之外的所有值都被解释为真值（与 Python 不同，Python 中有一些像0那样的假值）</p><h5 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h5><p>其中，符号类型是我们在 Python 中唯一没有遇到的类型。一个 符号的作用很像一个Python的名字，但不完全是。具体来说，Scheme 中的符号也是一种值。在 Python 中，名称仅用作表达式；Python 表达式永远不能计算为名称。</p><p>这个过程具体是怎么实现的，我们后面再讲。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; quotient      ; A name bound to a built-in procedure</span><br><span class="line">#[quotient]</span><br><span class="line">scm&gt; &#x27;quotient     ; An expression that evaluates to a symbol</span><br><span class="line">quotient</span><br><span class="line">scm&gt; &#x27;hello-world!</span><br><span class="line">hello-world!</span><br></pre></td></tr></table></figure><h4 id="调用表达式"><a href="#调用表达式" class="headerlink" title="调用表达式"></a>调用表达式</h4><p>与 Python 一样，Scheme 调用表达式中的运算符位于所有操作数之前。与 Python 不同的是，运算符包含在括号内，并且操作数由空格而不是逗号分隔。然而，Scheme 调用表达式的计算遵循与 Python 完全相同的规则：</p><p>1.评估操作符，应该评估为一个过程</p><p>2.从左到右评估操作数</p><p>3.操作数应用于过程</p><p>以下是一些使用内置过程的示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (+ 1 2)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">scm&gt; (- 10 (/ 6 2))</span><br><span class="line"><span class="number">7</span></span><br><span class="line">scm&gt; (modulo 35 4)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">scm&gt; (even? (quotient 45 2))</span><br><span class="line">#t</span><br></pre></td></tr></table></figure><h4 id="控制结构与列表"><a href="#控制结构与列表" class="headerlink" title="控制结构与列表"></a>控制结构与列表</h4><h5 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h5><p>该if特殊形式使我们能够评估基于谓词两个表达式之一。它接受两个必需的参数和一个可选的第三个参数：</p><blockquote><p>(if <predicate> <if-true> [if-false])</p></blockquote><p>第一个操作数是Scheme 中所谓的谓词表达式，该表达式的值被解释为#tor 或#f。</p><p>计算if特殊形式表达式的规则如下：</p><p>1.评估<predicate>。<br>2.如果<predicate>评估为真值，则评估并返回该值，如果表达式<if-true>. 否则，[if-false]如果提供，则评估并返回值 。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (if (&gt; x 3)</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">         2)</span><br></pre></td></tr></table></figure><p>在 Scheme 中，您不能编写elif案例。如果要使用if表达式有多个案例，则需要多个分支if表达式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (if (&lt; x 0)</span><br><span class="line">         <span class="symbol">&#x27;negative</span></span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">             <span class="symbol">&#x27;zero</span></span><br><span class="line">             <span class="symbol">&#x27;positive</span></span><br><span class="line">         )</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><h5 id="cond表达式"><a href="#cond表达式" class="headerlink" title="cond表达式"></a>cond表达式</h5><p>使用嵌套if表达式似乎不是处理多种情况的非常实用的方法。相反，我们可以使用cond特殊形式，一种类似于 Python 中的多子句 if/elif/else 条件表达式的通用条件表达式。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">    (<span class="name">&lt;p1&gt;</span> &lt;e1&gt;)</span><br><span class="line">    (<span class="name">&lt;p2&gt;</span> &lt;e2&gt;)</span><br><span class="line">    ...</span><br><span class="line">    (<span class="name">&lt;pn&gt;</span> &lt;en&gt;)</span><br><span class="line">    [(<span class="name"><span class="builtin-name">else</span></span> &lt;else-expression&gt;)])</span><br></pre></td></tr></table></figure><p>评价规则如下：</p><p>1.对谓词<p1>, <p2>, …,<pn>进行求值，直到达到求值为真 y 值的谓词为止。<br>2.如果您到达一个计算结果为真值的谓词，请计算并返回子句中的相应表达式。<br>3.如果没有一个谓词是真y并且有一个else子句，则评估并返回<else-expression>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (cond</span><br><span class="line">        ((<span class="name"><span class="builtin-name">&gt;</span></span> x <span class="number">0</span>) <span class="symbol">&#x27;positive</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>) <span class="symbol">&#x27;negative</span>)</span><br><span class="line">        (else &#x27;zero))</span><br></pre></td></tr></table></figure><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><h6 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h6><p>Scheme 列表与我们在 Python 中使用的链表非常相似。就像链表是由一系列Link 对象构建的一样，Scheme 列表是由一系列对构建的，这些对是由构造函数创建的cons，是一种可递归对象。</p><p>Scheme列表要cdr是另一个列表或nil空列表。列表在解释器中显示为值序列（类似于对象的 __str__表示Link）。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (cons 1 (cons 2 (cons 3 nil)))</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>具体的实现方式用图像来表示就是</p><p><img src="https://i.loli.net/2021/08/10/Le2kpYIwaAgWN8E.png" alt="image-20210810094539083"></p><p>我们可以使用car和cdr从我们的列表中检索值，现在它的工作方式类似于 PythonLink的first和rest属性。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a</span><br><span class="line">scm&gt; a</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; (car a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">scm&gt; (cdr a)</span><br><span class="line">(<span class="name">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; (car (cdr (cdr a)))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果您没有将 pair 或 nil 作为第二个参数传递给cons，则会出错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (cons 1 2)</span><br><span class="line">Error</span><br></pre></td></tr></table></figure><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>另一种创建列表的方式是利用list，该list过程接受任意数量的参数并使用这些参数的值构造一个列表</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (list 1 2 3)</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; (list 1 (list 2 3) 4)</span><br><span class="line">(<span class="name">1</span> (<span class="name">2</span> <span class="number">3</span>) <span class="number">4</span>)</span><br><span class="line">scm&gt; (list (cons 1 (cons 2 nil)) 3 4)</span><br><span class="line">((<span class="name">1</span> <span class="number">2</span>) <span class="number">3</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>请注意，此表达式中的所有操作数在放入结果列表之前都会进行评估。</p><h6 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h6><p>我们还可以使用引用形式来创建一个列表，通过引用形式创建的列表不进评估</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; &#x27;(1 2 3)</span><br><span class="line">(<span class="name">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">scm&gt; &#x27;(cons 1 2)           ; Argument to quote is not evaluated</span><br><span class="line">(<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">scm&gt; &#x27;(1 (2 3 4))</span><br><span class="line">(<span class="name">1</span> (<span class="name">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="定义变量与函数"><a href="#定义变量与函数" class="headerlink" title="定义变量与函数"></a>定义变量与函数</h4><p>在Python中定义变量使用=号进行，而定义变量使用def进行，而在Scheme中定义变量和过程都使用define语法，这个在后期解释器的构造中我也会着重细讲。</p><p>定义变量，我们使用语法</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> &lt;name&gt; &lt;expression&gt;)</span><br></pre></td></tr></table></figure><p>评估这个表达式的规则是</p><p>1.评估<expression>.<br>2.将其值绑定到<name>当前Frame中。<br>3.返回<name>。</p><p>定义过程，我们使用语法</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">&lt;name&gt;</span> &lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt; )</span><br></pre></td></tr></table></figure><p>要评估此表达式：</p><p>1.使用给定的参数和 来创建一个 lambda 过程<body>。<br>2.将过程绑定到<name>当前帧中的 。<br>3.返回<name>。</p><p>以下两个表达式是等价的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (define foo (lambda (x y) (+ x y)))</span><br><span class="line">foo</span><br><span class="line">scm&gt; (define (foo x y) (+ x y))</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><h4 id="匿名过程"><a href="#匿名过程" class="headerlink" title="匿名过程"></a>匿名过程</h4><p>所有 Scheme 过程都是 lambda 过程。要创建 lambda 过程，我们可以使用lambda特殊形式</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (&lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn&#x27;t assign it to a name</span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (x y) (<span class="name"><span class="builtin-name">+</span></span> x y))</span><br><span class="line">scm&gt; ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>一个过程可以接受任意数量的参数。该<body>可以包含多个表达式。return Scheme 中没有 Python语句的等效版本。该函数将简单地返回正文中最后一个表达式的值。</p><h3 id="Scheme语言特性"><a href="#Scheme语言特性" class="headerlink" title="Scheme语言特性"></a>Scheme语言特性</h3><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><h5 id="Define-macro"><a href="#Define-macro" class="headerlink" title="Define-macro"></a>Define-macro</h5><p>宏是一个不好理解的概念，但是却是一个非常重要的概念，我们刚才已经介绍了define的用法，下面我们使用define来定义一个过程</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> twice(<span class="name">f</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">begin</span></span> f f))</span><br></pre></td></tr></table></figure><p>当我们输入<code>（twice （print &#39;woof））</code>我们希望能输出两次woof，然而</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (twice (print &#x27;woof))</span><br><span class="line">woof</span><br></pre></td></tr></table></figure><p>这是怎么回事呢？</p><p>我们一步一步来，首先我们对操作符twice进行评估，返回我们定义的twice过程，而后我们对<code>(print &#39;woof)</code>进行评估，打印woof，而后将返回的undefined值绑定到f，而后将操作数字应用于操作符，得到表达式<code>（begin undefined undefined）</code>对该表达式进行评估，无返回值</p><p>那么我们该怎么样修改才能得到正确输出呢？</p><p>我们想要最终评估的表达式是这样的，<code>begin （print &#39;woof）(print &#39;woof)</code> ，因此，我们想到一种办法</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">twice</span> f)</span><br><span class="line">  (<span class="name"><span class="builtin-name">eval</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">&#x27;begin</span> f f))</span><br></pre></td></tr></table></figure><p>为了保证最终评估的表达式是<code>begin （print &#39;woof）(print &#39;woof)</code> ，我们稍微改变了一下输入的值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (twice &#x27;(print &#x27;woof))</span><br><span class="line">woof</span><br><span class="line">woof</span><br></pre></td></tr></table></figure><p>这样我们就通过eval list返回的列表，完成了正确输出。</p><p>但是肯定有人会想，为什么要这么麻烦，在进入函数的时候用‘防止被eval，结果在出来的时候又得加个eval，那索性就直接让操作数不评估不就行了。</p><p>诶，没错，这个问题，前人已经考虑到了，而且他们还设计了一种语法来解决这个问题，这种语法被叫做macro，宏。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scm&gt; (define-macro (twice f) (list &#x27;begin f f))</span><br><span class="line">twice</span><br><span class="line">scm&gt; (twice (print &#x27;woof))</span><br><span class="line">woof</span><br><span class="line">woof</span><br></pre></td></tr></table></figure><p>define-macro允许我们定义macro，这是我们将未计算的输入表达式组合到另一个表达式中的一种方式。当我们调用宏时，操作数不会被评估，而是被视为 Scheme 数据。这意味着任何作为调用表达式或特殊形式表达式的操作数都被视为列表。</p><p>在我们的例子中，我们需要一个如下所示的begin 表达式</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">begin</span></span> (<span class="name">print</span> <span class="symbol">&#x27;woof</span>) (<span class="name">print</span> <span class="symbol">&#x27;woof</span>))</span><br></pre></td></tr></table></figure><p>作为 Scheme 数据，这个表达式实际上只是一个包含三个元素的列表：begin和(print ‘woof)两次，这正是(list ‘begin f f)返回的内容。现在，当我们调用 时twice，这个列表被评估为一个表达式并被(print ‘woof)评估两次。</p><p>回顾一下，宏的调用方式与常规过程类似，但评估它们的规则不同。我们通过以下方式评估了 lambda 过程：</p><blockquote><p>1.评估运算符<br>2.评估操作数<br>3.将运算符应用于操作数，评估过程的主体</p></blockquote><p>但是，评估对宏过程调用的规则是：</p><blockquote><p>1.评估运算符<br>2.将运算符应用于未计算的操作数<br>3.评估宏在调用它的框架中返回的表达式。</p></blockquote><p>这种特性使得scheme语言具有很强的扩展性，可以随意设计各种不同的语法来进行运算，举个例子，如果我们想把Scheme的定义语法用Python的风格写出来，该怎么做呢？</p><p>这时候我们就可以利用宏来实现。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">def</span> func bindings body)</span><br><span class="line">    (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">&#x27;define</span> (<span class="name"><span class="builtin-name">cons</span></span> func bindings) body))</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scm&lt; (def f(x y) (+ x y))</span><br><span class="line">f</span><br></pre></td></tr></table></figure><p>这样我们就可以使用具有Python风格的语法来定义scheme函数了。</p><h5 id="Quasiquote"><a href="#Quasiquote" class="headerlink" title="Quasiquote"></a>Quasiquote</h5><p>回想一下，quote特殊形式会阻止 Scheme 解释器执行表达式,如果我们试图构建具有许多嵌套列表的复杂 Scheme 表达式，这种形式似乎会派上用场。</p><p>考虑我们将twice宏重写如下</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">twice</span> f)</span><br><span class="line">  &#x27;(begin f f))</span><br></pre></td></tr></table></figure><p>这似乎会产生相同的效果，但由于quote 表单阻止了任何评估，我们创建的结果表达式实际上是<code>(begin f f)</code>，这不是我们想要的。</p><p>乍一看，quasiquote（可以用反引号`或quasiquote特殊形式调用）与quote的行为完全相同。但是，使用quasiquote可以使用逗号，从引用的上下文中删除一个表达式，对其进行评估，然后将其放回原处。</p><p>下面是我们如何使用 quasiquote 来重写我们之前的示例：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">twice</span> f)</span><br><span class="line">  `(begin ,f ,f))</span><br></pre></td></tr></table></figure><p>同样我们重写def实例：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> (<span class="name">def</span> func bindings body)</span><br><span class="line">    `(define ,(cons func bindings) ,body))</span><br></pre></td></tr></table></figure><p>其执行结果不变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CS61A-元语言抽象&quot;&gt;&lt;a href=&quot;#CS61A-元语言抽象&quot; class=&quot;headerlink&quot; title=&quot;CS61A 元语言抽象&quot;&gt;&lt;/a&gt;CS61A 元语言抽象&lt;/h2&gt;&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;head</summary>
      
    
    
    
    <category term="CS61A" scheme="http://example.com/categories/CS61A/"/>
    
    
    <category term="程序结构" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    <category term="CS61" scheme="http://example.com/tags/CS61/"/>
    
    <category term="CS61A" scheme="http://example.com/tags/CS61A/"/>
    
  </entry>
  
  <entry>
    <title>CS61A-数据抽象</title>
    <link href="http://example.com/2021/06/28/CS61A-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
    <id>http://example.com/2021/06/28/CS61A-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</id>
    <published>2021-06-28T03:25:57.000Z</published>
    <updated>2021-08-09T00:44:39.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS61A-数据抽象"><a href="#CS61A-数据抽象" class="headerlink" title="CS61A 数据抽象"></a>CS61A 数据抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><p>数据抽象导引</p><ul><li>构造器与选择器</li><li>序对的表示</li><li>抽象屏障与序对的过程性表示</li></ul><p>层次性数据和闭包性质</p><ul><li>序列的表示形式</li><li>可变数据与可变函数</li><li>层次性结构</li><li>迭代器与生成器</li></ul></blockquote><p><strong>带有*号的章节为SICP教材中所涉及的内容，CS61A课程中并未涉及。</strong></p><h3 id="数据抽象导引"><a href="#数据抽象导引" class="headerlink" title="数据抽象导引"></a>数据抽象导引</h3><hr><p>在课程第一部分过程抽象中，我们通过将一些过程组合起来形成复合过程，并以这种方式构造起各种抽象，然而第一章里的所有过程，操作的都是较为简单的数据，而对于许多问题而言，简单的数据无法满足需求，于是我们引入了数据抽象的概念。</p><p><strong>数据抽象就是指将数据对象组合起来，构成复合数据的形式。</strong></p><p>这是什么意思呢，我们从一个问题来引入，这个例子来自SICP教材，只不过SICP教材中所使用的是scheme语言，结构较为繁琐，因此我们使用Python语言代替来讲解。假设我们要设计一个系统，这个系统能够完成对于有理数的运算，从基本数据出发，一个有理数可以由两个整数来表示，那么如果我们要对两个有理数进行加法，那么我们就要向加法函数中同时传入两个分母和两个分子，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adder_without</span>(<span class="params">a,b,c,d</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (ad+bc)//bd</span><br><span class="line"></span><br><span class="line">如果我们要计算<span class="number">1</span>/<span class="number">3</span>+<span class="number">4</span>/<span class="number">5</span>，那么我们就得这样传入参数</span><br><span class="line"></span><br><span class="line">&gt;&gt;adder_without(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">17</span>/<span class="number">15</span></span><br></pre></td></tr></table></figure><p>我们会发现，这样很麻烦，在进行函数过程设计的时候，很容易就忘了a，b，c，d分别是什么，所以我们思考，能不能将一个分子与一个分母粘在一起，形成一个复合结构c和d，那么只需要在参数中传入c和d即可，这样就解决了传参的问题。</p><p>但是还有一个 问题，在函数设计过程中，我们也 需要对复合结构中的内容进行提取后使用，那么又该如何提取复合结构数据中的数据呢？</p><p>答案就是构建构造函数与选择函数。</p><h4 id="构造器与选择器"><a href="#构造器与选择器" class="headerlink" title="构造器与选择器"></a>构造器与选择器</h4><p>接着上面的问题，我们首先要将分子与分母放入一个复合结构，实现这个过程的函数叫做构造函数，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">up,down</span>)：</span></span><br><span class="line">    return [up,down]</span><br><span class="line"></span><br><span class="line">于是我们可以利用分子分母构建有理数a和b</span><br><span class="line"></span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>/<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个过程也可以使用scheme语言，具体语法不懂的可以看SICP教材。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">build</span> up down) (<span class="name"><span class="builtin-name">cons</span></span> up down)</span><br></pre></td></tr></table></figure><p>而后我们要能够将分子分母再从中提取出来，实现这个过程的函数叫做选择函数，Python叫选择器，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_up</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_down</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">于是我们就可以使用以上两个函数提取数据</span><br><span class="line"></span><br><span class="line">a_up = get_up(a)</span><br><span class="line">b_down = get_down(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用构造器与选择器重写加法函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (get_up(a)*get_down(b)+get_up(b)*get_down(a))/get_down(a)*get_down(b)</span><br><span class="line"></span><br><span class="line">使用构造函数</span><br><span class="line">a = build(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b = build(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">new = add(a,b)</span><br></pre></td></tr></table></figure><p>这样看起来是不是就清晰多了，这就是构造器和选择器搭配使用的优势，利用这个思路，我们还可以建立<code>sub</code>,<code>mul</code>,<code>pow</code>等运算函数。</p><h4 id="序对的表示"><a href="#序对的表示" class="headerlink" title="序对的表示"></a>序对的表示</h4><p>其实在上面我们已经在使用序对了，一个序对就是一个复合结构，不同的语言有不同的结构表示方式，Python中序对和序列界限其实很模糊，序对在Python中有字典Dict，元组Tuple，以及上面使用过的列表List：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   <span class="type">List</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="type">Tuple</span></span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125; <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line">Python中万物皆对象，所以提取数据的方式非常简单</span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line">b[<span class="number">1</span>]</span><br><span class="line">c[<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在scheme语言中，序对表示为cons，但是cons只能有两个数据：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> <span class="number">2</span>)   #相当于x = [<span class="name">1</span>,<span class="number">2</span>],但是scheme没有python高级，实现序列需要cons函数</span><br><span class="line">  </span><br><span class="line">使用 car 和 cdr 提取数据</span><br><span class="line">(<span class="name"><span class="builtin-name">car</span></span> x)</span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> x)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h4 id="抽象屏障与序对的过程性表示"><a href="#抽象屏障与序对的过程性表示" class="headerlink" title="抽象屏障与序对的过程性表示"></a>抽象屏障与序对的过程性表示</h4><p>抽象屏障隔离了系统的不同层次，在每一层上这种屏障都把使用数据抽象的程序和实现数据抽象的程序隔离开来，以有理数运算为例，对实现的过程进行分层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最高层： 使用有理数运算函数的过程</span><br><span class="line"></span><br><span class="line">第一层： 有理数运算函数 add() sub() mul() </span><br><span class="line"></span><br><span class="line">第二层： 有理数的构造函数和生成函数 build() get_up() get_down(）</span><br><span class="line">                                             </span><br><span class="line">第三层： 作为序对的有理数 cons() car()  cdr()  &#x2F;list[]  tuple[]</span><br></pre></td></tr></table></figure><p>这种构造思想最大的优点就是可修改性好，如果想要对程序的执行结构进行修改，可以直接对相应层中的函数进行修改，上层函数也会因此改变。</p><p>例如，我们想将输出的有理数约分到最简的形式，就可以在第二层中对有理数的构造函数build进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">up,down</span>):</span> </span><br><span class="line">    g = gcd(up,down)</span><br><span class="line">    <span class="keyword">return</span> [up/g,down/g]</span><br></pre></td></tr></table></figure><p>这样就完成了约分有理数的过程。</p><p>一般而言，我们总可以将复合数据定义为一组适当的选择函数和构造函数，以及使得这些过程成为一套合法表示，这一观点不仅可以服务于高层数据对象，同样也可以用于低层的数据对象，比如scheme语言中的序对这个概念，我们在前面用序对定义有理数，而cons，car和cdr也是函数，只要是函数就一定还能解释单个过程，那么cons函数会由哪些过程构成呢？</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">cons</span></span> x y))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> m))</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">=</span></span> m <span class="number">0</span>) x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">=</span></span> m <span class="number">1</span>) y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span>))</span><br><span class="line">    dispatch)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">car</span></span> z) (<span class="name">z</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> z) (<span class="name">z</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>由此我们可以看出，序对的概念实际上也可以解释为，由<code>(cons x y)</code>返回的值是一个选择过程，并根据参数是0还是1，返回x和y，虽然scheme语言并非这样来定义序对的，但是这也说明了所有数据都可以被定义为一组适当的选择器和构造器。</p><p>SICP教材中有一道题目很有意思，既然我们知道所有的复合数据都可以被定义为一组适当的构造函数和选择函数，那么对于基础数据呢？基础数据是不是也能由构造函数和选择函数定义？</p><p>答案是可以，这一表示形式被称为Church计数，其名字来源于发明人Alonzo Church，在SICP中使用scheme实现Church计数太过复杂，CS61A毕竟是入门课，所以使用Python来实现这个过程，首先我们实现构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(f(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用匿名函数嵌套的方式去定义构造函数，但是这样定义很累，所以我们思考用一个类似迭代的方式去实现，我们发现，实际上<code>one(f) = return lambda x:f(x) = return lambda x:f(zero(f)(x)</code>),把这个结构抽象出来就得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们要实现 two = successor(one)</span><br><span class="line">所以 two = <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(one(f)(x))</span><br><span class="line">令one = n 则有</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f:<span class="keyword">lambda</span> x:f(n(f)(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选择器要实现的过程就是将构造的zero转变为0，将one转变为1，我们使用选择器函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def church_to_int(n):</span><br><span class="line">    return n(lambda x:x+1)(0)</span><br><span class="line"></span><br><span class="line">这个函数的意思是令初始值x为0,然后按照构造函数的嵌套层数对x嵌套执行匿名函数，此处的匿名函数为add_one,同时也可以另其为add_ten等等，那么zero对应的就是0,one对应10</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;church_to_int(one)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt;church_to_int(three)</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>同样也可以对church对象进行加法运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_church</span>(<span class="params">m, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; church_to_int(add_church(two, three))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#church_to_int() if return 5 then five return five(f)</span></span><br><span class="line">    <span class="comment">#so we have to make add_church(two,three) like five(f)</span></span><br><span class="line">    <span class="comment">#five(f) return lambda x:f(f(f(f(f(x)))))  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(f)(x) +m(f)(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SICP中有church计数的scheme实现过程，大体类似。</p><h3 id="层次性数据和闭包性质"><a href="#层次性数据和闭包性质" class="headerlink" title="层次性数据和闭包性质"></a>层次性数据和闭包性质</h3><p>我们可以建立元素本身也是序对/序列的序列，我们把语言的这种性质叫做闭包性质，通过复合数据的闭包性质，可以实现复合结构的再复合。</p><h4 id="序列的表示形式"><a href="#序列的表示形式" class="headerlink" title="序列的表示形式"></a>序列的表示形式</h4><p>在scheme语言中，序列需要由基本的序对构成，通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，引入了一个基本操作list，使用list可以实现序对嵌套形成的序列，具体实现过程如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> </span><br><span class="line">   (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">2</span> </span><br><span class="line">       (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> nil)))</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">list(1,2,3)</span><br><span class="line"></span><br><span class="line">def lists (list(1,2,3)):</span><br></pre></td></tr></table></figure><p>通过上面的方式构建起<code>lists</code>这个表对象，而后使用cdr和car对表对象包含的数据进行调用</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">car</span></span> lists)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> lists)</span><br><span class="line">(<span class="name">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">car</span></span>(<span class="name"><span class="builtin-name">cdr</span></span> lists))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们也可以构建函数返回表中的第n个项：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">list-n</span> list n))</span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">car</span></span> list)</span><br><span class="line">      (<span class="name">list-n</span> (<span class="name"><span class="builtin-name">cdr</span></span> items) (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">于是对lists对象使用</span><br><span class="line">    </span><br><span class="line">(<span class="name">list-n</span> lists <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>scheme实现表操作的方式很麻烦，需要构建函数，需要自己设计过程，而Python生成序列的方式就明显高级很多了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样的过程只需要</span><br><span class="line"></span><br><span class="line">lists = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">调用返回第n项也只需要</span><br><span class="line"></span><br><span class="line">a = lists[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>而且python还可以生成字典，元组等序列，序列之间也可以直接嵌套：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure><h4 id="可变数据与可变函数"><a href="#可变数据与可变函数" class="headerlink" title="可变数据与可变函数"></a>可变数据与可变函数</h4><p>由于scheme对于序列的聚合太过繁杂，故我们直接使用python进行序列操作的介绍，对于python来说，序列聚合有很多种方式，也有很多函数可以进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&lt;stat&gt;)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">min</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,key=)</span><br><span class="line"><span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">any</span>()</span><br><span class="line"><span class="built_in">bool</span>()</span><br></pre></td></tr></table></figure><p>以上都是对python的序列进行聚合的方式，还有很多就不赘述了，有需要可以参考Roonob网站教程。那么，当我们需要修改一个序列的时候，我们该怎么实现呢？这就涉及可变性的问题了，python的序列当中，列表和字典属于<strong>可变序列</strong>，而字符串和元组属于不可变序列，那么什么是可变呢？可变就是能够任意修改序列的内容，比如，我们要在序列后加入‘a’这个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可变序列：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].append(<span class="string">&#x27;a&#x27;</span>)   </span><br><span class="line">dicts[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">不可变序列</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.append(<span class="string">&#x27;a&#x27;</span>)    Error</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>).append(<span class="string">&#x27;a&#x27;</span>)   Error</span><br></pre></td></tr></table></figure><p>具有可变性的序列可以直接使用内置函数直接修改序列本身，而不需要返回值来传递，这个在函数作用下效果明显，假设我们有一个列表<code>list1 = [1,2,3,4]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    list1.append(x)</span><br><span class="line">    list1.append(x)</span><br><span class="line"></span><br><span class="line">执行func(<span class="number">3</span>)后list1会改变吗？</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;func(<span class="number">3</span>)</span><br><span class="line">&lt;&lt;&lt;list1</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">会改变，因为列表具有可变性，调用append内置函数后，列表自动修改。</span><br></pre></td></tr></table></figure><p>有时候我们不仅需要可变序列，我们还需要可变函数，比如我们往银行存了100块钱，我们要每次从银行中取出20元，如果我们不使用可变函数我们就必须：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_money</span>(<span class="params">my_money</span>):</span></span><br><span class="line">     my_money -=<span class="number">20</span></span><br><span class="line">     <span class="keyword">return</span> my_money</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;my_money = <span class="number">100</span></span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money = get_money(<span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;my_money</span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure><p>我们会发现这种方式很麻烦，因为要不断返回和重新赋值给<code>my_money</code>变量，有没有一种方法，使得不用返回值就能直接得出剩余钱数呢？</p><p>有的，那就是<strong>可变函数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_draw</span>(<span class="params">balance</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_draw</span>(<span class="params">acount</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            balance = balance - acount</span><br><span class="line">            <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里出现了一个新的类型<code>nonlocal</code>，意思是非本地，也就是说，定义为<code>nonlocal</code>的变量会直接去父框架寻找变量，并且所有的变量更改直接同步父框架，基于这个性质 <code>nonlocal</code>必须满足以下几个条件才能使用：</p><blockquote><p>1.nonlocal 声明的变量必须存在于父框架</p><p>2.nonlocal 声明的变量不能在本地变量已经绑定值后再声明，这样python无法判断该变量的位置。</p></blockquote><p>我们知道，框架中可以直接调用和修改父框架内的值，那么为什么还要使用nonlocal来声明？</p><p>答案就是，python在进行运行前就已经对变量进行了判断，是位于本框架还是父框架，如果没有对变量进行nonlocal声明，python就会基于<code>balance=balance-accont</code>这个表达式判断balance是本地变量，而后在<code>if account &gt; balance</code>中报错。（讲的有些不太清楚，这里其实我也有点没理解透，后面再翻书查查。）</p><p>有没有办法能够不使用nonlocal进行可变函数的使用，有的，那就是改绑定值为修改值，利用序列的性质，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_draw</span>(<span class="params">balance</span>):</span></span><br><span class="line">    b= []</span><br><span class="line">    b[<span class="number">0</span>] = balance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_draw</span>(<span class="params">acount</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> acount &gt; balance</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b[<span class="number">0</span>] = b[<span class="number">0</span>] - acount</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> with_draw</span><br><span class="line"></span><br><span class="line">这样我们就可以实现</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;with_draw = make_draw(<span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line">&gt;&gt;&gt;with_draw(<span class="number">20</span>)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，减少值的过程就变成了修改序列第一位的值，而非修改balance变量的绑定，也就不会报错。</p><h4 id="层次性结构"><a href="#层次性结构" class="headerlink" title="层次性结构"></a>层次性结构</h4><p>序列按照层次性结构相互组合就会形成具有层次性的序列，最典型的层次性结构序列就是树，我们知道复合结构都可以用构造器和选择器定义，下面给出树的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span>(<span class="params">label, branches=[]</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a tree with the given label value and a list of branches.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">label</span>(<span class="params">tree</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Return the label value of a tree.&quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> branches(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Return the list of branches of the given tree.&quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> is_tree(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree is a tree, and False otherwise.&quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="params">tree</span>) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(<span class="params">tree</span>) &lt; <span class="number">1</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(<span class="params">branch</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">return</span> <span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="literal">True</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> is_leaf(<span class="params">tree</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Returns True if the given tree&#x27;s list of branches is empty, and False</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    otherwise.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="keyword">not</span> branches(<span class="params">tree</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">def</span> print_tree(<span class="params">t, indent=<span class="number">0</span></span>):</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;&quot;&quot;Print a representation of this tree in which each node is</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    indented by two spaces times its depth from the root.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; print_tree(tree(1))</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &gt;&gt;&gt; print_tree(numbers)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      3</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        4</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        5</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      6</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        7</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &quot;&quot;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">print</span>(<span class="params"><span class="string">&#x27;  &#x27;</span> * indent + <span class="built_in">str</span>(<span class="params">label(<span class="params">t</span>)</span>)</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(<span class="params">t</span>):</span></span></span><br><span class="line"><span class="function"><span class="params">        print_tree(<span class="params">b, indent + <span class="number">1</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br></pre></td></tr></table></figure><p>以上是树的定义，树每个的节点都由标签label和分支branch组成，没有分支的节点称为树叶节点，这种数据组织的方式，可以很清晰的看清上下层次的关系，可以用于解决很多实际问题，比如斐波纳契数列。</p><p>递归是处理树结构问题的一种常用方式，由于树的每一个分支都是子树或树叶，因此很容易实现自上而下的递归，以base_case作为终止条件。</p><p>我们来看几个关于树结构的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">问题一：替换具有指定数据的树节点</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_leaf</span>(<span class="params">t, old, new</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to old has</span></span><br><span class="line"><span class="string">    been replaced with new.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,</span></span><br><span class="line"><span class="string">    ...                  [tree(&#x27;balder&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;freya&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;frigg&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;,</span></span><br><span class="line"><span class="string">    ...                        [tree(&#x27;sif&#x27;),</span></span><br><span class="line"><span class="string">    ...                         tree(&#x27;thor&#x27;)]),</span></span><br><span class="line"><span class="string">    ...                   tree(&#x27;thor&#x27;)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))</span></span><br><span class="line"><span class="string">    odin</span></span><br><span class="line"><span class="string">      balder</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      frigg</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      thor</span></span><br><span class="line"><span class="string">        sif</span></span><br><span class="line"><span class="string">        freya</span></span><br><span class="line"><span class="string">      freya</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">if</span> label(t)==old:</span><br><span class="line">            <span class="keyword">return</span> tree(new)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tree(label(t))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_leaf(b,old,new) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line">可以看出，通过递归的方式可以对树的每个节点进行遍历，而后替换制定标签的数值</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">问题二：在每个叶节点上插入新子树</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sprout_leaves</span>(<span class="params">t, vals</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in vals at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new2)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        3</span></span><br><span class="line"><span class="string">          6</span></span><br><span class="line"><span class="string">          1</span></span><br><span class="line"><span class="string">          2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(s) <span class="keyword">for</span> s <span class="keyword">in</span> vals ])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        lsb = []</span></span><br><span class="line"><span class="string">        for b in branches(t):</span></span><br><span class="line"><span class="string">            lsb += sprout_leaves(b,vals)</span></span><br><span class="line"><span class="string">        return [tree(label(t),lsb)]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[sprout_leaves(b,vals) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><p>下一个问题比较麻烦，实现过程也比较复杂，基本上囊括了递归的所有知识，如果能够独立完成，基本上对于树的概念和递归的概念已经理解较深了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">问题三：对应树的相加</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_trees</span>(<span class="params">t1, t2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; numbers = tree(1,</span></span><br><span class="line"><span class="string">    ...                [tree(2,</span></span><br><span class="line"><span class="string">    ...                      [tree(3),</span></span><br><span class="line"><span class="string">    ...                       tree(4)]),</span></span><br><span class="line"><span class="string">    ...                 tree(5,</span></span><br><span class="line"><span class="string">    ...                      [tree(6,</span></span><br><span class="line"><span class="string">    ...                            [tree(7)]),</span></span><br><span class="line"><span class="string">    ...                       tree(8)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(numbers, numbers))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">        6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">      10</span></span><br><span class="line"><span class="string">        12</span></span><br><span class="line"><span class="string">          14</span></span><br><span class="line"><span class="string">        16</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">      4</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \</span></span><br><span class="line"><span class="string">    tree(2, [tree(3, [tree(4)]), tree(5)])))</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">      6</span></span><br><span class="line"><span class="string">        8</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t1) <span class="keyword">and</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span>(tree(label(t1)+label(t2)))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t1):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t2))</span><br><span class="line">    <span class="keyword">elif</span> is_leaf(t2):</span><br><span class="line">        <span class="keyword">return</span> tree((label(t1)+label(t2)),branches(t1))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lsp = []</span><br><span class="line">        node = label(t1)+label(t2)</span><br><span class="line">        zips = <span class="built_in">list</span>(<span class="built_in">zip</span>(branches(t1),branches(t2)))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t1)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t2)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(zips) == <span class="built_in">len</span>(branches(t2)):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> zips:</span><br><span class="line">                lsp += [add_trees(b[<span class="number">0</span>],b[<span class="number">1</span>])]</span><br><span class="line">            lsp +=branches(t1)[<span class="built_in">len</span>(zips):]</span><br><span class="line">            <span class="keyword">return</span> tree(node,lsp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里所用到的zip函数请自行查阅python指南，解答过程如上。</p><h4 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h4><p>Python和许多其他编程语言提供了一种统一的方式来顺序处理容器值的元素，称为迭代器，一个迭代器是提供对值顺序访问。</p><p>迭代器对象由两个部分组成，一个是迭代值iterable，另一个是迭代器iterator，迭代值提供迭代器顺序迭代的范围，迭代器提供一个检索对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   迭代值</span><br><span class="line">iters = <span class="built_in">iter</span>(prime)  迭代器</span><br></pre></td></tr></table></figure><p>利用迭代器的next方法来获取迭代器对象所指位置的数据，而后将指针后移一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(iters)</span><br><span class="line">StopIteration </span><br></pre></td></tr></table></figure><p>当到达处理序列末尾后再次调用<code>next</code>方法将会引发StopIteration异常，说明序列已经迭代完毕。</p><p>两个独立的迭代器可以跟踪同一序列的两个不同位置，同一迭代器赋值给另一变量，两个变量名称共享一个位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  =  <span class="built_in">range</span> ( <span class="number">3</span> ,  <span class="number">13</span> ) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第一个迭代器s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( s ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t  =  <span class="built_in">iter</span> ( r )   <span class="comment"># 第二个迭代器t </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( t ) </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u  =  <span class="built_in">iter</span>(t)  <span class="comment"># 第二个迭代器的替代名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span> ( u ) </span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>这里有一个利用迭代器计算斐波纳契数列的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_iter</span>(<span class="params">n</span>):</span></span><br><span class="line">    prev,curr=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="built_in">list</span> = [prev,curr]</span><br><span class="line">    index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        prev,curr = curr,prev+curr</span><br><span class="line">        <span class="built_in">list</span> +=[curr]</span><br><span class="line">        index ++</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p>使用如上的迭代器对象，可以轻松完成简单序列的迭代，然而，对于复杂的序列，next方法很难在计算中保存位置，生成器允许我们利用Python的特性来定义更复杂的迭代。</p><p>生成器函数与常规函数的区别在于，它们的主体中不包含return语句，而是使用yeild返回系列的元素</p><p>生成器不使用对象的属性来跟踪它们在一系列中的进度，相反，它们控制生成器函数的执行，该函数一直运行得到每次调用生成器的next方法时执行下一个yeild语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letters_generator</span>():</span></span><br><span class="line">    current = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> current &lt;=<span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">yield</span> current</span><br><span class="line">        current =<span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;letters = letters_generator()</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(letters)</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>再复杂一点可以这样使用生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">natural</span>():</span></span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">        x+<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;ns1,ns2=natural(),natural()</span><br><span class="line">&gt;&gt;&gt;[<span class="built_in">next</span>(ns1)*<span class="built_in">next</span>(ns2) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CS61A-数据抽象&quot;&gt;&lt;a href=&quot;#CS61A-数据抽象&quot; class=&quot;headerlink&quot; title=&quot;CS61A 数据抽象&quot;&gt;&lt;/a&gt;CS61A 数据抽象&lt;/h2&gt;&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CS61A" scheme="http://example.com/categories/CS61A/"/>
    
    
    <category term="程序结构" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    <category term="CS61" scheme="http://example.com/tags/CS61/"/>
    
    <category term="CS61A" scheme="http://example.com/tags/CS61A/"/>
    
  </entry>
  
  <entry>
    <title>CS61A-过程抽象</title>
    <link href="http://example.com/2021/06/12/CS61A-%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"/>
    <id>http://example.com/2021/06/12/CS61A-%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/</id>
    <published>2021-06-12T07:15:32.000Z</published>
    <updated>2021-08-08T08:01:48.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS61A-过程抽象"><a href="#CS61A-过程抽象" class="headerlink" title="CS61A 过程抽象"></a>CS61A 过程抽象</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><p>程序设计的基本元素</p><ul><li>表达式</li><li>变量与环境</li><li>复合过程与函数</li><li>条件表达式与判定符号</li><li>过程作为黑箱抽象</li></ul><p>过程产生的计算</p><ul><li>线性递归与迭代</li><li>树形递归</li></ul><p>高阶函数抽象</p><ul><li>过程作为参数</li><li>过程作为一般性的方法</li><li>过程作为返回值</li><li>使用匿名函数构造过程</li></ul></blockquote><h3 id="程序设计的基本元素"><a href="#程序设计的基本元素" class="headerlink" title="程序设计的基本元素"></a>程序设计的基本元素</h3><hr><p>一个强有力的语言，需要成为一种框架，使我们能够在里面组织自己的计算思想，为了达成这个目的，语言提供了三种机制：</p><p>一是基本的表达形式，也就是表达式，在python中，3，‘s’，这些都是表达式，3 + int(‘s’),这叫做复合表达式，表达式是语言最简单的个体。</p><p>二是组合的方法，通过组合，可以将各种表达式结合起来构造出复杂的元素</p><p>三是抽象的方法，通过抽象，我们可以对过程进行命名，并将它们当作单元去使用</p><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>以python为例，我们先来看一些基本表达式，基本表达式可以是数字，字符，字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;s&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p>通过将基本表达式进行组合，我们可以得到组合式</p><blockquote><p>3-1</p><p>‘s’ + ‘e’</p></blockquote><p>组合式表示一个过程，将运算符所刻画的过程，应用有关的实际参数，有些嵌套表达式比较复杂，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>+(<span class="number">4</span>*<span class="number">6</span>))*(<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p> 对于这个表达式，我们可以采取一棵树的形式来表示，设想运算对象的值向上穿行，而后在越来越高的层次中组合起来，这种计算过程叫做树形积累。</p><p><img src="https://i.loli.net/2021/06/12/BCrLjKNHeXEtiW3.png" alt="image-20210612194156857"></p><h4 id="变量与环境"><a href="#变量与环境" class="headerlink" title="变量与环境"></a>变量与环境</h4><p>我们在设计程序的时候会遇到这样一个问题，假设我们需要计算一个半径为2的圆的面积，我们使用<code>pi*(2**2)</code>进行计算，当我们想要计算的半径变为3时，我们又得写表达<code>pi*(3**2)</code>,为了避免这种情况的出现，我们将值2与名称r关联起来，而后我们只需要使用<code>pi*(r**2)</code>就可以计算半径为r对应值的圆的面积，我们把定义的名称r叫做变量。</p><p>不同语言定义变量的方式不同</p><p>Lisp</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> r <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>变量是语言抽象里最简单的一种方式，进一步思考，我们既然可以将值与符号相关联，这说明解释器必须维持某种储存能力，以保证一对一的关系，这种储存叫做环境。</p><h4 id="复合过程与函数"><a href="#复合过程与函数" class="headerlink" title="复合过程与函数"></a>复合过程与函数</h4><p>由上文可知，数和算数运算是基本的数据和过程，组合式的嵌套提供了一种组织多个操作的方法，而定义是一种受限的抽象手段，仅仅只能对值进行抽象</p><p>那么如果我们要对过程进行抽象该怎么办呢？</p><p>过程定义是一种威力更大的抽象技术，通过它可以为复合过程提供名称，而后便可以利用名称调用所对应的复合过程，这个复合过程在高级语言中被叫做函数，<strong>为了方便大家观看，接下来所有定义的复合过程我们均使用函数这个名称。</strong></p><p>例如，我们要求某个数的平方，因此我们给求平方的过程取一个名字叫做square</p><p>不同语言定义函数/复合过程名称的方式不同</p><p><em>Lisp</em></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x) (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure><p><em>Python</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br></pre></td></tr></table></figure><p>定义好之后就可以使用square进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(sqare <span class="number">21</span>)</span><br><span class="line">square(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们可以利用已定义好的函数去构建其他过程，以python为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_sq</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> square(x) + square(y)</span><br></pre></td></tr></table></figure><p>还可以利用sum_sq去构造其他过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sum_aq(a,a)</span><br></pre></td></tr></table></figure><h4 id="条件表达式与符号"><a href="#条件表达式与符号" class="headerlink" title="条件表达式与符号"></a>条件表达式与符号</h4><p>至此我们能定义的函数还是很有限，因为没法去做检测，而后依据结果去进行分支操作，因此我们需要条件表达式</p><p>不同的语言中条件表达式不同</p><p><em>Lisp</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</span><br><span class="line">     (<span class="name">cond</span>  (<span class="name">&gt;</span> x <span class="number">0</span>)x)</span><br><span class="line">            (<span class="name">=</span> x <span class="number">0</span>)<span class="number">0</span>)</span><br><span class="line">            (&lt; x 0)(-x))</span><br><span class="line">     )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Python没有switch语句，可以用if..elif…替代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> x = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> x &lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><p>if是一种特殊形式，是条件表达式的一种受限形式，适用于分情况分析只有两种情况的情况下。</p><p>除了&gt;&lt;=之外，还可以使用and，or，not进行判断，and表达式从左到右依次求值，如果某个值为假则表达式为假，后面不再求值，or表达式如果某个表达式为真，则表达式为真，后面也不在再求值。</p><p>例如Lisp中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">and</span>(<span class="name">&gt;</span> x <span class="number">5</span>)(<span class="name">&lt;</span> x <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h4 id="函数作为黑箱抽象"><a href="#函数作为黑箱抽象" class="headerlink" title="函数作为黑箱抽象"></a>函数作为黑箱抽象</h4><p>sqrt的例子可以自然的分解成若干个子问题，每一个工作都分配给独立的一个过程完成，因此sqrt的实现过程如图，它们直接反映了原问题是如何分解成为子问题并解决的</p><p><img src="https://i.loli.net/2021/06/12/u4zixB95rycdopg.png" alt="image-20210612202953454"></p><p>这一分解的重要性，在于分解中的每个函数都完成了一件可以清楚标明的工作，因此可以进行替换和修改。用户在使用的过程中，不需要知道是如何实现的 。</p><h5 id="内部定义与块结构"><a href="#内部定义与块结构" class="headerlink" title="内部定义与块结构"></a>内部定义与块结构</h5><p>为了突出重点，我们可以把辅助所使用的good-enough，imporve等辅助函数放入sqrt函数中，这种嵌套的定义称为块结构，因为x在sqrt内部是受约束的，而辅助过程都定义在sqrt里面，也就是说辅助过程都可以使用x的值。</p><h3 id="函数产生的计算"><a href="#函数产生的计算" class="headerlink" title="函数产生的计算"></a>函数产生的计算</h3><hr><h4 id="线性递归与迭代"><a href="#线性递归与迭代" class="headerlink" title="线性递归与迭代"></a>线性递归与迭代</h4><p>我们以函数的阶乘为例，讲解函数的递归和迭代。</p><p>首先，我们使用递归来计算阶乘</p><p>考虑阶乘函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n! = n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>)..<span class="number">.1</span></span><br><span class="line">(n-<span class="number">1</span>)! = (n-<span class="number">1</span>)*(n-<span class="number">2</span>)..<span class="number">.1</span></span><br><span class="line">n! = n*(n-<span class="number">1</span>)! </span><br></pre></td></tr></table></figure><p>这样，我们就能通过算出(n-1)!，i进而计算出n！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">     <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但是这就出现了一个问题，这个函数会陷入无限循环，因为没有一个标志告诉函数什么时候停下来，所以我们需要一个base_case去限制递归终止的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这个过程如图所示</p><p><img src="https://i.loli.net/2021/06/12/EoGL5rvkQ8ilTzX.png" alt="image-20210612215413983"></p><p>于是我们总结出迭代所需要的三个要素：</p><p><em>一是base_case也就是迭代终止条件</em></p><p><em>二是可迭代拆分的结构，比如<code>factorial(n)</code>的结果就可以分解成为`n </em> factorial(n-1)`</p><p><em>三是可以连续传递</em>，验证n与n-1的规则是否通用。</p><p>但是，在设计迭代结构的过程中可能会遇到，由于存在其他规则，使得过程非单一方向，传入的参数无法进行迭代，比如</p><blockquote><p>乒乓序列从 1 开始计数，并且总是向上计数或向下计数。在元素 处k，如果k是 7 的倍数或包含数字 7 ，则方向切换。 下面列出了乒乓序列的前 30 个元素，方向交换在第 7、第 14、第 17、第 21、第 27 处用括号标记，和第 28 个元素：</p><p>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6,</p><p>def pingpong(n): ?</p></blockquote><p>这里的<code>pingpong(n)</code>和<code>pingpong(n-1)</code>无法形成迭代关系，因为每逢7就要切换方向，因此，我们在函数中再定义一个函数itera，利用itera来代替pingpong进行迭代,n仅作为base_case。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pingpong</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">itera</span>(<span class="params">out,index=<span class="number">1</span>,adder=<span class="number">1</span></span>)</span></span><br><span class="line">        if index == n:</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">        <span class="keyword">if</span> index%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> itera(out+adder,index+<span class="number">1</span>,adder=-adder)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> itera(out+adder,index+<span class="number">1</span>,adder=adder)</span><br><span class="line">    out = itera(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> out </span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>这样就实现了迭代，这里的迭代只针对内部函数itera，n在itera中相当于一个常数。</p><p>而后，我们再使用迭代对阶乘进行计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a = a*i</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>由上文可知，迭代的计算并没有重复调用自身，而是在单个函数框架内部控制了一个重复运行的结构，并利用for循环设置停止条件。</p><p>迭代的表示如下：</p><p><img src="https://i.loli.net/2021/06/13/SmeKwilTO8B7Z2t.png" alt="image-20210613110228758"></p><p>迭代和递归是两种最常见的循环过程，其主要不同点在于：</p><p>一是框架，迭代的整个过程都是在函数建立的单个框架内部执行的，而递归由于不断重复调用自身，所以不断的建立新的函数框架，使用Pythontutor可以清晰的看到这两个过程。</p><p>迭代：</p><p><img src="https://i.loli.net/2021/06/13/X86tKiEOypvATkb.png" alt="image-20210613110437725"></p><p>递归：</p><p><img src="https://i.loli.net/2021/06/13/rLJNnMR8fzq2SBX.png" alt="image-20210613110636563"></p><p>二是过程，迭代实际上是一个过程中的一部分，而递归是一个完整的过程，也就是说递归中可能包含迭代，但是迭代中肯定不会包含递归。</p><h4 id="树形递归"><a href="#树形递归" class="headerlink" title="树形递归"></a>树形递归</h4><p>树形递归是一种特殊的递归形式，我们以斐波纳契数列为例，讲解树形递归的实现方式。</p><p>首先我们以递归的思路来考虑</p><p><code>feb(n)</code>和<code>feb(n-1)</code>有什么关系？</p><p>貌似没有关系，但是我们知道<code>feb(n)=feb(n-1)+feb(n-2)</code></p><p>因此我们可以这样设计递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feb</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这个过程同时进行了两个方向的递归，这种递归叫做树递归，表示如下：</p><p><img src="https://i.loli.net/2021/06/13/NnIUPVbqSmXe4lB.png" alt="image-20210613112437233"></p><p>树形递归的作用就是同时进行多个方向的递归，有些函数需要多个递归过程相加，例如HW02中的河内塔问题</p><blockquote><p>Q7：河内塔<br>一个名为河内塔的经典谜题是一种游戏，它由三根杆和许多可以滑到任何杆上的不同大小的圆盘组成。谜题开始时，n圆盘在start棒上按尺寸升序排列整齐，最小的在顶部，形成圆锥形状。</p><p><img src="https://i.loli.net/2021/06/13/BeUAztOT3pEMG9L.png" alt="image-20210613154038670"></p><p>拼图的目标是将整个堆栈移动到一根end杆上，遵守以下规则：</p><p>一次只能移动一个磁盘。<br>每次移动都包括从一根棒上取下顶部（最小）圆盘并将其滑到另一根棒上，位于该棒上可能已经存在的其他圆盘的顶部。<br>任何磁盘都不能放置在较小磁盘的顶部。<br>完成 的定义move_stack，它打印出在不违反规则的情况下将n圆盘从start杆移动到杆所需的步骤end。提供的print_move函数将打印出将单个磁盘从给定的移动origin到给定的步骤destination。</p><p>题目给出了两个内置函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_move</span>(<span class="params">origin, destination</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print instructions to move a disk.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Move the top disk from rod&quot;</span>, origin, <span class="string">&quot;to rod&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_stack</span>(<span class="params">n, start, end</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print the moves required to move n disks on the start pole to the end</span></span><br><span class="line"><span class="string">    pole without violating the rules of Towers of Hanoi.</span></span><br></pre></td></tr></table></figure></blockquote><p>我们仔细思考这个过程，我们知道，如果要把一个三层河内塔从Bar1移动到Bar3，那么我们应该<code>move_stack(3,1,3)</code>,而<code>move_stack(3,1,3)</code>这个过程可以分解为</p><p>一.先将上面两层移动至2,即<code>move_stack(2,1,2)</code></p><p>二.将底层移动到3,即<code>move_stack(1,1,3)</code></p><p>三.将在2的两层移至3,即<code>move_stack(2,2,3)</code></p><p>我们会发现实际上<code>move_stack(n,a,c)</code>可以分解为<code>move_stack(n-1,a,b)</code>，<code>move_stack(1,a,c)</code>,<code>move_stack(n-1,b,c)</code></p><p>因此这个递归函数是一个树递归，三个递归同时在运行，最终合并得出最终结果。</p><p>具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_stack</span>(<span class="params">n,start,end</span>):</span></span><br><span class="line">        bars = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        print_move(start,end)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c=[bar <span class="keyword">for</span> bar <span class="keyword">in</span> bars <span class="keyword">if</span> bar <span class="keyword">not</span> <span class="keyword">in</span> [start,end] ]</span><br><span class="line">        c = c[<span class="number">0</span>]</span><br><span class="line">        a = start</span><br><span class="line">        b = end </span><br><span class="line">        move_stack(n-<span class="number">1</span>,a,c)</span><br><span class="line">        move_stack(<span class="number">1</span>,a,b)</span><br><span class="line">        move_stack(n-<span class="number">1</span>,c,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的base_case就是n==1。</p><h3 id="高阶函数抽象"><a href="#高阶函数抽象" class="headerlink" title="高阶函数抽象"></a>高阶函数抽象</h3><hr><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>思考一下以下两个函数</p><p>第一个 sum_naturals函数计算最大为n的自然数之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_naturals</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + [k], k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二个sum_pi计算系列中的项的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi_sum</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + [<span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>))], k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><p>我们发现，他们实际上都共有一个框架，唯一不同的实际上是一个关于k的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xx</span> (<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><p>因此我们可以将这个关于k的函数作为参数传入主函数，这样就实现了填充同一个模板中的槽来生成每个函数，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">n,term</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">natural</span>(<span class="params">k</span>):</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi</span>(<span class="params">k</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样一来，我们就将整个结构抽象了出来，通过传入不同函数对过程进行控制。</p><h4 id="函数作为一般性方法"><a href="#函数作为一般性方法" class="headerlink" title="函数作为一般性方法"></a>函数作为一般性方法</h4><p>刚才我们说到，函数可以作为参数传递给函数，我们再来看一个例子，这个例子是计算黄金分割率的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="function"><span class="keyword">def</span> <span class="title">improve</span>(<span class="params">update, close, guess=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="number">2</span>    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line"><span class="number">3</span>        guess = update(guess)</span><br><span class="line"><span class="number">4</span>    <span class="keyword">return</span> guess</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span><span class="function"><span class="keyword">def</span> <span class="title">golden_update</span>(<span class="params">guess</span>):</span></span><br><span class="line"><span class="number">7</span>    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span><span class="function"><span class="keyword">def</span> <span class="title">square_close_to_successor</span>(<span class="params">guess</span>):</span></span><br><span class="line"><span class="number">10</span>    <span class="keyword">return</span> approx_eq(guess * guess,</span><br><span class="line"><span class="number">11</span>                     guess + <span class="number">1</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span><span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span></span><br><span class="line"><span class="number">14</span>    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>phi = improve(golden_update,</span><br><span class="line"><span class="number">17</span>              square_close_to_successor)</span><br></pre></td></tr></table></figure><p>我们会发现，虽然结果没有问题，但是整个函数结构显得很凌乱，为了解决这个问题，我们引入了嵌套定义的概念，为了解决函数结构不整齐的问题，于是上文的函数结构就可以改变为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve</span>(<span class="params">guess=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">golden_update</span>(<span class="params">guess</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square_close_to_successor</span>(<span class="params">guess</span>):</span></span><br><span class="line">           <span class="keyword">return</span> approx_eq(guess * guess,guess + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-3</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span> <span class="keyword">not</span> square_close_to_successor(guess):</span><br><span class="line">        guess = golden_update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line">phi = improve()</span><br></pre></td></tr></table></figure><p>这样一来整体的函数结构就清晰多了。</p><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>通过创建返回值本身就是函数的函数，我们可以在我们的程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保持其父环境。以下示例说明了此功能的实用性。</p><p>一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数f(x)和g(x)，我们可能想要定义h(x) = f(g(x))。我们可以使用现有工具定义函数组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose1</span>(<span class="params">f, g</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="keyword">return</span> f(g(x))</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>这时候返回的函数就是f(g(x))</p><p>函数作为返回值的一个重要应用就是函数的柯里化，我们可以使用高阶函数将带有多个参数的函数转换为每个带有一个参数的函数链。更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g使得g(x)(y)等价于f(x, y)。这里，g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y 的函数。这种转换称为柯里化。</p><p>柯里化的具体实现过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curi_pow</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x,y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当调用<code>curi_pow(2)(3)</code>时，首先计算curi_pow(2),返回的函数实际上就是 <code>lambda  x: pow(2,x)</code>，这个结构可能大家现在还看不懂，不过后面讲到lambda匿名函数的时候就懂了。因此<code>curi_pow(2)（3）</code>实际上是<code>lambda x:pow(2,x)(3)</code>也就是pow(2,3)</p><p>我们可以将柯里化的过程也抽象成一个函数，使得其可以对所有拥有两个参数的函数进行柯里化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curi</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">y</span>):</span></span><br><span class="line">            <span class="keyword">return</span> f(x,y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>具体推导过程 如下：</p><p>要使得  s(x)(y) = f(x,y)，则s = lambda x:lambda y :f(x,y)，将lambda函数转为正常函数即可。</p><p>柯里化也可以反向进行，具体实现过程为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uncuri</span>(<span class="params">g</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">x,y</span>):</span></span><br><span class="line">            <span class="keyword">return</span> g(x)(y)</span><br><span class="line">     <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>同理，要使得 f(x,y) = g(x)(y)，则 f = lambda x,y : g(x)(y)，将lambda函转换为正常函数即可。</p><h4 id="使用匿名函数构造过程"><a href="#使用匿名函数构造过程" class="headerlink" title="使用匿名函数构造过程"></a>使用匿名函数构造过程</h4><p>到目前为止，每次我们想要定义一个新函数时，我们都需要给它一个名字。但是有一种函数不需要命名就可以调用，这种函数被称作匿名函数，在 Python 中，我们可以使用lambda 表达式动态创建函数值，这些表达式的计算结果为未命名的函数。一个 lambda 表达式的计算结果是一个函数，它有一个返回表达式作为它的主体。</p><p>lambda 表达式的结果称为 lambda 函数。它没有内在名称（因此 Python 打印<lambda>作为名称），但除此之外它的行为与任何其他函数一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">lambda</span> x:x*x</span><br><span class="line">s(<span class="number">2</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这相当于把s这个名称指向一个函数，这个函数是匿名函数lambda。</p><p>一些程序员发现使用来自 lambda 表达式的未命名函数更短、更直接。然而，众所周知，复合lambda表达式难以辨认，尽管它们很简洁。下面的定义是正确的，但是很多程序员很难快速理解它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose1=<span class="keyword">lambda</span> f,g:<span class="keyword">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure><p>匿名函数还可以是带递归的匿名函数，这个结构较为复杂，我们以阶乘为例，来讲解一下这个结构。</p><p>我们知道，使用递归来进行阶乘的计算如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么如果使用匿名函数来进行递归，结构又该是什么样的呢？</p><p>我们先来看一个简单一点的方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fact = <span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> n*fact(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这样的话我们只需要使用fact(3)就可以进行调用循环，但是这里有个问题就是，如果我们改变了左侧的名称，这个结构就没法用了，为了能够构建一个更加通用的匿名函数，我们需要将这个函数进一步改造，首先，我们将函数本身作为匿名的参数传入,我们这里将函数命名为f</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> n,f:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> n*f(n-<span class="number">1</span>,f) </span><br></pre></td></tr></table></figure><p>于是这个函数体就是我们所需要的匿名函数体，问题在于，如果这样构建匿名函数的话，我们需要传入一个参数f，也就是函数体本身，那么又无法通用了，因为如果你令fact= lambda n,f:1 if n==1 else n*f(n-1,f)，那么你要使用fact(n,fact)进行调用，这样还是无法满足通用性,因为我们要实现的是<random name>(n) 调用。</p><p>解决这个问题的方法是在函数外再套一层函数，将构建的函数f当作参数传入。</p><p>fact = lambda n:(lambda g:g(n,f))(lambda n,f:1 if n==1 else n*f(n-1,f))</p><p>这个结构的原理是这样的，fact(3)首先等于<code>(lambda f:f(3,f))</code>，然而由于后i面还有一个<code>(lambda n,f:1 if n==1 else n*f(n-1,f))</code>因此f函数的值被填充为匿名函数，成为f(3,f) 其中 <code>f(n,f)=(lambda n,f:1 if n==1 else n*f(n-1,f))</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CS61A-过程抽象&quot;&gt;&lt;a href=&quot;#CS61A-过程抽象&quot; class=&quot;headerlink&quot; title=&quot;CS61A 过程抽象&quot;&gt;&lt;/a&gt;CS61A 过程抽象&lt;/h2&gt;&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CS61A" scheme="http://example.com/categories/CS61A/"/>
    
    
    <category term="程序结构" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    <category term="CS61" scheme="http://example.com/tags/CS61/"/>
    
    <category term="CS61A" scheme="http://example.com/tags/CS61A/"/>
    
  </entry>
  
  <entry>
    <title>CS61A-综述</title>
    <link href="http://example.com/2021/06/12/CS61A-%E7%BB%BC%E8%BF%B0/"/>
    <id>http://example.com/2021/06/12/CS61A-%E7%BB%BC%E8%BF%B0/</id>
    <published>2021-06-12T07:04:18.000Z</published>
    <updated>2021-08-08T08:02:01.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS61A-综述"><a href="#CS61A-综述" class="headerlink" title="CS61A 综述"></a>CS61A 综述</h2><p>简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程序，课程按照讲解内容可以分为过程抽象，数据抽象和语言抽象。</p><p>首先，课程通过讲解函数式编程引入过程抽象思想，介绍了表达式，变量，函数等概念，又从函数框架的层面讲解了函数作用域的概念，最后对函数式编程的几种主要方式进行了介绍，引入了递归调用的概念。</p><p>而后，课程转入数据抽象，数据抽象是课程中最重要的部分，其直接的表现形式就是面向对象编程，把一组过程抽象（函数）作为类的方法集中考虑，并加入内部状态（类的变量），就是一个数据抽象，每个数据抽象对外通过一组接口进行调用，这样在调用时就不需要考虑函数内部情况，只需要知道函数实现的功能并进行合理调用即可。</p><p>最后，课程讲述了语言抽象的过程，主要是讲解如何从零开始构建一门语言，定义这门语言的语法，并实现该语言的解释器或编译器，这一部分涉及编译原理，可能需要对编译原理进行拓展阅读。</p><p>本书所使用的教材是经典的SICP，即计算机程序的构造与解释，原书所使用的语言是Lisp，而课程使用了更加广泛应用的python，降低了学习的门槛。</p><p>但是 ，程序设计的思想是通用的，我们要学习的不仅仅只是python语言中程序的构建模式，更要学习程序设计的通用模式，拿到一门语言后如何快速掌握其要点，并利用这门语言进行程序设计，这才是这门课程真正想教给大家的。</p><p>从讲述结构来看，我很明显感觉CS61A更注重的是Python语法的讲解，而SICP更多讲的是一种通用的程序设计模式，所以我会在后面将Python语法作为SICP模式讲解中的一个范例进行阐述，而不是直接讲python语法，毕竟我学61A的初衷不只是学会python，而是掌握程序设计的模式。</p><p>从20年接触计算机开始到现在，我开始慢慢感觉到整个计算机科学的构建就是不断的抽象和封装，尤其在读了Nand2Teris后，这种感受更加深刻了，Nand门的相互组合构建了16门，而16门的相互组合构建起了ROM，RAM和ALU，PC，再通过封装将这些模块组合起来，就构建成了计算机的硬件部分。软件也是一样，具体数值抽象成了变量，变量与数据结构共同作用构成了函数，函数与变量共同作用构成了类与对象。在不同类之间游走，就构建了计算机程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CS61A-综述&quot;&gt;&lt;a href=&quot;#CS61A-综述&quot; class=&quot;headerlink&quot; title=&quot;CS61A 综述&quot;&gt;&lt;/a&gt;CS61A 综述&lt;/h2&gt;&lt;p&gt;简单过了一遍课程内容，CS61A这门课程的主要目的是教会我们如何去利用抽象的思想构建繁杂的程</summary>
      
    
    
    
    <category term="CS61A" scheme="http://example.com/categories/CS61A/"/>
    
    
    <category term="程序结构" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    
    <category term="CS61" scheme="http://example.com/tags/CS61/"/>
    
    <category term="CS61A" scheme="http://example.com/tags/CS61A/"/>
    
  </entry>
  
  <entry>
    <title>简明Git使用方法</title>
    <link href="http://example.com/2021/05/27/%E7%AE%80%E6%98%8EGit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/05/27/%E7%AE%80%E6%98%8EGit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-05-27T07:37:40.000Z</published>
    <updated>2021-05-28T08:56:36.152Z</updated>
    
    <content type="html"><![CDATA[<p>近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote><p>版本库的创建</p><ul><li> Git的安装</li><li> 版本库的创建</li></ul><p>版本库的操作</p><ul><li> 文件操作</li><li> 版本回退</li><li> 修改撤销 </li></ul><p>远程库连接</p><ul><li>远程库添加与解除</li><li>从远程库克隆</li></ul><p>分支管理</p><ul><li>创建与合并分支</li><li>多人协作</li></ul><p>标签管理</p><ul><li>创建标签</li><li>操作标签</li></ul></blockquote><h2 id="版本库的创建"><a href="#版本库的创建" class="headerlink" title="版本库的创建"></a>版本库的创建</h2><hr><h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><p>在Ubuntu Linux上使用apt软件包管理工具进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>在windows上直接进入<a href="https://git-scm.com/downloads">Git官网</a>下载安装程序，而后按照默认选项安装即可</p><h3 id="版本库的创建-1"><a href="#版本库的创建-1" class="headerlink" title="版本库的创建"></a>版本库的创建</h3><p>选择一个合适的位置利用mkdir指令创建一个空目录，而后进入后输入指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>于是该目录就变成了Git可以管理的仓库，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><h2 id="版本库的操作"><a href="#版本库的操作" class="headerlink" title="版本库的操作"></a>版本库的操作</h2><hr><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在文件操作之前首先明确几个概念</p><p><strong>工作区</strong></p><p>就是电脑中能直接看见的目录</p><p><img src="https://i.loli.net/2021/05/28/Vc1mn4w6MZIaRSB.png" alt="working-dir"></p><p><strong>版本库</strong></p><p>工作区目录中有一个隐藏目录.git。这个是Git的版本库，版本库主要由两个部分组成，stage暂存区和分支区。</p><p><img src="https://i.loli.net/2021/05/28/nzqcBheNH58kMAG.jpg" alt="git-repo"></p><p> <strong>将文件添加至Git版本库中时，有三个步骤：</strong></p><p><strong>首先</strong>在工作区创建一个文件Read.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim/typora Read.txt</span><br></pre></td></tr></table></figure><p>将文件修改添加至暂存区，在添加至暂存区前，我们首先看一下git的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">Read.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Git清楚的告诉我们，有一个文件出现了，而<code>Read.txt</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p><strong>而后</strong>我们创建文件这次操作添加至暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add Read.txt</span><br></pre></td></tr></table></figure><p><em>如果添加的是文件夹可以使用</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add vs/*</span><br></pre></td></tr></table></figure><p>如果想删除文件可以用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm Read.txt</span><br></pre></td></tr></table></figure><p>再次查看git的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   Read.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Changes to be committed</code>我们发现git已经识别了这个文件，可见这个文件已经被添加到了暂存区。</p><p><strong>最后</strong>我们将文件创建这次操作提交至仓库的master分支（分支的概念后面会讲到）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit Read.txt -m <span class="string">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure><p><em>如果想提交全部文件的操作可以用</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit&quot;</span></span><br></pre></td></tr></table></figure><p>这里的-m参数是对这次提交进行文字说明</p><p>再次查看git的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见此时暂存区为空，修改已提交至仓库</p><p>我们可以将创建文件并提交至仓库的过程用流程图表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[在工作区创建文件]&#x3D;&#x3D;&#x3D;&gt;B[将修改&#x2F;创建&#x2F;删除操作添加至暂存区]&#x3D;&#x3D;&#x3D;&#x3D;&gt;C[将操作提交至仓库]</span><br></pre></td></tr></table></figure><p>估计很多人都有疑问，为什么这里写的是操作，而不是将文件添加至暂存区，因为Git管理的是修改而不是文件，我们用一个例子来说明这个问题。</p><p>首先，我们在Read.txt中添加一段文字<code>hello me</code>，而后将这次操作添加到暂存区，我们查看此时的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">modified:   Read.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见此次修改已经添加到了暂存区，而后我们再对文件进行修改，增加一行<code>hello you</code>，不将此次修改添加至暂存区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">modified:   Read.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   Read.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们执行提交指令将修改提交至仓库，而后查看git状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 8 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   Read.txt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们发现，未添加至暂存区的修改并未提交至仓库，我们查看一下工作区和最新版本库的区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git diff -- Read.txt</span><br><span class="line">diff --git a/Read.txt b/Read.txt</span><br><span class="line">index 1f8eec4..12ee40e 100644</span><br><span class="line">--- a/Read.txt</span><br><span class="line">+++ b/Read.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> hello world</span><br><span class="line"> hello me</span><br><span class="line">+hello you</span><br></pre></td></tr></table></figure><p>如果Git管理的是文件本身，那么文件在提交时是什么样，提交的文件就是什么样，然而经过对比发现，版本库的文件和工作区的文件是不一样，我们每次添加到暂存区的是对文件的操作步骤，比如创建删除文件，添加几行，删除几行，由于刚才添加<code>hello you</code>这一行文字的修改操作并未添加至暂存区，提交时只提交暂存区有的操作，因此该操作未提交至仓库。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>上面i讲到，Git管理的是修改，如果我们在进行修改提交的过程中，不小心删除了最后一行<code>hello me</code> ，而我们又需要这行文字该怎么办呢？</p><p>这时候就需要利用版本回退的功能了。</p><p>在Git中，我们可以查看每次操作的记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">aa03a474011bcb97e9f596d3b5c9a1b517726d05 (HEAD -&gt; master) delete a line</span><br><span class="line">05491fda20edff579daf14f24b7afed61d591842 add a line</span><br><span class="line">a58d42838b1284034c4a9d52f0d2780ad251bda2 a</span><br><span class="line">f67db85d1deeb3d7ca0020a332ac4e07bccf12b0 all</span><br><span class="line">b96112ab41f972a9949e213347d7403dd2f8a03b 1</span><br></pre></td></tr></table></figure><p>我们要将版本回退到<code>delete a line</code>操作前，因此我们使用<code>reset</code>指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 05491fd add a line</span><br></pre></td></tr></table></figure><p>这里的HEAD^表示上一个版本，如果上两个版本则为^^,以此类推。</p><p>但是问题来了，如果我们现在又想回到<code>delete a line</code>版本该怎么办呢？版本已经回退了。</p><p>git有一个命令记录了你的每次命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git reflog</span><br><span class="line">05491fd (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">aa03a47 HEAD@&#123;1&#125;: commit: delete a line</span><br><span class="line">05491fd (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add a line</span><br></pre></td></tr></table></figure><p>于是我们就可以利用<code>aa03a47</code>这个id来回到原来版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard aa03a47</span><br><span class="line">HEAD is now at aa03a47 delete a line</span><br></pre></td></tr></table></figure><p>于是，版本又回来了。</p><h3 id="修改撤销"><a href="#修改撤销" class="headerlink" title="修改撤销"></a>修改撤销</h3><p>有的时候我们会因为手抖写错代码，比如我们在Read.txt（.sh）文件中添加一行‘rm -rf’，懂点Linux都知道这是个致命操作。</p><p><strong>如果你还没有将这次文件修改提交到暂存区</strong>，那么很简单，直接修改就好了，或者也可以使用指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- Read.txt</span><br></pre></td></tr></table></figure><p>工作区的修改就被丢弃了，工作区文件的内容和版本库文件的内容相同。</p><p><strong>如果你已经将文件修改添加到了暂存区</strong>，那么我们需要使用另一个指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD Read.txt</span><br></pre></td></tr></table></figure><p>reset指令不仅可以回退版本，当HEAD不^时，reset指令也可以将暂存区的修改操作移除，而后再利用<code>checkout</code>指令同步版本库和工作区内容。</p><p><strong>如果你已经将修改提交到了版本库</strong>，那么按照版本回退的方式进行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>如果你已经将版本库内的内容推送到远程库，比如Github，那就只能听天由命了，谁运行，谁遭殃。</p><h2 id="远程库连接"><a href="#远程库连接" class="headerlink" title="远程库连接"></a>远程库连接</h2><hr><h3 id="远程库添加-解除"><a href="#远程库添加-解除" class="headerlink" title="远程库添加/解除"></a>远程库添加/解除</h3><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p><p>（图借的廖雪峰大L的）：</p><p><img src="https://i.loli.net/2021/05/28/HYRADbO3nfjtW9T.png" alt="github-create-repo-1"></p><p>在Repository name填入<code>Read</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://i.loli.net/2021/05/28/P62pheNWtkZSVcB.png" alt="github-create-repo-2"></p><p>而后，我们在本地运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxx/Read.git</span><br></pre></td></tr></table></figure><p>xxx处为你自己的Github账户名，就可以将本地的版本库和远程的库连接起来了。</p><p>将本地库所有内容推送至Github远程库的master分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push （-u） origin master</span><br></pre></td></tr></table></figure><p>加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令，不许需要加入-u参数。</p><p><strong>SSH警告</strong></p><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><p><strong>解除远程库与本地库的关联关系</strong></p><p>如果我们需要解除本地库与远程库的关联关系，可以使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><h3 id="远程库克隆"><a href="#远程库克隆" class="headerlink" title="远程库克隆"></a>远程库克隆</h3><p>我们有时需要把远程库从Github克隆下来，为了借鉴代码或是进行分布式工作，使用以下指令将远程库克隆至本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xxx/Read.git</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p><img src="https://i.loli.net/2021/05/28/X69umbEgxRBfh3w.png" alt="git-br-initial"></p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p><p><img src="https://i.loli.net/2021/05/28/EXNTRAfMmV2B63a.png" alt="git-br-create"></p><p>我们建立一个新分支<code>dev</code>并切换至新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev    /   git switch -c dev</span><br></pre></td></tr></table></figure><p><em>如果切换至已有分支则</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev    /    git switch dev</span><br></pre></td></tr></table></figure><p>如果只是创建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd"></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://i.loli.net/2021/05/28/dQuX31cxi6RTeDO.png" alt="git-br-ff-merge"></p><p>我们切换至主分支，而后将dev分支合并至主分支master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>而后我们可以保留分支，也可以删除分支，如果删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://i.loli.net/2021/05/28/tWO9ydfr5miY3EP.png" alt="git-br-policy"></p><p><strong>远程库克隆</strong></p><p>团队合作的过程中首先要将远程库克隆至本地，具体方式见前文远程库克隆一节</p><p>完成克隆后，Git自动把本地的master分支和远程的master分支对应起来了，默认远程仓库的名称为origin</p><p>查看远程库的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/CS61A$ git remote -v</span><br><span class="line">origingit@github.com:x/CS61A.git (fetch)</span><br><span class="line">origingit@github.com:x/CS61A.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><p><strong>分支的推送</strong></p><p>分支的推送有很多种模式，这里只介绍最简单的模式，假设，我们已经将远程库的master分支克隆到了本地，而后我们创建了一个新的分支dev，在新的分支进行工作，工作完毕后我们将dev分支合并至master分支，而后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>就将该分支推送到了远程库</p><p><strong>分支的抓取</strong></p><p>在多人协作时可能会出现一些问题，比如有一天，你的小伙伴已经向origin/master分支推送了他的提交，而你碰巧也对同样的文件进行了修改，并试图推送，这时候你会发现，git提示推送失败，因为你的小伙伴的最新提交和你的提交有冲突。</p><p>因此我们要在推送前先将master最新情况从远程抓下来，然后在本地进行合并和解决冲突。</p><p>解决冲突的方法如下</p><p>我们知道当我们把远程的master分支抓取下来后，我们本地的dev分支和远程pull下来的master分支存在冲突</p><p><img src="https://i.loli.net/2021/05/28/ve3HlyfWtqB7bYN.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并会有冲突，我们查看 一下git的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   Read.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Git告诉我们，Read.txt文件存在冲突，我们可以直接查看文件内容</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交修改给master分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>Git告诉我们冲突被解决了，于是我们将dev分支合并至master，而后执行push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:x/Read.git</span><br><span class="line">   7a5e5dd..57c53ab  master -&gt; master</span><br></pre></td></tr></table></figure><p>成功。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>为什么需要标签？</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，而后敲击tag就可以打一个标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p>利用<code>git tag</code>查看所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br><span class="line">v2.1</span><br></pre></td></tr></table></figure><p>如果要对历史commit打标签，那就通过git log找到commit号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 f287d34</span><br></pre></td></tr></table></figure><p>查看每个标签的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后按照版本回退一节的方法使用<code>reset</code>指令回退至对应版本打包即可。</p><p>注意，标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag <span class="string">&#x27;v0.1&#x27;</span> (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或使用<code>git push origin --tags</code>推送所有标签。</p><p>如果要删除远程标签则先从本地删除标签，而后向远程同步删除指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:x/Read.gi0t</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程Git</a></p><p>2.<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><p>3.<a href="https://git-scm.com/">Git官方网站</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期做项目用Github比较频繁，简单记录一下Git的主要操作方式，比较复杂的部分就略过了，主要是以使用为目的&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;blockquot</summary>
      
    
    
    
    <category term="软件文档" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析精要</title>
    <link href="http://example.com/2021/05/24/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B2%BE%E8%A6%81/"/>
    <id>http://example.com/2021/05/24/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B2%BE%E8%A6%81/</id>
    <published>2021-05-24T10:53:01.000Z</published>
    <updated>2021-05-24T10:53:01.803Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python爬虫精要</title>
    <link href="http://example.com/2021/05/24/Python%E7%88%AC%E8%99%AB%E7%B2%BE%E8%A6%81/"/>
    <id>http://example.com/2021/05/24/Python%E7%88%AC%E8%99%AB%E7%B2%BE%E8%A6%81/</id>
    <published>2021-05-24T10:52:26.000Z</published>
    <updated>2021-05-24T10:52:26.035Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>我走的路和高山的雪</title>
    <link href="http://example.com/2021/04/16/%E6%88%91%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%92%8C%E9%AB%98%E5%B1%B1%E7%9A%84%E9%9B%AA/"/>
    <id>http://example.com/2021/04/16/%E6%88%91%E8%B5%B0%E7%9A%84%E8%B7%AF%E5%92%8C%E9%AB%98%E5%B1%B1%E7%9A%84%E9%9B%AA/</id>
    <published>2021-04-16T04:15:52.000Z</published>
    <updated>2021-04-16T06:55:54.277Z</updated>
    
    <content type="html"><![CDATA[<p>劫后余生，才知命运无常。</p><p>三场大火，烧光了所有希望，我站在熊熊烈焰面前，只一步就万劫不复，人类的悲欢从不相通，我只觉得他们吵闹，他们呼喊着，投来同情的目光，却只能远远的望着。这一刻我才发现，很多事情，除了自己咬着牙硬抗，没人能帮的了你。不怪朋友袖手旁观，也不怪父母相对无言，有些事情，你懂，他们未必也明白。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;劫后余生，才知命运无常。&lt;/p&gt;
&lt;p&gt;三场大火，烧光了所有希望，我站在熊熊烈焰面前，只一步就万劫不复，人类的悲欢从不相通，我只觉得他们吵闹，他们呼喊着，投来同情的目光，却只能远远的望着。这一刻我才发现，很多事情，除了自己咬着牙硬抗，没人能帮的了你。不怪朋友袖手旁观，也不怪</summary>
      
    
    
    
    <category term="沉思录" scheme="http://example.com/categories/%E6%B2%89%E6%80%9D%E5%BD%95/"/>
    
    
    <category term="人生" scheme="http://example.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>CS自学路线与课程推荐</title>
    <link href="http://example.com/2021/04/13/CS%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90/"/>
    <id>http://example.com/2021/04/13/CS%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90/</id>
    <published>2021-04-13T12:30:38.000Z</published>
    <updated>2021-04-13T15:33:43.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS基础课程自学路线与课程推荐"><a href="#CS基础课程自学路线与课程推荐" class="headerlink" title="CS基础课程自学路线与课程推荐"></a>CS基础课程自学路线与课程推荐</h1><p>简单记录我在自学路上所接触和选择的一些优秀课程，供自己回顾，各位同样奋战在CS自学路上的朋友也可以留作参考</p><p>注：本人也在学习中，不是每一门课程都看过，里面每一门课程都需要几个月的时间奋战，我基本都是选择其一学习，不要陷入焦虑，加粗的是我学习的路线。</p><hr><h3 id="计算机入门"><a href="#计算机入门" class="headerlink" title="计算机入门"></a>计算机入门</h3><h5 id="公开课程："><a href="#公开课程：" class="headerlink" title="公开课程："></a>公开课程：</h5><ul><li><strong>哈佛大学 CS50</strong>   </li><li>斯坦福大学 CS101</li><li>麻省理工学院 6.00.1</li></ul><h5 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul><li>《编码》： 一本讲清编码原理的书</li></ul><hr><h3 id="计算机程序结构与抽象"><a href="#计算机程序结构与抽象" class="headerlink" title="计算机程序结构与抽象"></a>计算机程序结构与抽象</h3><h5 id="公开课程：-1"><a href="#公开课程：-1" class="headerlink" title="公开课程："></a>公开课程：</h5><ul><li><p><strong>加州大学伯克利分校  CS61A</strong></p></li><li><p>斯坦福大学 CS106A  [Python]  </p></li><li><p>卡内基梅隆大学 CMU 15-122 </p></li></ul><h5 id="书籍推荐：-1"><a href="#书籍推荐：-1" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><p>《计算机程序的构造和解释》</p><blockquote><p>SICP 可以教会你编程语言的核心思想，懂得了程序设计和语言构成，你就可以快速掌握一门语言，这对于学习安全或是软件移植都是很关键的。</p></blockquote><hr><h3 id="计算机系统架构与体系"><a href="#计算机系统架构与体系" class="headerlink" title="计算机系统架构与体系"></a>计算机系统架构与体系</h3><p>对于系统架构读过的不太多，网易云课堂上哈工大的计算机体系结构读了很疲惫，转战Nand2Tetris立马就兴奋了，不得不说有些国内讲的基础课程真的讲的太无聊了，听的都能睡着。</p><h5 id="公开课程：-2"><a href="#公开课程：-2" class="headerlink" title="公开课程："></a>公开课程：</h5><ul><li><strong>计算机系统要素  Nand2Tetris</strong>    </li></ul><blockquote><p>这本书讲的计算机架构自底向上的抽象，从简单的门电路开始讲起，慢慢构造CPU，主存，I/O，最后直接实现了一台基本的计算机硬件部分，这些都是纯靠Nand这个逻辑门硬搭建起来的你敢信，我当时就惊了。后半部分需要一些编程基础，但其实也还好，懂一点python的语法就没什么大问题，后半部分主要讲的是编译器和汇编器的实现，在加上构建了一个简单的操作系统。这门课好好学，真的是神课，学完你买一袋Nand门就能组台电脑（滑稽）。</p></blockquote><h5 id="书籍推荐：-2"><a href="#书籍推荐：-2" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul><li>计算机系统要素  Nand2Tetris的原书</li></ul><hr><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>问我为什么要先学数据结构与算法，很简单，考研啊！408的数据结构与算法占了35%，这个分你拿到了，再加上计网的简单部分有个15%，你就拿了5成的分数了，150分你已经拿到了75。</p><h5 id="公开课程：-3"><a href="#公开课程：-3" class="headerlink" title="公开课程："></a>公开课程：</h5><ul><li><strong>加州大学伯克利分校  CS61B</strong></li></ul><blockquote><p>cs61B也是门好课，虽然达不到神课的地步，但是学完了你应该就能刷leetcode了，这个成就还是很显著的，总比你刷C++ prime舒服多了吧。</p></blockquote><ul><li>斯坦福 CS106B</li><li>卡内基梅隆大学 CMU 15-210</li></ul><h5 id="书籍推荐：-3"><a href="#书籍推荐：-3" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul><li>算法导论  </li></ul><blockquote><p>老牌的算法大全，厚的能砸死人，但是确实看完能封神，一般都是浅浅看一遍。</p></blockquote><ul><li>大话数据结构</li></ul><blockquote><p>深入浅出的讲解数据结构，作为入门当小说看看挺好的。</p></blockquote><ul><li>算法图解</li></ul><blockquote><p>同样是入门书籍，看看培养兴趣挺好的。</p></blockquote><hr><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>我的计划里是计网放在CSAPP前面的，因为无论是Linux，Github使用，还是环境架设，都对计算机网络的了解程度要求很高，有的时候你不懂计网，很多时候看不清网络拓扑，思路完全是混乱的，比如你要用Python爬虫，或者是Python利用漏洞攻击软件，你连流量通过什么方式传递到另一台主机都不知道，什么是端口，怎么监听，怎么发送流量到端口，怎么转发端口，这些都不知道，那你会完全手足无措。</p><h5 id="公开课程：-4"><a href="#公开课程：-4" class="headerlink" title="公开课程："></a>公开课程：</h5><ul><li>斯坦福大学 CS144</li><li>网易云课堂 《计算机网络》</li></ul><h5 id="书籍推荐：-4"><a href="#书籍推荐：-4" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul><li><strong>计算机网络自顶而下</strong>  </li></ul><blockquote><p>好，又是一本神书，如果说Nand2Tetris在架构层面从下到上剖析的清清楚楚，那这本书就是把网络从上往下一点一点拆开讲的清清楚楚，这本书看完，你基本上可以理解大部分网络的连接过程。</p></blockquote><ul><li>计算机网络(谢希仁版)</li></ul><blockquote><p>这本书是我本科时候唯一一本跟计算机沾点边的书，很无奈，整个本科期间什么计算机的课程都不开，讲了一堆废物课程，到最后同年的战友连C都不会敲，JX文化课程的悲哀和瞎掰，回归正题，那时候边上课边翻觉得太复杂了，完全看不懂，这本书最好还是在看完自顶而下有一个完整的概念之后再去深入理解比较好。</p></blockquote><hr><h3 id="计算机系统与运行"><a href="#计算机系统与运行" class="headerlink" title="计算机系统与运行"></a>计算机系统与运行</h3><p>学完了以上，基本上就在应用层编写代码无障碍了，这个能力很关键，无论是未来搞安全还是搞开发，搞研究，快速把想法实现的能力还是很关键的，再加上SICP的程序结构，掌握新语言已经难度不大了，甚至还可以试着读读编译原理看看能不能自己重写编译器。</p><h5 id="公开课程"><a href="#公开课程" class="headerlink" title="公开课程:"></a>公开课程:</h5><ul><li><strong>卡内基梅隆大学 CSAPP 配套课程  （B站有）</strong></li><li>卡内基梅隆大学 CMU 15-213</li><li>加州大学伯克利大学 CS61C</li><li>斯坦福大学 CS107 </li></ul><h5 id="书籍推荐：-5"><a href="#书籍推荐：-5" class="headerlink" title="书籍推荐："></a>书籍推荐：</h5><ul><li>深入理解计算机系统 CSAPP </li></ul><blockquote><p>计算机领域的圣经级别书籍，北大的计算机系统导论，南大的计算机系统课程都是基于CSAPP的，这本书把操作系统，计算机组成结构和计算机网络都连接起来，还讲了汇编的一些理论，整合了很多零散内容。</p></blockquote><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>知乎文章《计算机名校路线课程》</li><li>网易云课堂  顶尖大学中文计算机课程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CS基础课程自学路线与课程推荐&quot;&gt;&lt;a href=&quot;#CS基础课程自学路线与课程推荐&quot; class=&quot;headerlink&quot; title=&quot;CS基础课程自学路线与课程推荐&quot;&gt;&lt;/a&gt;CS基础课程自学路线与课程推荐&lt;/h1&gt;&lt;p&gt;简单记录我在自学路上所接触和选择的一</summary>
      
    
    
    
    <category term="考研之路" scheme="http://example.com/categories/%E8%80%83%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="学习路线" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    <category term="计算机课程" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Markdown使用指南</title>
    <link href="http://example.com/2021/04/11/Markdown%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2021/04/11/Markdown%E6%8C%87%E5%8D%97/</id>
    <published>2021-04-11T02:31:39.000Z</published>
    <updated>2021-04-11T13:26:53.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown使用-指南"><a href="#Markdown使用-指南" class="headerlink" title="Markdown使用 指南"></a><strong>Markdown使用 指南</strong></h1><hr><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><hr><h3 id="使用-标记多级标题"><a href="#使用-标记多级标题" class="headerlink" title="使用#标记多级标题"></a>使用#标记多级标题</h3><blockquote><p>一级标题用#号来标记</p><p>二级标题用##号来标记</p><p>….. 依次类推</p></blockquote><h3 id="使用-和-标记一级和二级标题（部分支持）"><a href="#使用-和-标记一级和二级标题（部分支持）" class="headerlink" title="使用=和-标记一级和二级标题（部分支持）"></a>使用=和-标记一级和二级标题（部分支持）</h3><blockquote><p>一级标题用=======来标注</p><p>二级标题用————来标注</p></blockquote><hr><h2 id="Markdown段落格式"><a href="#Markdown段落格式" class="headerlink" title="Markdown段落格式"></a>Markdown段落格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote><p><em>斜体</em>   * *</p><p><strong>粗体</strong>  ** **</p><p><em><strong>斜粗体</strong></em>   * * *  * * *</p></blockquote><h3 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h3><blockquote><p>分割线 *********</p><p><del>删除线</del>  ~~ ~~</p><p><u>下划线</u>  <u> </u></p><p>脚注  <a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8">^脚注</a></p></blockquote><hr><h2 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h2><ul><li><p>第一项</p><ul><li><p>第一个元素</p><ul><li>第二个元素</li></ul></li></ul></li><li><p>第二项</p><ul><li>第一个元素</li><li>第二个元素 </li></ul></li></ul><hr><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><h3 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h3><blockquote><p>区块引用符 &gt;</p><blockquote><p>第一层嵌套 &gt;&gt;</p></blockquote><blockquote><blockquote><p>第二层嵌套 &gt;&gt;&gt;</p></blockquote></blockquote></blockquote><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><blockquote><ul><li>第一项<ul><li>1.1</li><li>1.2</li></ul></li><li>第二项<ul><li>2.1</li><li>2.2</li></ul></li><li>第三项</li></ul></blockquote><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><ul><li><p>第一项</p><blockquote><p>学技术不仅是技术，而是梦想</p></blockquote></li><li><p>第二项 </p><blockquote><p>我们的目标是星辰大海。</p></blockquote></li></ul><hr><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><h3 id="单个片段代码"><a href="#单个片段代码" class="headerlink" title="单个片段代码"></a>单个片段代码</h3><blockquote><p><code>printf()</code>函数</p></blockquote><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码块使用三个反引号建立，以下是部分语言的实例代码：</p><blockquote><p><strong>Python实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Javascript实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;RUNO&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>PHP实例</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>链接使用<a href="http://www.baidu.com/">链接名称</a>建立，格式为<a href=""></a> ，也可以用变量设置来建立一个链接，赋值在文档末尾进行</p><blockquote><p>这个链接用 1 作为网址变量 [Google][1]</p></blockquote><hr><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><h3 id="通过markdown语法插入图片"><a href="#通过markdown语法插入图片" class="headerlink" title="通过markdown语法插入图片"></a>通过markdown语法插入图片</h3><p>Markdown 插入图片的语法格式如下：</p><blockquote><p><img src="" alt="属性文本"></p></blockquote><h3 id="通过Typora直接插入图片-编辑器必须是Typora编辑器"><a href="#通过Typora直接插入图片-编辑器必须是Typora编辑器" class="headerlink" title="通过Typora直接插入图片 (编辑器必须是Typora编辑器)"></a>通过Typora直接插入图片 (编辑器必须是Typora编辑器)</h3><blockquote><p>格式–&gt;图像–&gt;插入图片</p></blockquote><hr><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown表格格式如下：</p><blockquote><p>| |为分割单元格，-表示长度，：：为中央对齐</p></blockquote><table><thead><tr><th align="center">数据统计表</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">文字</td><td align="center">1</td><td align="center">4</td><td align="center">5</td><td align="center">8</td><td align="center">9</td></tr><tr><td align="center">图标</td><td align="center">2</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">0</td></tr></tbody></table><hr><h2 id="Markdown-拓展技巧"><a href="#Markdown-拓展技巧" class="headerlink" title="Markdown 拓展技巧"></a>Markdown 拓展技巧</h2><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的HTML元素有：</p><blockquote><p>&lt;kbd&gt;元素：使用<kbd>Shift</kbd> +<kbd>W</kbd> 执行操作</p><p>&lt;b&gt;元素：<b>123</b>    </p><p>&lt;i&gt;元素：<i>admin</i></p><p>&lt;em&gt;元素：<em>admin</em></p><p>&lt;sup&gt;元素：A<sup>1</sup></p><p>&lt;br&gt; 元素：换行</p></blockquote><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字，Markdown 使用反斜杠转义特殊字符：</p><blockquote><p>\ * \ * 转义文本加粗</p></blockquote><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如输入：</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$&#123;$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>会显示如下公式：</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p>1.菜鸟教程 <u><a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></u></p><p>2.知乎专栏 <u><a href="https://zhuanlan.zhihu.com/p/67153848">https://zhuanlan.zhihu.com/p/67153848</a></u></p><p>[1] : <a href="http://www.google.com/">http://www.google.com</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown使用-指南&quot;&gt;&lt;a href=&quot;#Markdown使用-指南&quot; class=&quot;headerlink&quot; title=&quot;Markdown使用 指南&quot;&gt;&lt;/a&gt;&lt;strong&gt;Markdown使用 指南&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="软件文档" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="Markdown" scheme="http://example.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>世界很大，人心很小</title>
    <link href="http://example.com/2021/04/10/%E4%B8%96%E7%95%8C%E5%BE%88%E5%A4%A7%EF%BC%8C%E4%BA%BA%E5%BF%83%E5%BE%88%E5%B0%8F/"/>
    <id>http://example.com/2021/04/10/%E4%B8%96%E7%95%8C%E5%BE%88%E5%A4%A7%EF%BC%8C%E4%BA%BA%E5%BF%83%E5%BE%88%E5%B0%8F/</id>
    <published>2021-04-10T00:42:43.000Z</published>
    <updated>2021-04-10T00:43:43.602Z</updated>
    
    
    
    
    <category term="沉思录" scheme="http://example.com/categories/%E6%B2%89%E6%80%9D%E5%BD%95/"/>
    
    
    <category term="沉思录" scheme="http://example.com/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件管理与权限控制</title>
    <link href="http://example.com/2021/04/10/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2021/04/10/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</id>
    <published>2021-04-10T00:23:09.000Z</published>
    <updated>2021-04-11T13:27:10.826Z</updated>
    
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="权限控制" scheme="http://example.com/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机考研综述</title>
    <link href="http://example.com/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%BB%BC%E8%BF%B0/"/>
    <id>http://example.com/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%BB%BC%E8%BF%B0/</id>
    <published>2021-04-10T00:17:36.000Z</published>
    <updated>2021-04-10T00:21:25.283Z</updated>
    
    <content type="html"><![CDATA[<p>this is an example</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;this is an example&lt;/p&gt;
</summary>
      
    
    
    
    <category term="考研之路" scheme="http://example.com/categories/%E8%80%83%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="研招信息" scheme="http://example.com/tags/%E7%A0%94%E6%8B%9B%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路</title>
    <link href="http://example.com/2021/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://example.com/2021/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</id>
    <published>2021-04-10T00:17:36.000Z</published>
    <updated>2021-05-03T11:22:50.362Z</updated>
    
    <content type="html"><![CDATA[<p>this is an example</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;this is an example&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
</feed>
